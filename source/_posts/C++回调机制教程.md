C++回调机制教程

# 引言

在 C++ 开发过程中，经常会遇到需要一个类在遇到某种情况下（比如触发了一个行为等等）需要驱使另一类去做某些行为的需求（也就是回调机制）。本文参考如下博文：[C++简单实现回调机制](https://blog.csdn.net/u012814856/article/details/73294124)进行讲解。

# Demo

A和B的打招呼程序。

## 需求

> 现在有两个人，一位是 A 先生，另一位是 B 先生。 
现在要求当 A 先生给 B 先生打了招呼之后，B 先生立马回复 A，向 A 问好。

## 抽象

这个过程抽象为三个类进行模拟：

角色 | 功能
---- | ---
A | 向B打招呼
B |  当A向自己打招呼时，向A打招呼
main | 创造A和B对象和控制A和B的行为

当我们看到上述的分析后，应该想到这么三个内容：

A 的作用：A 在这里干了什么呢？他是触发一次回调行为的触发点，也就是因为 A 进行了打招呼的行为，才有了 B 的回复的行为。也就是说：A 是触发方

B 的作用：B 在这里干的就多了。他在得知 A 向自己打招呼了之后，进行了回复。也就是说：B 是驱使方

回复事件：这是我们的回调行为本身，当 A 进行了打招呼的行为，B 进行了回调事件指定的行为

主过程：它掌控着时空，提供上述所有行为的必要条件

那么分析至此，我们已经拥有了写出这个程序的一切条件，接下来让我们一步一步分析一步一步实现吧。

# 实现：A、B、Event、main

首先，我们需要定义一个抽象的事件类，用来定义回复事件：

```C++
// event class
class CEvent {
public:
    virtual void hiReply() = 0;
};
```

这个类是这个方法的核心：

> 这个事件类是一个抽象的类： 
1.驱使方应该继承这个类并实现其内的具体功能 
2.触发方应该将此类包含为一个私有变量，当遇到触发事件的时候，通过此指针（父类指针）调用其具体实现的方法（由驱使方实现） 
3.还需要注意的一点是，为了方便调用，这个类中的方法需要全部声明为公有的，也就是需要在前面加 public 修饰

然后，我们需要实现 A 类，也就是事件触发方：

```C++
// person A class , call an event
class A {
public:
    A() : m_pEvent(NULL) {}
    void sayHi() {
        cout << "A: hello B" << endl;
        if (nullptr != m_pEvent) {
            m_pEvent->hiReply();
        }
    }
    void setEvent(CEvent *event) {
        m_pEvent = event;
    }
private:
    CEvent *m_pEvent;
};
```

# 参考

- [C++简单实现回调机制](https://blog.csdn.net/u012814856/article/details/73294124)