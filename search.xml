<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>linux-深度学习环境配置</title>
      <link href="/2018/03/31/linux-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <content type="html"><![CDATA[<h1 id="Ubuntu16-04-cuda8-0-GPU驱动配置"><a href="#Ubuntu16-04-cuda8-0-GPU驱动配置" class="headerlink" title="Ubuntu16.04 cuda8.0 GPU驱动配置"></a>Ubuntu16.04 cuda8.0 GPU驱动配置</h1><h2 id="GPU驱动配置"><a href="#GPU驱动配置" class="headerlink" title="GPU驱动配置"></a>GPU驱动配置</h2><p>根据GPU型号从相应网站下载驱动，例如使用NVIDIA Tesla M60，从<a href="http://www.nvidia.cn/Download/index.aspx?lang=cn" target="_blank" rel="noopener">NVIDIA网站</a>选择对应的型号和操作系统，CUDA Toolkit版本，下载驱动文件，如NVIDIA-Linux-x86_64-375.66.run，运行驱动文件，根据提示安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh  NVIDIA-Linux-x86_64-375.66.run</span><br></pre></td></tr></table></figure><h3 id="卸载掉原有驱动"><a href="#卸载掉原有驱动" class="headerlink" title="卸载掉原有驱动"></a>卸载掉原有驱动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove –purge nvidia*</span><br></pre></td></tr></table></figure><h3 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h3><p>安装驱动可能需要的依赖(可选):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> apt-get update</span><br><span class="line"></span><br><span class="line"><span class="variable">$sudo</span> apt-get install dkms build-essential linux-headers-generic</span><br></pre></td></tr></table></figure><p>进入命令行界面</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-Alt+F1</span><br></pre></td></tr></table></figure></code></pre><p>给驱动run文件赋予执行权限</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod a+x NVIDIA-Linux-x86_64-375.20.run</span><br></pre></td></tr></table></figure></code></pre><p>安装: 注意下面参数</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo ./NVIDIA-Linux-x86_64-375.20.run –no-x-check –no-nouveau-check –no-opengl-files </span><br><span class="line"><span class="comment"># –no-x-check安装驱动时关闭X服务 </span></span><br><span class="line"><span class="comment"># –no-nouveau-check 安装驱动时禁用nouveau </span></span><br><span class="line"><span class="comment"># –no-opengl-files 只安装驱动文件，不安装OpenGL文件</span></span><br></pre></td></tr></table></figure></code></pre><p>重启</p><p>注意：安装CUDA时一定使用runfile文件，这样可以进行选择。不再选择安装驱动，以及在弹出xorg.conf时选择NO<br>不要使用ubuntu设置中附加驱动中驱动</p><h2 id="安装cuda"><a href="#安装cuda" class="headerlink" title="安装cuda"></a>安装<a href="https://developer.nvidia.com/cuda-80-ga2-download-archive" target="_blank" rel="noopener">cuda</a></h2><p>注意这里下载的是cuda8.0的runfile（local）文件。 </p><p>这里是nvidia给出的官方安装指南（遇到问题时可以查阅) </p><p>下载完cuda8.0后，执行如下语句，运行runfile文件： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh cuda_8.0.27_linux.run</span><br></pre></td></tr></table></figure><p>因为驱动之前已经安装，这里就不要选择安装驱动。其余的都直接默认或者选择是即可。</p><p>使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/profile</span><br></pre></td></tr></table></figure><p>打开“profile”文件，在末尾处添加（注意不要有空格，不然会报错):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/cuda-8.0/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/cuda-8.0/lib64<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure><p>重启电脑：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><p>测试cuda的Samples:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/cuda-8.0/samples/1_Utilities/deviceQuery</span><br><span class="line">sudo make</span><br><span class="line">./deviceQuery</span><br></pre></td></tr></table></figure><h1 id="OpenCV3-1配置"><a href="#OpenCV3-1配置" class="headerlink" title="OpenCV3.1配置"></a>OpenCV3.1配置</h1><h2 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line"><span class="comment"># 必须的，gcc编译环境</span></span><br><span class="line"></span><br><span class="line">sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev</span><br><span class="line"><span class="comment"># 必须的,包括cmake等工具</span></span><br><span class="line"></span><br><span class="line">sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev</span><br><span class="line"><span class="comment"># 可选的，看个人需要，总共5M左右</span></span><br><span class="line"></span><br><span class="line">sudo apt-get install libv4l-dev</span><br></pre></td></tr></table></figure><h2 id="下载-源码"><a href="#下载-源码" class="headerlink" title="下载 源码"></a>下载 源码</h2><p><a href="https://opencv.org/releases.html" target="_blank" rel="noopener">OpenCV</a></p><p>或着用git clone：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/opencv310</span><br><span class="line">    <span class="comment"># opencv310为自己建的，源码将放在这里</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/Itseez/opencv.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/Itseez/opencv_contrib.git</span><br></pre></td></tr></table></figure><h2 id="CMake-Opencv源码"><a href="#CMake-Opencv源码" class="headerlink" title="CMake Opencv源码"></a>CMake Opencv源码</h2><p>建立一个编译目录（例如：/build）把cmake后的文件都放在这里边。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/opencv</span><br><span class="line">mkdir build  //建立一个build目录，把cmake的文件都放着里边</span><br><span class="line"><span class="built_in">cd</span> build　　　//进入build目录</span><br></pre></td></tr></table></figure><p>cmake时ippicv_linux_20151201.tgz总是不能成功下载，故cmake之前将./downloads/linux-808b791a6eac9ed78d32a7666804320e 文件拷贝至./opencv-3.1.0/3rdparty/ippicv/ 路径下(先执行一次cmake 命令生成文件路径，在将ippicv_linux_20151201.tgz复制进去) 首先，手动下载<a href="https://raw.githubusercontent.com/Itseez/opencv_3rdparty/81a676001ca8075ada498583e4166079e5744668/ippicv/ippicv_linux_20151201.tgz" target="_blank" rel="noopener">ippicv</a></p><p>然后开始cmake，这里需要注意几个cmake的参数，比较重要。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/<span class="built_in">local</span> WITH_LIBV4L=ON ..</span><br></pre></td></tr></table></figure><p>切记最后’..’两个点之前要加空格！！</p><h2 id="把代码编译成可执行文件"><a href="#把代码编译成可执行文件" class="headerlink" title="把代码编译成可执行文件"></a>把代码编译成可执行文件</h2><p>这里官方推荐使用多进程编译，推荐七个进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 报错：</span></span><br><span class="line"><span class="comment"># modules/cudalegacy/src/graphcuts.cpp:120:54: error: </span></span><br><span class="line"><span class="comment"># ‘NppiGraphcutState’ has not been declared</span></span><br><span class="line"><span class="comment"># typedef NppStatus (*init_func_t)(NppiSize oSize, </span></span><br><span class="line"><span class="comment"># NppiGraphcutState** ppState, Npp8u* pDeviceMem);</span></span><br><span class="line"><span class="comment"># 这是因为opecv3.0与cuda8.0不兼容导致的。解决办法： </span></span><br><span class="line"><span class="comment"># 修改 ～/opencv/modules/cudalegacy/src/graphcuts.cpp文件内容</span></span><br><span class="line"><span class="comment"># 将  </span></span><br><span class="line"><span class="comment"># #if !defined (HAVE_CUDA) || defined (CUDA_DISABLER)   </span></span><br><span class="line"><span class="comment"># 改为  </span></span><br><span class="line"><span class="comment"># #if !defined (HAVE_CUDA) || defined (CUDA_DISABLER) || (CUDART_VERSION &gt;= 8000) </span></span><br><span class="line">make -j7 <span class="comment"># 并行运行七个jobs，这一步也在build目录中进行</span></span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">如果你要在python下运行opencv库的情况下，那就必须安装安装python-opencv</span><br><span class="line">sudo apt-get install python-opencv</span><br></pre></td></tr></table></figure><h2 id="配置库文件路径"><a href="#配置库文件路径" class="headerlink" title="配置库文件路径"></a>配置库文件路径</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c <span class="string">'echo "/usr/local/lib" &gt; /etc/ld.so.conf.d/opencv.conf'</span></span><br><span class="line"><span class="comment">#或者直接打开/etc/ld.so.conf.d/opencv.conf，添加/usr/local/lib</span></span><br><span class="line"><span class="comment">#使配置生效</span></span><br><span class="line">sudo  ldconfig(重要)</span><br></pre></td></tr></table></figure><h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo vim/etc/bash.bashrc   </span><br><span class="line"><span class="comment">#在最后加入以下两行代码</span></span><br><span class="line">PKG_CONFIG_PATH=<span class="variable">$PKG_CONFIG_PATH</span>:/usr/<span class="built_in">local</span>/lib/pkgconfig </span><br><span class="line"><span class="built_in">export</span> PKG_CONFIG_PATH  </span><br><span class="line"><span class="comment">#使配置生效</span></span><br><span class="line">sudo <span class="built_in">source</span> /etc/bash.bashrc </span><br><span class="line">（该步骤可能会报错找不到命令，原因是<span class="built_in">source</span>为root命令</span><br><span class="line">su（进入root权限）</span><br></pre></td></tr></table></figure><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --modversion opencv</span><br><span class="line">pkg-config --cflags opencv</span><br></pre></td></tr></table></figure><h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><p>我是用python+opencv的，我这里直接运行opencv自带的python的例子程序，TX1自带摄像头不能用，需要使用外接USB摄像头，插入USB接口即可，无需安装驱动，也无需改动测试代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;opencv3.1.0_dir&gt;/samples/python/</span><br><span class="line">python video.py</span><br><span class="line">python edge.py</span><br><span class="line">python facedetect.py</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.liaohuqiu.net/cn/posts/ssh-public-key-auto-login/" target="_blank" rel="noopener">https://www.liaohuqiu.net/cn/posts/ssh-public-key-auto-login/</a></li><li><a href="https://blog.csdn.net/asukasmallriver/article/details/72927860" target="_blank" rel="noopener">https://blog.csdn.net/asukasmallriver/article/details/72927860</a></li><li><a href="https://blog.csdn.net/u011440558/article/details/78358447" target="_blank" rel="noopener">https://blog.csdn.net/u011440558/article/details/78358447</a></li></ol><h1 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.mtyun.com/library/how-to-install-caffe-on-centos7" target="_blank" rel="noopener">https://www.mtyun.com/library/how-to-install-caffe-on-centos7</a></li><li><a href="https://blog.csdn.net/qq_28413479/article/details/76377184" target="_blank" rel="noopener">https://blog.csdn.net/qq_28413479/article/details/76377184</a></li></ol>]]></content>
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Linux </category>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Linux </tag>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深度学习-TensorFlow教程</title>
      <link href="/2018/03/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-TensorFlow%E6%95%99%E7%A8%8B/"/>
      <content type="html"><![CDATA[<h1 id="TensorFlow简介"><a href="#TensorFlow简介" class="headerlink" title="TensorFlow简介"></a>TensorFlow简介</h1><p>TensorFlow是Google开发的一款神经网络的Python外部的结构包, 也是一个采用数据流图来进行数值计算的开源软件库.TensorFlow 让我们可以先绘制计算结构图, 也可以称是一系列可人机交互的计算操作, 然后把编辑好的Python文件 转换成 更高效的C++, 并在后端进行计算.</p><h1 id="TensorFlow安装"><a href="#TensorFlow安装" class="headerlink" title="TensorFlow安装"></a>TensorFlow安装</h1><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><h3 id="Dock安装"><a href="#Dock安装" class="headerlink" title="Dock安装"></a>Dock安装</h3><p>Docker安装请参考<a href="http://mapstec.com/2018/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4GPU%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">实验室GPU服务器部署教程</a></p><h3 id="TensorFlow安装方式一"><a href="#TensorFlow安装方式一" class="headerlink" title="TensorFlow安装方式一"></a>TensorFlow安装方式一</h3><ol><li><p>下载镜像</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull tensorflow/tensorflow</span><br></pre></td></tr></table></figure></li><li><p>创建Tensorflow容器</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --name my-tensorflow -it -p 8888:8888 -v ~/tensorflow:/<span class="built_in">test</span>/data tensorflow/tensorflow</span><br><span class="line"><span class="comment"># --name：创建的容器名，即my-tensorflow</span></span><br><span class="line"><span class="comment"># -it：保留命令行运行</span></span><br><span class="line"><span class="comment"># p 8888:8888：将本地的8888端口和http://localhost:8888/映射</span></span><br><span class="line"><span class="comment"># -v ~/tensorflow:/test/data:将本地的~/tensorflow挂载到容器内的/# test/data下</span></span><br><span class="line"><span class="comment"># tensorflow/tensorflow ：默认是tensorflow/tensorflow:latest,指定使用的镜像</span></span><br></pre></td></tr></table></figure></li><li><p>拷贝带token的URL在浏览器打开</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://[all ip addresses on your system]:8888/?token=649d7cab1734e01db75b6c2b476ea87aa0b24dde56662a27</span><br></pre></td></tr></table></figure></li><li><p>显示Jupyter Notebook，Jupyter Notebook（此前被称为 IPython notebook）是一个交互式笔记本。示例中已经显示了Tensorflow的入门教程，点开一个可以看见。</p></li><li><p>关闭容器</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop my-tensortflow</span><br></pre></td></tr></table></figure></li><li><p>再次打开</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start my-tensortflow</span><br></pre></td></tr></table></figure></li></ol><h3 id="TensorFlow安装方式二"><a href="#TensorFlow安装方式二" class="headerlink" title="TensorFlow安装方式二"></a>TensorFlow安装方式二</h3><ol><li><p>下载镜像</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull tensorflow/tensorflow</span><br></pre></td></tr></table></figure></li><li><p>创建Tensorflow容器</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name bash_tensorflow tensorflow/tensorflow /bin/bash</span><br><span class="line"><span class="comment"># 这样我们就创建了名为bash_tensorflow的容器</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>start命令启动容器</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start bash_tensorflow</span><br></pre></td></tr></table></figure></li><li><p>再连接上容器</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker attach bash_tensorflow</span><br><span class="line"><span class="comment"># 可以看到我们用终端连接上了容器，和操作Linux一样了。</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Pip安装"><a href="#Pip安装" class="headerlink" title="Pip安装"></a>Pip安装</h2><h3 id="Linux-和-MacOS"><a href="#Linux-和-MacOS" class="headerlink" title="Linux 和 MacOS"></a>Linux 和 MacOS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu/Linux 64-位 系统的执行代码:</span></span><br><span class="line">$ sudo apt-get install python-pip python-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mac OS X 系统的执行代码:</span></span><br><span class="line">$ sudo easy_install --upgrade pip</span><br><span class="line">$ sudo easy_install --upgrade six</span><br></pre></td></tr></table></figure><ol><li><p>CPU 版</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 2+ 的用户:</span></span><br><span class="line">$ pip install tensorflow</span><br><span class="line"></span><br><span class="line"><span class="comment"># python 3+ 的用户:</span></span><br><span class="line">$ pip3 install tensorflow</span><br></pre></td></tr></table></figure></li><li><p>GPU 版</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libcupti-dev</span><br><span class="line">$ sudo apt-get install python-pip python-dev   <span class="comment"># for Python 2.7</span></span><br><span class="line">$ sudo apt-get install python3-pip python3-dev <span class="comment"># for Python 3.n</span></span><br><span class="line">$ pip install tensorflow      <span class="comment"># Python 2.7; CPU support (no GPU support)</span></span><br><span class="line">$ pip3 install tensorflow     <span class="comment"># Python 3.n; CPU support (no GPU support)</span></span><br><span class="line">$ pip install tensorflow-gpu  <span class="comment"># Python 2.7;  GPU support</span></span><br><span class="line">$ pip3 install tensorflow-gpu <span class="comment"># Python 3.n; GPU support</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>测试</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow</span><br></pre></td></tr></table></figure></li></ol><h1 id="TensorFlow-教程"><a href="#TensorFlow-教程" class="headerlink" title="TensorFlow 教程"></a>TensorFlow 教程</h1><h2 id="Session-会话控制"><a href="#Session-会话控制" class="headerlink" title="Session 会话控制"></a>Session 会话控制</h2><p>参考：</p><ul><li><a href="https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/2-3-session/" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/2-3-session/</a></li></ul><p>Session 是 Tensorflow 为了控制,和输出文件的执行的语句. 运行 session.run() 可以获得你要得知的运算结果, 或者是你所要运算的部分.</p><p>例子讲解：建立两个 matrix ,输出两个 matrix 矩阵相乘的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># create two matrixes</span></span><br><span class="line"></span><br><span class="line">matrix1 = tf.constant([[<span class="number">3</span>,<span class="number">3</span>]])</span><br><span class="line">matrix2 = tf.constant([[<span class="number">2</span>],</span><br><span class="line">                       [<span class="number">2</span>]])</span><br><span class="line">product = tf.matmul(matrix1,matrix2)</span><br></pre></td></tr></table></figure><p>因为 product 不是直接计算的步骤, 所以我们会要使用 Session 来激活 product 并得到计算结果. 有两种形式使用会话控制 Session 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># method 1</span></span><br><span class="line">sess = tf.Session()</span><br><span class="line">result = sess.run(product)</span><br><span class="line">print(result)</span><br><span class="line">sess.close()</span><br><span class="line"><span class="comment"># [[12]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># method 2</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    result2 = sess.run(product)</span><br><span class="line">    print(result2)</span><br><span class="line"><span class="comment"># [[12]]</span></span><br></pre></td></tr></table></figure><h2 id="Variable-变量"><a href="#Variable-变量" class="headerlink" title="Variable 变量"></a>Variable 变量</h2><p>参考：</p><ul><li><a href="https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/2-4-variable/" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/2-4-variable/</a></li></ul><p>在 Tensorflow 中，定义了某字符串是变量，它才是变量。定义语法： state = tf.Variable()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">state = tf.Variable(<span class="number">0</span>, name=<span class="string">'counter'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义常量 one</span></span><br><span class="line">one = tf.constant(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义加法步骤 (注: 此步并没有直接计算)</span></span><br><span class="line">new_value = tf.add(state, one)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 State 更新成 new_value</span></span><br><span class="line">update = tf.assign(state, new_value)</span><br></pre></td></tr></table></figure><p>如果你在 Tensorflow 中设定了变量，那么初始化变量是最重要的！！所以定义了变量以后, 一定要定义 init = tf.initialize_all_variables() .</p><p>到这里变量还是没有被激活，需要再在 sess 里, sess.run(init) , 激活 init 这一步.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果定义 Variable, 就一定要 initialize</span></span><br><span class="line"><span class="comment"># init = tf.initialize_all_variables() # tf 马上就要废弃这种写法</span></span><br><span class="line">init = tf.global_variables_initializer()  <span class="comment"># 替换成这样就好</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用 Session</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(init)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        sess.run(update)</span><br><span class="line">        print(sess.run(state))</span><br></pre></td></tr></table></figure><p>注意：直接 print(state) 不起作用！！</p><p>一定要把 sess 的指针指向 state 再进行 print 才能得到想要的结果！</p><h2 id="Placeholder-传入值"><a href="#Placeholder-传入值" class="headerlink" title="Placeholder 传入值"></a>Placeholder 传入值</h2><p>参考：</p><ul><li><a href="https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/2-5-placeholde/" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/2-5-placeholde/</a></li></ul><p>placeholder 是 Tensorflow 中的占位符，暂时储存变量.</p><p>Tensorflow 如果想要从外部传入data, 那就需要用到 tf.placeholder(), 然后以这种形式传输数据 sess.run(<strong>*, feed_dict={input: </strong>}).</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment">#在 Tensorflow 中需要定义 placeholder 的 type ，一般为 float32 形式</span></span><br><span class="line">input1 = tf.placeholder(tf.float32)</span><br><span class="line">input2 = tf.placeholder(tf.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># mul = multiply 是将input1和input2 做乘法运算，并输出为 output </span></span><br><span class="line">ouput = tf.multiply(input1, input2)</span><br></pre></td></tr></table></figure><p>接下来, 传值的工作交给了 sess.run() , 需要传入的值放在了feed_dict={} 并一一对应每一个 input. placeholder 与 feed_dict={} 是绑定在一起出现的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    print(sess.run(ouput, feed_dict=&#123;input1: [<span class="number">7.</span>], input2: [<span class="number">2.</span>]&#125;))</span><br><span class="line"><span class="comment"># [ 14.]</span></span><br></pre></td></tr></table></figure><h2 id="建造神经网络"><a href="#建造神经网络" class="headerlink" title="建造神经网络"></a>建造神经网络</h2><p>参考：</p><ul><li><a href="https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/3-2-create-NN/" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/3-2-create-NN/</a></li></ul><h3 id="add-layer-功能"><a href="#add-layer-功能" class="headerlink" title="add_layer 功能"></a>add_layer 功能</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_layer</span><span class="params">(inputs, in_size, out_size, activation_function=None)</span>:</span></span><br><span class="line">    Weights = tf.Variable(tf.random_normal([in_size, out_size]))</span><br><span class="line">    biases = tf.Variable(tf.zeros([<span class="number">1</span>, out_size]) + <span class="number">0.1</span>)</span><br><span class="line">    Wx_plus_b = tf.matmul(inputs, Weights) + biases</span><br><span class="line">    <span class="keyword">if</span> activation_function <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        outputs = Wx_plus_b</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        outputs = activation_function(Wx_plus_b)</span><br><span class="line">    <span class="keyword">return</span> outputs</span><br></pre></td></tr></table></figure><h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><p>构建所需的数据。 这里的x_data和y_data并不是严格的一元二次函数的关系，因为我们多加了一个noise,这样看起来会更像真实情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x_data = np.linspace(<span class="number">-1</span>,<span class="number">1</span>,<span class="number">300</span>, dtype=np.float32)[:, np.newaxis]</span><br><span class="line">noise = np.random.normal(<span class="number">0</span>, <span class="number">0.05</span>, x_data.shape).astype(np.float32)</span><br><span class="line">y_data = np.square(x_data) - <span class="number">0.5</span> + noise</span><br></pre></td></tr></table></figure><p>利用占位符定义我们所需的神经网络的输入。 tf.placeholder()就是代表占位符，这里的None代表无论输入有多少都可以，因为输入只有一个特征，所以这里是1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xs = tf.placeholder(tf.float32, [<span class="keyword">None</span>, <span class="number">1</span>])</span><br><span class="line">ys = tf.placeholder(tf.float32, [<span class="keyword">None</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>接下来，我们就可以开始定义神经层了。 通常神经层都包括输入层、隐藏层和输出层。这里的输入层只有一个属性， 所以我们就只有一个输入；隐藏层我们可以自己假设，这里我们假设隐藏层有10个神经元； 输出层和输入层的结构是一样的，所以我们的输出层也是只有一层。 所以，我们构建的是——输入层1个、隐藏层10个、输出层1个的神经网络。</p><h3 id="搭建网络"><a href="#搭建网络" class="headerlink" title="搭建网络"></a>搭建网络</h3><p>利用之前的add_layer()函数，这里使用 Tensorflow 自带的激励函数tf.nn.relu。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l1 = add_layer(xs, <span class="number">1</span>, <span class="number">10</span>, activation_function=tf.nn.relu)</span><br></pre></td></tr></table></figure><p>接着，定义输出层。此时的输入就是隐藏层的输出——l1，输入有10层（隐藏层的输出层），输出有1层。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prediction = add_layer(l1, <span class="number">10</span>, <span class="number">1</span>, activation_function=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p>计算预测值prediction和真实值的误差，对二者差的平方求和再取平均。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loss = tf.reduce_mean(tf.reduce_sum(tf.square(ys - prediction),</span><br><span class="line">                     reduction_indices=[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><p>接下来，是很关键的一步，如何让机器学习提升它的准确率。tf.train.GradientDescentOptimizer()中的值通常都小于1，这里取的是0.1，代表以0.1的效率来最小化误差loss。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_step = tf.train.GradientDescentOptimizer(<span class="number">0.1</span>).minimize(loss)</span><br></pre></td></tr></table></figure><p>使用变量时，都要对它进行初始化，这是必不可少的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># init = tf.initialize_all_variables() # tf 马上就要废弃这种写法</span></span><br><span class="line">init = tf.global_variables_initializer()  <span class="comment"># 替换成这样就好</span></span><br></pre></td></tr></table></figure><p>定义Session，并用 Session 来执行 init 初始化步骤。 （注意：在tensorflow中，只有session.run()才会执行我们定义的运算。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(init)</span><br></pre></td></tr></table></figure><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>机器学习的内容是train_step, 用 Session 来 run 每一次 training 的数据，逐步提升神经网络的预测准确性。 (注意：当运算要用到placeholder时，就需要feed_dict这个字典来指定输入。)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    <span class="comment"># training</span></span><br><span class="line">    sess.run(train_step, feed_dict=&#123;xs: x_data, ys: y_data&#125;)</span><br></pre></td></tr></table></figure><p>每50步我们输出一下机器学习的误差。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># to see the step improvement</span></span><br><span class="line">    print(sess.run(loss, feed_dict=&#123;xs: x_data, ys: y_data&#125;))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.021204619</span></span><br><span class="line"><span class="number">0.009980676</span></span><br><span class="line"><span class="number">0.007174721</span></span><br><span class="line"><span class="number">0.006633012</span></span><br><span class="line"><span class="number">0.00622975</span></span><br><span class="line"><span class="number">0.005894037</span></span><br><span class="line"><span class="number">0.005621146</span></span><br><span class="line"><span class="number">0.0053801737</span></span><br><span class="line"><span class="number">0.00519997</span></span><br><span class="line"><span class="number">0.005050111</span></span><br><span class="line"><span class="number">0.004922069</span></span><br><span class="line"><span class="number">0.0048095705</span></span><br><span class="line"><span class="number">0.0047140927</span></span><br><span class="line"><span class="number">0.0046234317</span></span><br><span class="line"><span class="number">0.0045334958</span></span><br><span class="line"><span class="number">0.0044504963</span></span><br><span class="line"><span class="number">0.004378309</span></span><br><span class="line"><span class="number">0.0043256846</span></span><br><span class="line"><span class="number">0.0042802156</span></span><br><span class="line"><span class="number">0.0042369063</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 深度学习 </category>
          
          <category> TF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> TF </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>实验室GPU服务器部署教程</title>
      <link href="/2018/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4GPU%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/"/>
      <content type="html"><![CDATA[<h1 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a><a href="https://docs.docker.com/install/linux/ubuntu/" target="_blank" rel="noopener">Docker</a> 安装</h1><p>参考：<a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/#set-up-the-repository" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/ubuntu/#set-up-the-repository</a></p><ol><li><p>Prerequisites</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">To install Docker CE, you need the 64-bit version of one of these Ubuntu versions:</span><br><span class="line"></span><br><span class="line">Artful 17.10 (Docker CE 17.11 Edge and higher only)</span><br><span class="line">Xenial 16.04 (LTS)</span><br><span class="line">Trusty 14.04 (LTS)</span><br></pre></td></tr></table></figure></li><li><p>Uninstall old versions</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io</span><br></pre></td></tr></table></figure></li><li><p>Install Docker CE</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"><span class="comment"># Install packages to allow apt to use a repository over HTTPS</span></span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br><span class="line"><span class="comment"># Add Docker’s official GPG key:</span></span><br><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">$ sudo apt-key fingerprint 0EBFCD88</span><br><span class="line"><span class="comment"># Use the following command to set up the stable repository.</span></span><br><span class="line">$ sudo add-apt-repository \</span><br><span class="line">   <span class="string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">   <span class="variable">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">   stable"</span></span><br><span class="line">$ sudo apt-get update</span><br><span class="line"><span class="comment"># Install the latest version of Docker CE</span></span><br><span class="line">$ sudo apt-get install docker-ce</span><br><span class="line"><span class="comment"># Verify that Docker CE is installed correctly by running the hello-world image.</span></span><br><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>UPGRADE DOCKER CE</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>Uninstall Docker CE</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get purge docker-ce</span><br><span class="line">$ sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure></li></ol><h1 id="Docker-备份、恢复和迁移"><a href="#Docker-备份、恢复和迁移" class="headerlink" title="Docker 备份、恢复和迁移"></a>Docker 备份、恢复和迁移</h1><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>首先，为了备份Docker中的容器，我们会想看看我们想要备份的容器列表。要达成该目的，我们需要在我们运行着Docker引擎，并已创建了容器的Linux机器中运行 docker ps 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker ps</span></span><br></pre></td></tr></table></figure><p>在此之后，我们要选择我们想要备份的容器，然后去创建该容器的快照。我们可以使用 docker commit 命令来创建快照。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker commit -p 30b8f18f20b4 container-backup</span></span><br></pre></td></tr></table></figure><p>该命令会生成一个作为Docker镜像的容器快照，我们可以通过运行 docker images 命令来查看Docker镜像，如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker images</span></span><br></pre></td></tr></table></figure><p>正如我们所看见的，上面做的快照已经作为Docker镜像保存了。现在，为了备份该快照，我们有两个选择，一个是我们可以登录进Docker注册中心，并推送该镜像；另一个是我们可以将Docker镜像打包成tar包备份，以供今后使用。</p><p>如果我们想要在<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker注册中心</a>上传或备份镜像，我们只需要运行 docker login 命令来登录进Docker注册中心，然后推送所需的镜像即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker login</span></span><br><span class="line"><span class="comment"># docker tag a25ddfec4d2a arunpyasi/container-backup:test</span></span><br><span class="line"><span class="comment"># docker push arunpyasi/container-backup</span></span><br></pre></td></tr></table></figure><p>如果我们不想备份到docker注册中心，而是想要将此镜像保存在本地机器中，以供日后使用，那么我们可以将其作为tar包备份。要完成该操作，我们需要运行以下 docker save 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker save -o ~/container-backup.tar container-backup</span></span><br></pre></td></tr></table></figure><p>要验证tar包是否已经生成，我们只需要在保存tar包的目录中运行 ls 命令即可。</p><h2 id="恢复容器"><a href="#恢复容器" class="headerlink" title="恢复容器"></a>恢复容器</h2><p>接下来，在我们成功备份了我们的Docker容器后，我们现在来恢复这些制作了Docker镜像快照的容器。如果我们已经在注册中心推送了这些Docker镜像，那么我们仅仅需要把那个Docker镜像拖回并直接运行即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker pull arunpyasi/container-backup:test</span></span><br></pre></td></tr></table></figure><p>但是，如果我们将这些Docker镜像作为tar包文件备份到了本地，那么我们只要使用 docker load 命令，后面加上tar包的备份路径，就可以加载该Docker镜像了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker load -i ~/container-backup.tar</span></span><br></pre></td></tr></table></figure><p>现在，为了确保这些Docker镜像已经加载成功，我们来运行 docker images 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker images</span></span><br></pre></td></tr></table></figure><p>在镜像被加载后，我们将用加载的镜像去运行Docker容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker run -d -p 80:80 container-backup</span></span><br></pre></td></tr></table></figure><h2 id="迁移Docker容器"><a href="#迁移Docker容器" class="headerlink" title="迁移Docker容器"></a>迁移Docker容器</h2><p>迁移容器同时涉及到了上面两个操作，备份和恢复。我们可以将任何一个Docker容器从一台机器迁移到另一台机器。在迁移过程中，首先我们将把容器备份为Docker镜像快照。然后，该Docker镜像或者是被推送到了Docker注册中心，或者被作为tar包文件保存到了本地。如果我们将镜像推送到了Docker注册中心，我们简单地从任何我们想要的机器上使用 docker run 命令来恢复并运行该容器。但是，如果我们将镜像打包成tar包备份到了本地，我们只需要拷贝或移动该镜像到我们想要的机器上，加载该镜像并运行需要的容器即可。</p><h1 id="Docker-SSH-访问"><a href="#Docker-SSH-访问" class="headerlink" title="Docker SSH 访问"></a>Docker SSH 访问</h1><p>假设我们已经pull了一个docker 镜像，如下图所示的tensorflow/tensorflow。</p><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --name my-tensorflow -it -p 8888:8888 -v ~/tensorflow:/<span class="built_in">test</span>/data tensorflow/tensorflow</span><br><span class="line"><span class="comment"># --name：创建的容器名，即my-tensorflow</span></span><br><span class="line"><span class="comment"># -it：保留命令行运行</span></span><br><span class="line"><span class="comment"># p 8888:8888：将本地的8888端口和http://localhost:8888/映射</span></span><br><span class="line"><span class="comment"># -v ~/tensorflow:/test/data:将本地的~/tensorflow挂载到容器内的/# test/data下</span></span><br><span class="line"><span class="comment"># tensorflow/tensorflow ：默认是tensorflow/tensorflow:latest,指定使用的镜像</span></span><br></pre></td></tr></table></figure></code></pre><p>如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name tf tensorflow/tensorflow /bin/bash</span><br><span class="line"><span class="comment"># 这样我们就创建了名为tf的容器</span></span><br><span class="line">docker start tf</span><br><span class="line">docker attach tf</span><br></pre></td></tr></table></figure><h2 id="修改容器的root密码"><a href="#修改容器的root密码" class="headerlink" title="修改容器的root密码"></a>修改容器的root密码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-get install vim -y</span><br><span class="line">apt-get install openssh-server -y</span><br><span class="line">apt-get install passwd</span><br><span class="line">passwd root</span><br></pre></td></tr></table></figure><h2 id="修改ssh配置"><a href="#修改ssh配置" class="headerlink" title="修改ssh配置"></a>修改ssh配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line"><span class="comment"># 修改PermitRootLogin yes  </span></span><br><span class="line">UsePAM no</span><br></pre></td></tr></table></figure><h2 id="启动ssh服务"><a href="#启动ssh服务" class="headerlink" title="启动ssh服务"></a>启动ssh服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service ssh start</span><br></pre></td></tr></table></figure><h2 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h2 id="提交容器成为新的镜像"><a href="#提交容器成为新的镜像" class="headerlink" title="提交容器成为新的镜像"></a>提交容器成为新的镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如叫做ubuntu-ssh，输入docker commit 容器ID ubuntu-ssh</span><br></pre></td></tr></table></figure><h2 id="启动这个镜像的容器，并映射本地的一个闲置的端口"><a href="#启动这个镜像的容器，并映射本地的一个闲置的端口" class="headerlink" title="启动这个镜像的容器，并映射本地的一个闲置的端口"></a>启动这个镜像的容器，并映射本地的一个闲置的端口</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p 50001:22 tf-ssh /bin/bash</span><br></pre></td></tr></table></figure><h2 id="ssh登录"><a href="#ssh登录" class="headerlink" title="ssh登录"></a>ssh登录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@127.0.0.1 -p 50001</span><br></pre></td></tr></table></figure><h2 id="Docker后台运行"><a href="#Docker后台运行" class="headerlink" title="Docker后台运行"></a>Docker后台运行</h2><h1 id="阿里云加速器设置"><a href="#阿里云加速器设置" class="headerlink" title="阿里云加速器设置"></a>阿里云加速器设置</h1><p>由于官方Docker Hub网络速度较慢，这里使用阿里云提供的<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>. 需要配置阿里云加速器，官方说明如下：</p><ol><li><p>针对Docker客户端版本大于1.10的用户： </p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 您可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器</span></span><br><span class="line">$ sudo mkdir -p /etc/docker</span><br><span class="line">$ sudo tee /etc/docker/daemon.json &lt;&lt;-‘EOF’ </span><br><span class="line">  &#123; </span><br><span class="line">  “registry-mirrors”: [“https://fird1mfg.mirror.aliyuncs.com“] </span><br><span class="line">  &#125; </span><br><span class="line">  EOF</span><br><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>针对Docker客户的版本小于等于1.10的用户或者想配置启动参数，可以使用下面的命令将配置添加到docker daemon的启动参数中.</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 12.04 14.04的用户:</span></span><br><span class="line">$ <span class="built_in">echo</span> “DOCKER_OPTS=/”<span class="variable">$DOCKER_OPTS</span> –registry-mirror=https://fird1mfg.mirror.aliyuncs.com/”” | sudo tee -a /etc/default/docker</span><br><span class="line">$ sudo service docker restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ubuntu 15.04 16.04的用户</span></span><br><span class="line">$ sudo mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line">$ sudo tee /etc/systemd/system/docker.service.d/mirror.conf &lt;&lt;-‘EOF’ </span><br><span class="line">[Service] </span><br><span class="line">ExecStart=/usr/bin/docker daemon -H fd:// –registry-mirror=https://fird1mfg.mirror.aliyuncs.com </span><br><span class="line">EOF</span><br><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure></li></ol><h1 id="NVIDIA-Docker安装"><a href="#NVIDIA-Docker安装" class="headerlink" title="NVIDIA-Docker安装"></a><a href="https://github.com/NVIDIA/nvidia-docker/wiki" target="_blank" rel="noopener">NVIDIA-Docker</a>安装</h1><ol><li><p>Prerequisties</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GNU/Linux x86_64 with kernel version &gt; 3.10 </span><br><span class="line">Docker &gt;= 1.9 (official docker-engine, docker-ce or docker-ee only) </span><br><span class="line">NVIDIA GPU with Architecture &gt; Fermi (2.1) </span><br><span class="line">NVIDIA drivers &gt;= 340.29 with binary nvidia-modprobe (驱动版本与CUDA计算能力相关)</span><br></pre></td></tr></table></figure></li><li><p>CUDA与NVIDIA driver安装 <a href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="noopener">cuda</a></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">处理NVIDIA-Docker依赖项 NVIDIA drivers &gt;= 340.29 with binary nvidia-modprobe 要求. </span><br><span class="line">根据显卡，下载对应版本的CUDA并进行安装.</span><br></pre></td></tr></table></figure></li><li><p>NVIDIA-Docker安装</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Install nvidia-docker and nvidia-docker-plugin</span></span><br><span class="line"></span><br><span class="line">wget -P /tmp https://github.com/NVIDIA/nvidia-docker/releases/download/v1.0.1/nvidia-docker_1.0.1-1_amd64.deb</span><br><span class="line">sudo dpkg -i /tmp/nvidia-docker*.deb &amp;&amp; rm /tmp/nvidia-docker*.deb</span><br><span class="line"><span class="comment">#Test nvidia-smi</span></span><br><span class="line"></span><br><span class="line">sudo nvidia-docker run –rm nvidia/cuda nvidia-smi</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>默认用nvdia-docker替代docker命令：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'alias docker=nvidia-docker'</span> &gt;&gt; ~/.bashrc</span><br><span class="line">bash</span><br></pre></td></tr></table></figure></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://jingyan.baidu.com/article/a3aad71aa180e7b1fa009676.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/a3aad71aa180e7b1fa009676.html</a></li><li><a href="https://github.com/ufoym/deepo#Installation" target="_blank" rel="noopener">https://github.com/ufoym/deepo#Installation</a></li><li><a href="https://hub.docker.com/r/ufoym/deepo/" target="_blank" rel="noopener">https://hub.docker.com/r/ufoym/deepo/</a></li><li><a href="https://github.com/fatedier/frp/blob/master/README_zh.md#frp-%E7%9A%84%E4%BD%9C%E7%94%A8" target="_blank" rel="noopener">https://github.com/fatedier/frp/blob/master/README_zh.md#frp-%E7%9A%84%E4%BD%9C%E7%94%A8</a></li><li><a href="https://ranpox.github.io/2018/01/14/notification-of-gpu-server/" target="_blank" rel="noopener">https://ranpox.github.io/2018/01/14/notification-of-gpu-server/</a></li></ol>]]></content>
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 深度学习 </category>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 环境配置 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python多线程教程</title>
      <link href="/2018/03/26/python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%95%99%E7%A8%8B/"/>
      <content type="html"><![CDATA[<h1 id="什么多线程"><a href="#什么多线程" class="headerlink" title="什么多线程"></a>什么多线程</h1><p>多线程是加速程序计算的有效方式</p><h2 id="添加线程-Thread"><a href="#添加线程-Thread" class="headerlink" title="添加线程 Thread"></a>添加线程 Thread</h2><ul><li>导入模块</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br></pre></td></tr></table></figure><ul><li>获取已激活的线程数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threading.active_count()</span><br></pre></td></tr></table></figure><ul><li>查看所有线程信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threading.enumerate()</span><br></pre></td></tr></table></figure><ul><li>查看现在正在运行的线程</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threading.current_thread()</span><br></pre></td></tr></table></figure><ul><li>添加线程</li></ul><p>threading.Thread()接收参数target代表这个线程要完成的任务，需自行定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_job</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'This is a thread of %s'</span> % threading.current_thread())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    thread = threading.Thread(target=thread_job,)   <span class="comment"># 定义线程 </span></span><br><span class="line">    thread.start()  <span class="comment"># 让线程开始工作</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="join-功能"><a href="#join-功能" class="headerlink" title="join 功能"></a>join 功能</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_job</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"T1 start\n"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(<span class="number">0.1</span>) <span class="comment"># 任务间隔0.1s</span></span><br><span class="line">    print(<span class="string">"T1 finish\n"</span>)</span><br><span class="line"></span><br><span class="line">added_thread = threading.Thread(target=thread_job, name=<span class="string">'T1'</span>)</span><br><span class="line">added_thread.start()</span><br><span class="line">print(<span class="string">"all done\n"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">thread_1.start() <span class="comment"># start T1</span></span><br><span class="line">thread_2.start() <span class="comment"># start T2</span></span><br><span class="line">thread_2.join() <span class="comment"># join for T2</span></span><br><span class="line">thread_1.join() <span class="comment"># join for T1</span></span><br><span class="line">print(<span class="string">"all done\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">T1 start</span></span><br><span class="line"><span class="string">T2 start</span></span><br><span class="line"><span class="string">T2 finish</span></span><br><span class="line"><span class="string">T1 finish</span></span><br><span class="line"><span class="string">all done</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h2 id="储存进程结果-Queue"><a href="#储存进程结果-Queue" class="headerlink" title="储存进程结果 Queue"></a>储存进程结果 Queue</h2><ul><li>导入线程,队列的标准模块</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br></pre></td></tr></table></figure><ul><li>定义一个被多线程调用的函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job</span><span class="params">(l,q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range (len(l)):</span><br><span class="line">        l[i] = l[i]**<span class="number">2</span></span><br><span class="line">    q.put(l)   <span class="comment">#多线程调用的函数不能用return返回值</span></span><br></pre></td></tr></table></figure><p>完整的代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job</span><span class="params">(l,q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range (len(l)):</span><br><span class="line">        l[i] = l[i]**<span class="number">2</span></span><br><span class="line">    q.put(l)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multithreading</span><span class="params">()</span>:</span></span><br><span class="line">    q =Queue()</span><br><span class="line">    threads = []</span><br><span class="line">    data = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        t = threading.Thread(target=job,args=(data[i],q))</span><br><span class="line">        t.start()</span><br><span class="line">        threads.append(t)</span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.join()</span><br><span class="line">    results = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        results.append(q.get())</span><br><span class="line">    print(results)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name___==<span class="string">'__main__'</span>:</span><br><span class="line">    multithreading()</span><br></pre></td></tr></table></figure><h2 id="线程锁-Lock"><a href="#线程锁-Lock" class="headerlink" title="线程锁 Lock"></a>线程锁 Lock</h2><ul><li>不使用 Lock 的情况</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> A</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        A+=<span class="number">1</span></span><br><span class="line">        print(<span class="string">'job1'</span>,A)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> A</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        A+=<span class="number">10</span></span><br><span class="line">        print(<span class="string">'job2'</span>,A)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__== <span class="string">'__main__'</span>:</span><br><span class="line">    lock=threading.Lock()</span><br><span class="line">    A=<span class="number">0</span></span><br><span class="line">    t1=threading.Thread(target=job1)</span><br><span class="line">    t2=threading.Thread(target=job2)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">job1job2 <span class="number">11</span></span><br><span class="line">job2 <span class="number">21</span></span><br><span class="line">job2 <span class="number">31</span></span><br><span class="line">job2 <span class="number">41</span></span><br><span class="line">job2 <span class="number">51</span></span><br><span class="line">job2 <span class="number">61</span></span><br><span class="line">job2 <span class="number">71</span></span><br><span class="line">job2 <span class="number">81</span></span><br><span class="line">job2 <span class="number">91</span></span><br><span class="line">job2 <span class="number">101</span></span><br><span class="line"> <span class="number">1</span></span><br><span class="line">job1 <span class="number">102</span></span><br><span class="line">job1 <span class="number">103</span></span><br><span class="line">job1 <span class="number">104</span></span><br><span class="line">job1 <span class="number">105</span></span><br><span class="line">job1 <span class="number">106</span></span><br><span class="line">job1 <span class="number">107</span></span><br><span class="line">job1 <span class="number">108</span></span><br><span class="line">job1 <span class="number">109</span></span><br><span class="line">job1 <span class="number">110</span></span><br></pre></td></tr></table></figure><ul><li>使用 Lock 的情况</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> A,lock</span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        A+=<span class="number">1</span></span><br><span class="line">        print(<span class="string">'job1'</span>,A)</span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> A,lock</span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        A+=<span class="number">10</span></span><br><span class="line">        print(<span class="string">'job2'</span>,A)</span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__== <span class="string">'__main__'</span>:</span><br><span class="line">    lock=threading.Lock()</span><br><span class="line">    A=<span class="number">0</span></span><br><span class="line">    t1=threading.Thread(target=job1)</span><br><span class="line">    t2=threading.Thread(target=job2)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">job1 <span class="number">1</span></span><br><span class="line">job1 <span class="number">2</span></span><br><span class="line">job1 <span class="number">3</span></span><br><span class="line">job1 <span class="number">4</span></span><br><span class="line">job1 <span class="number">5</span></span><br><span class="line">job1 <span class="number">6</span></span><br><span class="line">job1 <span class="number">7</span></span><br><span class="line">job1 <span class="number">8</span></span><br><span class="line">job1 <span class="number">9</span></span><br><span class="line">job1 <span class="number">10</span></span><br><span class="line">job2 <span class="number">20</span></span><br><span class="line">job2 <span class="number">30</span></span><br><span class="line">job2 <span class="number">40</span></span><br><span class="line">job2 <span class="number">50</span></span><br><span class="line">job2 <span class="number">60</span></span><br><span class="line">job2 <span class="number">70</span></span><br><span class="line">job2 <span class="number">80</span></span><br><span class="line">job2 <span class="number">90</span></span><br><span class="line">job2 <span class="number">100</span></span><br><span class="line">job2 <span class="number">110</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://morvanzhou.github.io/tutorials/python-basic/threading/" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/python-basic/threading/</a></li></ul>]]></content>
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>semantic_mapping_论文阅读</title>
      <link href="/2018/03/26/semantic-mapping-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
      <content type="html"><![CDATA[<h1 id="Semantic-Mapping-文献综述"><a href="#Semantic-Mapping-文献综述" class="headerlink" title="Semantic Mapping 文献综述"></a>Semantic Mapping 文献综述</h1><blockquote><p>1，CNN-SLAM为今年CVPR的文章，是比较完整的pipeline，将LSD-SLAM里的深度估计和图像匹配都替换成基于CNN的方法，取得了更为robust的结果，并可以融合语义信息。见<a href="http://campar.in.tum.de/Chair/ProjectCNNSLAM" target="_blank" rel="noopener">ProjectCNNSLAM</a>.类似的工作还有UnDeepVO: Monocular Visual Odometry through Unsupervised Deep Learning。 问题在于准确度非常低。做过benchmark，基于单帧彩色照片进行距离信息预测，在室内每个像素的平均误差约50cm，在室外平均误差则高达７米以上。一篇投ICRA的工作结合少量的距离信息和彩色信息进行距离图像预测，效果比单纯用彩色照片准确得多且鲁棒性强。这个方法可以帮助传统SLAM从稀疏点云快速生成密集的点云，也可以用在激光雷达的超分辨率上。代码已开源<a href="https://github.com/fangchangma/sparse-to-dense" target="_blank" rel="noopener">sparse-to-dense</a>,论文：Sparse-to-Dense: Depth Prediction from Sparse Depth Samples and a Single Image <br><br></p><ol><li>VINet是AAAI2017的文章，利用CNN和RNN构建了一个VIO，即输入image和IMU信息，直接输出估计的pose。 <br><br></li><li>Unsupervised learning of depth and ego-motion from video是Google CVPR 2017的oral文章，利用CNN学习一个无监督的深度估计和pose估计网络，代码见<a href="https://github.com/tinghuiz/SfMLearner.git" target="_blank" rel="noopener">SfMLearner</a>.SfM-Net利用监督学习也干了类似的工作。 <br><br></li><li>重定位PoseNet和Delving deeper into convolutional neural networks for camera relocalization <br></li><li>语义地图 Semi-Dense 3D Semantic Mapping from Monocular SLAM <br><br></li><li>哪怕在传统基于特征点的SLAM已经能做到非常稳定高效的这个情况下，适合结合deep learning的科研方向还是有很多的。这其中包括 <br><blockquote><ul><li>提高特征点稳定性（减少outlier）和自动提取不同层级的特征点（点、线、面、物体）， <br></li><li>快速生成密集的地图（而非稀疏的三维点云） <br></li><li>结合语义信息和图像分割 <br></li><li>生成动态地图（可以实时更新、表达动态物体） <br></li><li>降低SLAM调参的难度 <br></li></ul></blockquote></li></ol></blockquote><blockquote><p>7.跳出SLAM，说点题外话，利用深度强化学习来进行端对端的机器人导航，已经有了不错的结果。人类在环境中导航，不也是直接输入image，输出action吗？有兴趣的可以看看这两篇文章：<a href="https://arxiv.org/abs/1702.03920" target="_blank" rel="noopener">Cognitive Mapping and Planning for Visual Navigation</a>和<a href="https://arxiv.org/abs/1609.05143" target="_blank" rel="noopener">Target-driven Visual Navigation in Indoor Scenes using Deep Reinforcement Learning</a>。navigation 是更适合 DL 的一个场景。人在移动的时候，并不会建立精确的环境地图，无法具体说出障碍物距离自己多少厘米。所以，我一直有一个直觉：「navigation 应该不需要精确地图信息与定位信息」，而 DL 似乎有可能实现这一全新的方法。 navigation 是更适合 DL 的一个场景。人在移动的时候，并不会建立精确的环境地图，无法具体说出障碍物距离自己多少厘米。所以，一直有一个直觉：「navigation 应该不需要精确地图信息与定位信息」，而 DL 似乎有可能实现这一全新的方法。但是，目前所有这些工作都存在一个问题：只是训练出一个 local planner，无法实现全局的路径规划。 <br><br></p><ol><li>语义分割和SLAM的结合还很粗糙.最简单的方式，就是跑一个pixel-wise的图像语义分割，再跑一个dense或者semi-dense的SLAM，把前者的结果map到后者的地图上去，每个像素（或者surfel）上做recursive Bayesian update，其实也就是概率累乘。参见Andrew Davison组的SemanticFusion (ICRA’17)，代码已开源。国内学者也有类似的工作，用LSD-SLAM + DeepLab v2，这个是单目的（SemanticFusion是RGB-D）,即<a href="https://arxiv.org/abs/1611.04144" target="_blank" rel="noopener">Semi-Dense 3D Semantic Mapping from Monocular SLAM</a>。这种结合方式，按某些学者的意见都不能称为semantic SLAM，只能叫semantic mapping，因为localization部分跟semantics没关系嘛。 <br><br></li><li>真正的semantic SLAM，语义信息是要能够帮助定位的，比如这篇：<a href="https://pdfs.semanticscholar.org/ef4c/ffbbca79df1c1ca7891345f898812289b6cb.pdf" target="_blank" rel="noopener">Probabilistic Data Association for Semantic SLAM</a>(ICRA’17)。用object detection的结果作为SLAM前端的输入，跟ORB之类的特征互补提高定位鲁棒性。优点很明显，这下SLAM不会因为你把床收拾了一下就啥都不认识了（视觉特征都变了，但床还是床）。难点是detection结果的data association最好能跟定位联合优化，但前者是个离散问题。这篇文章用EM算法，E步考虑所有可能的association，比较粗暴，但识别物体较少的时候还不错（论文实验里只识别椅子）。上面这篇文章没有语义分割。。。map里只有稀稀拉拉的几个物体（位置和类别）。 <br><br></li><li>另外，SLAM也能提升语义理解水平。前面提到的SemanticFusion和类似的工作里，融合了多个视角语义理解结果的3D地图，其中的语义标签准确率高于单帧图像得到的结果，这很容易理解。另外，通过在3D空间引入一些先验信息，比如用CRF对地图做一下diffusion，能进一步提升准确率。但CRF毕竟还是简单粗暴，如果设计更精细的滤波算法，尤其是能从真实数据中学习一些先验的话，应该效果还会更好。这方面的工作还没有。 <br><br></li><li>再提一个，融合优化之后的结果如果反馈给图像语义理解算法做一下fine-tuning，那就是self-supervised learning了。这方面的工作也还没有。 <br><br></li><li>接下来是语义地图怎么用的问题。对上层应用有价值的语义地图，应该包含一个个物体及其模型，而不仅是一堆标记了类别的voxel。一个比较好的例子来自IROS’17：<a href="https://arxiv.org/abs/1609.07849" target="_blank" rel="noopener">Meaningful Maps With Object-Oriented Semantic Mapping</a>不过这篇文章里的语义信息来自SSD和非神经网络的分割，还没有用端到端的语义分割网络。 <br><br></li><li>另外，针对动态场景，怎样处理物体移位，怎样区别长效地图和短效地图，怎么“脑补”同类物体，这里面一堆问题可以研究。更别说地图构建出来之后如何做体现空间智能的自然语言交互和任务规划，如何reasoning了，这方面研究目前连影子都没有。 <br><br></li><li>一篇很好的综述，里面也有很多关于语义SLAM的介绍：<a href="https://arxiv.org/abs/1606.05830" target="_blank" rel="noopener">Past, Present, and Future of Simultaneous Localization And Mapping: Towards the Robust-Perception Age</a> <br><br></li><li>语义slam开源：<br></li></ol><ul><li><a href="https://github.com/yuxng/DA-RNN" target="_blank" rel="noopener">DA-RNN_Semantic Mapping with Data Associated</a><br></li><li><a href="https://bitbucket.org/dysonroboticslab/semanticfusion" target="_blank" rel="noopener">SemanticFusion</a><br></li><li><a href="https://github.com/shichaoy/pop_up_image" target="_blank" rel="noopener">Pop-up SLAM: Semantic Monocular Plane SLAM</a>.场景理解用于改善状态估计，尤其是在低纹理区域，是目前极少的开源语义SLAM方案之一<br></li></ul></blockquote><p>参考：</p><ol><li><a href="https://www.zhihu.com/question/66006923/answer/241333356" target="_blank" rel="noopener">当前深度学习和slam结合有哪些比较好的论文，有没有一些开源的代码?</a></li><li><a href="https://www.zhihu.com/question/264578623/answer/283163990" target="_blank" rel="noopener">当前语义分割帮助视觉SLAM提高定位准确度，建立语义地图的研究现状如何？</a></li></ol><h2 id="研读论文一：CNN-SLAM-Real-time-dense-monocular-SLAM-with-learned-depth-prediction"><a href="#研读论文一：CNN-SLAM-Real-time-dense-monocular-SLAM-with-learned-depth-prediction" class="headerlink" title="研读论文一：CNN-SLAM: Real-time dense monocular SLAM with learned depth prediction"></a>研读论文一：CNN-SLAM: Real-time dense monocular SLAM with learned depth prediction</h2><blockquote><p>Tateno, K., Tombari, F., Laina, I., &amp; Navab, N. (2017). CNN-SLAM: Real-time dense monocular SLAM with learned depth prediction. arXiv preprint arXiv:1704.03489.<br>CVPR 2017</p></blockquote><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ol><li>本文提出了一种基于深度神经网络方法能够从单目图像中预测深度信息，用途可为弹幕图像的重建。尤其是对于纯单目重建是小的区域，如纹理不丰富的区域，效果较好。此外，相比较于单目SLAM，该深度SLAM还可提供scale。此外，该方法还融合了语义标记，来重建语义信息的场景。</li><li>传统的基于深度摄像头的SLAM有如下缺点：</li></ol><ul><li>有效工作距离较短</li><li>太阳光的影响等</li><li>普适性</li></ul><ol><li>双目摄像头缺点：特征丰富程度敏感</li><li>鉴于卷积神经网络（CNN）深度预测的最新进展，本文研究了深度神经网络的预测深度图，可以部署用于精确和密集的单目重建。我们提出了一种方法，其中CNN预测的稠密深度图与通过直接单目SLAM获得的深度测量自然地融合在一起。我们的融合方案在图像定位中优于单目SLAM方法，例如沿低纹理区域，反之亦然。我们展示了使用深度预测来估计重建的绝对尺度，从而克服了单眼SLAM的主要局限性之一。最后，我们提出一个框架，从单个帧获得的语义标签有效地融合了密集的SLAM，从单个视图产生语义相干的场景重构。两个基准数据集的评估结果显示了我们的方法的鲁棒性和准确性</li></ol>]]></content>
      
      <categories>
          
          <category> 学术 </category>
          
          <category> 论文阅读 </category>
          
          <category> Semantic Mapping </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学术 </tag>
            
            <tag> 论文阅读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>numpy和pandas教程</title>
      <link href="/2018/03/26/numpy%E5%92%8Cpandas%E6%95%99%E7%A8%8B/"/>
      <content type="html"><![CDATA[<h1 id="安装-numpy和pandas"><a href="#安装-numpy和pandas" class="headerlink" title="安装 numpy和pandas"></a>安装 numpy和pandas</h1><p><a href="http://www.numpy.org/" target="_blank" rel="noopener">numpy</a> 和 <a href="https://pandas.pydata.org/" target="_blank" rel="noopener">pandas</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install numpy</span><br><span class="line">sudo pip install pandas</span><br></pre></td></tr></table></figure><h1 id="Numpy教程"><a href="#Numpy教程" class="headerlink" title="Numpy教程"></a>Numpy教程</h1><h2 id="Numpy-属性"><a href="#Numpy-属性" class="headerlink" title="Numpy 属性"></a>Numpy 属性</h2><ul><li>ndim：维度</li><li>shape：行数和列数</li><li>size：元素个数</li></ul><h2 id="Numpy-的创建-array"><a href="#Numpy-的创建-array" class="headerlink" title="Numpy 的创建 array"></a>Numpy 的创建 array</h2><ul><li>array：创建数组</li><li>dtype：指定数据类型</li><li>zeros：创建数据全为0</li><li>ones：创建数据全为1</li><li>empty：创建数据接近0</li><li>arrange：按指定范围创建数据</li><li>linspace：创建线段</li></ul><h2 id="Numpy-基础运算"><a href="#Numpy-基础运算" class="headerlink" title="Numpy 基础运算"></a>Numpy 基础运算</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a=np.array([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>])   <span class="comment"># array([10, 20, 30, 40])</span></span><br><span class="line">b=np.arange(<span class="number">4</span>)              <span class="comment"># array([0, 1, 2, 3])</span></span><br></pre></td></tr></table></figure><ul><li>减法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c=a-b  <span class="comment"># array([10, 19, 28, 37])</span></span><br></pre></td></tr></table></figure><ul><li>加法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c=a+b   <span class="comment"># array([10, 21, 32, 43])</span></span><br></pre></td></tr></table></figure><ul><li>乘法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c=a*b   <span class="comment"># array([  0,  20,  60, 120])</span></span><br></pre></td></tr></table></figure><p>有所不同的是，在Numpy中，想要求出矩阵中各个元素的乘方需要依赖双星符号 **</p><ul><li>乘法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c=b**<span class="number">2</span>  <span class="comment"># array([0, 1, 4, 9])</span></span><br></pre></td></tr></table></figure><ul><li>三角函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c=<span class="number">10</span>*np.sin(a)  <span class="comment"># cos tan</span></span><br><span class="line"><span class="comment"># array([-5.44021111,  9.12945251, -9.88031624,  7.4511316 ])</span></span><br></pre></td></tr></table></figure><ul><li>逻辑判断</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(b&lt;<span class="number">3</span>)  </span><br><span class="line"><span class="comment"># array([ True,  True,  True, False], dtype=bool)</span></span><br></pre></td></tr></table></figure><p>上述运算均是建立在一维矩阵，即只有一行的矩阵上面的计算，如果我们想要对多行多维度的矩阵进行操作，需要对开始的脚本进行一些修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a=np.array([[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>]])</span><br><span class="line">b=np.arange(<span class="number">4</span>).reshape((<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># array([[1, 1],</span></span><br><span class="line"><span class="comment">#       [0, 1]])</span></span><br><span class="line"></span><br><span class="line">print(b)</span><br><span class="line"><span class="comment"># array([[0, 1],</span></span><br><span class="line"><span class="comment">#       [2, 3]])</span></span><br></pre></td></tr></table></figure><p>此时构造出来的矩阵a和b便是2行2列的，其中 reshape 操作是对矩阵的形状进行重构， 其重构的形状便是括号中给出的数字。</p><ul><li>矩阵乘法运算</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c_dot = np.dot(a,b)</span><br><span class="line"><span class="comment"># array([[2, 4],</span></span><br><span class="line"><span class="comment">#       [2, 3]])</span></span><br><span class="line">c_dot_2 = a.dot(b)</span><br><span class="line"><span class="comment"># array([[2, 4],</span></span><br><span class="line"><span class="comment">#       [2, 3]])</span></span><br></pre></td></tr></table></figure><ul><li>特定运算<ul><li>求和：np.sum(A)</li><li>最小值：np.min(A)</li><li>最大值：np.max(A)</li><li>最小值索引：np.argmin(A)</li><li>最大值索引：np.argmax(A)</li><li>平均值：np.mean(A)</li><li>中位数：np.medium(A)</li><li>累加：np.cumsum(A)</li><li>累差：np.diff(A)</li><li>非零数：np.nonzero(A)</li><li>排序：np.sort(A)</li><li>矩阵反向（转置）：np.transpose(A)或A.T</li><li>截断：np.clip(A,5,9) # 小于5为5，大于9为9</li></ul></li></ul><h2 id="Numpy-索引"><a href="#Numpy-索引" class="headerlink" title="Numpy 索引"></a>Numpy 索引</h2><h3 id="一维索引"><a href="#一维索引" class="headerlink" title="一维索引"></a>一维索引</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.arange(<span class="number">3</span>,<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># array([3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])</span></span><br><span class="line">         </span><br><span class="line">print(A[<span class="number">3</span>])    <span class="comment"># 6</span></span><br></pre></td></tr></table></figure><h3 id="二维索引"><a href="#二维索引" class="headerlink" title="二维索引"></a>二维索引</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(A[<span class="number">1</span>][<span class="number">1</span>])      <span class="comment"># 8</span></span><br></pre></td></tr></table></figure><p>这一脚本中的flatten是一个展开性质的函数，将多维的矩阵进行展开成1行的数列。而flat是一个迭代器，本身是一个object属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.arange(<span class="number">3</span>,<span class="number">15</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">         </span><br><span class="line">print(A.flatten())   </span><br><span class="line"><span class="comment"># array([3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> A.flat:</span><br><span class="line">    print(item)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line">……</span><br><span class="line"><span class="comment"># 14</span></span><br></pre></td></tr></table></figure><h2 id="Numpy-array-合并"><a href="#Numpy-array-合并" class="headerlink" title="Numpy array 合并"></a>Numpy array 合并</h2><ul><li>上下合并 - np.vstack()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line">B = np.array([<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>])</span><br><span class="line">         </span><br><span class="line">print(np.vstack((A,B)))    <span class="comment"># vertical stack</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[1,1,1]</span></span><br><span class="line"><span class="string"> [2,2,2]]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><ul><li>左右合并 - np.hstack()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">D = np.hstack((A,B))       <span class="comment"># horizontal stack</span></span><br><span class="line"></span><br><span class="line">print(D)</span><br><span class="line"><span class="comment"># [1,1,1,2,2,2]</span></span><br><span class="line"></span><br><span class="line">print(A.shape,D.shape)</span><br><span class="line"><span class="comment"># (3,) (6,)</span></span><br></pre></td></tr></table></figure><ul><li>转置操作 - np.newaxis()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">print(A[np.newaxis,:])</span><br><span class="line"><span class="comment"># [[1 1 1]]</span></span><br><span class="line"></span><br><span class="line">print(A[np.newaxis,:].shape)</span><br><span class="line"><span class="comment"># (1,3)</span></span><br><span class="line"></span><br><span class="line">print(A[:,np.newaxis])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[1]</span></span><br><span class="line"><span class="string">[1]</span></span><br><span class="line"><span class="string">[1]]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">print(A[:,np.newaxis].shape)</span><br><span class="line"><span class="comment"># (3,1)</span></span><br></pre></td></tr></table></figure><p>此时我们便将具有3个元素的array转换为了1行3列以及3行1列的矩阵了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])[:,np.newaxis]</span><br><span class="line">B = np.array([<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>])[:,np.newaxis]</span><br><span class="line">         </span><br><span class="line">C = np.vstack((A,B))   <span class="comment"># vertical stack</span></span><br><span class="line">D = np.hstack((A,B))   <span class="comment"># horizontal stack</span></span><br><span class="line"></span><br><span class="line">print(D)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[1 2]</span></span><br><span class="line"><span class="string">[1 2]</span></span><br><span class="line"><span class="string">[1 2]]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">print(A.shape,D.shape)</span><br><span class="line"><span class="comment"># (3,1) (3,2)</span></span><br></pre></td></tr></table></figure><ul><li>合并操作需要针对多个矩阵或序列 - np.concatenate()</li></ul><p>当你的合并操作需要针对多个矩阵或序列时，借助concatenate函数可能会让你使用起来比前述的函数更加方便：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">C = np.concatenate((A,B,B,A),axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">print(C)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[1],</span></span><br><span class="line"><span class="string">       [1],</span></span><br><span class="line"><span class="string">       [1],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [1],</span></span><br><span class="line"><span class="string">       [1],</span></span><br><span class="line"><span class="string">       [1]])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">D = np.concatenate((A,B,B,A),axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(D)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[1, 2, 2, 1],</span></span><br><span class="line"><span class="string">       [1, 2, 2, 1],</span></span><br><span class="line"><span class="string">       [1, 2, 2, 1]])</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>axis参数很好的控制了矩阵的纵向或是横向打印，相比较vstack和hstack函数显得更加方便。</p><h2 id="Numpy-array-分割"><a href="#Numpy-array-分割" class="headerlink" title="Numpy array 分割"></a>Numpy array 分割</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">print(A)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="string">    [ 4,  5,  6,  7],</span></span><br><span class="line"><span class="string">    [ 8,  9, 10, 11]])</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><ul><li>纵向分割</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(np.split(A, <span class="number">2</span>, axis=<span class="number">1</span>))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[array([[0, 1],</span></span><br><span class="line"><span class="string">        [4, 5],</span></span><br><span class="line"><span class="string">        [8, 9]]), array([[ 2,  3],</span></span><br><span class="line"><span class="string">        [ 6,  7],</span></span><br><span class="line"><span class="string">        [10, 11]])]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><ul><li>横向分割</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(np.split(A, <span class="number">3</span>, axis=<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># [array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8,  9, 10, 11]])]</span></span><br></pre></td></tr></table></figure><ul><li>错误的分割 </li></ul><p>范例的Array只有4列，只能等量对分，因此输入以上程序代码后Python就会报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(np.split(A, <span class="number">3</span>, axis=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ValueError: array split does not result in an equal division</span></span><br></pre></td></tr></table></figure><ul><li>不等量的分割</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">print(np.array_split(A, <span class="number">3</span>, axis=<span class="number">1</span>))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[array([[0, 1],</span></span><br><span class="line"><span class="string">        [4, 5],</span></span><br><span class="line"><span class="string">        [8, 9]]), array([[ 2],</span></span><br><span class="line"><span class="string">        [ 6],</span></span><br><span class="line"><span class="string">        [10]]), array([[ 3],</span></span><br><span class="line"><span class="string">        [ 7],</span></span><br><span class="line"><span class="string">        [11]])]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><ul><li>其他的分割方式</li></ul><p>在Numpy里还有np.vsplit()与横np.hsplit()方式可用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">print(np.vsplit(A, <span class="number">3</span>)) <span class="comment">#等于 print(np.split(A, 3, axis=0))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8,  9, 10, 11]])]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(np.hsplit(A, <span class="number">2</span>)) <span class="comment">#等于 print(np.split(A, 2, axis=1))</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[array([[0, 1],</span></span><br><span class="line"><span class="string">       [4, 5],</span></span><br><span class="line"><span class="string">       [8, 9]]), array([[ 2,  3],</span></span><br><span class="line"><span class="string">        [ 6,  7],</span></span><br><span class="line"><span class="string">        [10, 11]])]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h2 id="Numpy-copy-amp-deep-copy"><a href="#Numpy-copy-amp-deep-copy" class="headerlink" title="Numpy copy &amp; deep copy"></a>Numpy copy &amp; deep copy</h2><ul><li>copy() 的赋值方式没有关联性</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b = a.copy()    <span class="comment"># deep copy</span></span><br><span class="line">print(b)        <span class="comment"># array([11, 22, 33,  3])</span></span><br><span class="line">a[<span class="number">3</span>] = <span class="number">44</span></span><br><span class="line">print(a)        <span class="comment"># array([11, 22, 33, 44])</span></span><br><span class="line">print(b)        <span class="comment"># array([11, 22, 33,  3])</span></span><br></pre></td></tr></table></figure><h1 id="Pandas-教程"><a href="#Pandas-教程" class="headerlink" title="Pandas 教程"></a>Pandas 教程</h1><h2 id="Numpy-和-Pandas-有什么不同"><a href="#Numpy-和-Pandas-有什么不同" class="headerlink" title="Numpy 和 Pandas 有什么不同"></a>Numpy 和 Pandas 有什么不同</h2><p>如果用 python 的列表和字典来作比较, 那么可以说 Numpy 是列表形式的，没有数值标签，而 Pandas 就是字典形式。Pandas是基于Numpy构建的，让Numpy为中心的应用变得更加简单。</p><ul><li>Series</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">s = pd.Series([<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,np.nan,<span class="number">44</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">print(s)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">0     1.0</span></span><br><span class="line"><span class="string">1     3.0</span></span><br><span class="line"><span class="string">2     6.0</span></span><br><span class="line"><span class="string">3     NaN</span></span><br><span class="line"><span class="string">4    44.0</span></span><br><span class="line"><span class="string">5     1.0</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>Series的字符串表现形式为：索引在左边，值在右边。由于我们没有为数据指定索引。于是会自动创建一个0到N-1（N为长度）的整数型索引。</p><ul><li>DataFrame</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dates = pd.date_range(<span class="string">'20160101'</span>,periods=<span class="number">6</span>)</span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">6</span>,<span class="number">4</span>),index=dates,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line"></span><br><span class="line">print(df)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">                   a         b         c         d</span></span><br><span class="line"><span class="string">2016-01-01 -0.253065 -2.071051 -0.640515  0.613663</span></span><br><span class="line"><span class="string">2016-01-02 -1.147178  1.532470  0.989255 -0.499761</span></span><br><span class="line"><span class="string">2016-01-03  1.221656 -2.390171  1.862914  0.778070</span></span><br><span class="line"><span class="string">2016-01-04  1.473877 -0.046419  0.610046  0.204672</span></span><br><span class="line"><span class="string">2016-01-05 -1.584752 -0.700592  1.487264 -1.778293</span></span><br><span class="line"><span class="string">2016-01-06  0.633675 -1.414157 -0.277066 -0.442545</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>DataFrame是一个表格型的数据结构，它包含有一组有序的列，每列可以是不同的值类型（数值，字符串，布尔值等）。DataFrame既有行索引也有列索引， 它可以被看做由Series组成的大字典。</p><ul><li>DataFrame 的一些简单运用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">print(df[<span class="string">'b'</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">2016-01-01   -2.071051</span></span><br><span class="line"><span class="string">2016-01-02    1.532470</span></span><br><span class="line"><span class="string">2016-01-03   -2.390171</span></span><br><span class="line"><span class="string">2016-01-04   -0.046419</span></span><br><span class="line"><span class="string">2016-01-05   -0.700592</span></span><br><span class="line"><span class="string">2016-01-06   -1.414157</span></span><br><span class="line"><span class="string">Freq: D, Name: b, dtype: float64</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>我们在创建一组没有给定行标签和列标签的数据 df1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>)))</span><br><span class="line">print(df1)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">   0  1   2   3</span></span><br><span class="line"><span class="string">0  0  1   2   3</span></span><br><span class="line"><span class="string">1  4  5   6   7</span></span><br><span class="line"><span class="string">2  8  9  10  11</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>默认的从0开始 index. 还有一种生成 df 的方法, 如下 df2:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'A'</span> : <span class="number">1.</span>,</span><br><span class="line">                    <span class="string">'B'</span> : pd.Timestamp(<span class="string">'20130102'</span>),</span><br><span class="line">                    <span class="string">'C'</span> : pd.Series(<span class="number">1</span>,index=list(range(<span class="number">4</span>)),dtype=<span class="string">'float32'</span>),</span><br><span class="line">                    <span class="string">'D'</span> : np.array([<span class="number">3</span>] * <span class="number">4</span>,dtype=<span class="string">'int32'</span>),</span><br><span class="line">                    <span class="string">'E'</span> : pd.Categorical([<span class="string">"test"</span>,<span class="string">"train"</span>,<span class="string">"test"</span>,<span class="string">"train"</span>]),</span><br><span class="line">                    <span class="string">'F'</span> : <span class="string">'foo'</span>&#125;)</span><br><span class="line">                    </span><br><span class="line">print(df2)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">     A          B    C  D      E    F</span></span><br><span class="line"><span class="string">0  1.0 2013-01-02  1.0  3   test  foo</span></span><br><span class="line"><span class="string">1  1.0 2013-01-02  1.0  3  train  foo</span></span><br><span class="line"><span class="string">2  1.0 2013-01-02  1.0  3   test  foo</span></span><br><span class="line"><span class="string">3  1.0 2013-01-02  1.0  3  train  foo</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>这种方法能对每一列的数据进行特殊对待. 如果想要查看数据中的类型, 我们可以用 dtype 这个属性:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">print(df2.dtypes)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">df2.dtypes</span></span><br><span class="line"><span class="string">A           float64</span></span><br><span class="line"><span class="string">B    datetime64[ns]</span></span><br><span class="line"><span class="string">C           float32</span></span><br><span class="line"><span class="string">D             int32</span></span><br><span class="line"><span class="string">E          category</span></span><br><span class="line"><span class="string">F            object</span></span><br><span class="line"><span class="string">dtype: object</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>如果想看对列的序号:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(df2.index)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Int64Index([0, 1, 2, 3], dtype='int64')</span></span><br></pre></td></tr></table></figure><p>同样, 每种数据的名称也能看到:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(df2.columns)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Index(['A', 'B', 'C', 'D', 'E', 'F'], dtype='object')</span></span><br></pre></td></tr></table></figure><p>果只想看所有df2的值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(df2.values)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'test', 'foo'],</span></span><br><span class="line"><span class="string">       [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'train', 'foo'],</span></span><br><span class="line"><span class="string">       [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'test', 'foo'],</span></span><br><span class="line"><span class="string">       [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'train', 'foo']], dtype=object)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>想知道数据的总结, 可以用 describe():</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">df2.describe()</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">         A    C    D</span></span><br><span class="line"><span class="string">count  4.0  4.0  4.0</span></span><br><span class="line"><span class="string">mean   1.0  1.0  3.0</span></span><br><span class="line"><span class="string">std    0.0  0.0  0.0</span></span><br><span class="line"><span class="string">min    1.0  1.0  3.0</span></span><br><span class="line"><span class="string">25%    1.0  1.0  3.0</span></span><br><span class="line"><span class="string">50%    1.0  1.0  3.0</span></span><br><span class="line"><span class="string">75%    1.0  1.0  3.0</span></span><br><span class="line"><span class="string">max    1.0  1.0  3.0</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>如果想翻转数据, transpose:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">print(df2.T)</span><br><span class="line"></span><br><span class="line"><span class="string">"""                   </span></span><br><span class="line"><span class="string">0                    1                    2  \</span></span><br><span class="line"><span class="string">A                    1                    1                    1   </span></span><br><span class="line"><span class="string">B  2013-01-02 00:00:00  2013-01-02 00:00:00  2013-01-02 00:00:00   </span></span><br><span class="line"><span class="string">C                    1                    1                    1   </span></span><br><span class="line"><span class="string">D                    3                    3                    3   </span></span><br><span class="line"><span class="string">E                 test                train                 test   </span></span><br><span class="line"><span class="string">F                  foo                  foo                  foo   </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                     3  </span></span><br><span class="line"><span class="string">A                    1  </span></span><br><span class="line"><span class="string">B  2013-01-02 00:00:00  </span></span><br><span class="line"><span class="string">C                    1  </span></span><br><span class="line"><span class="string">D                    3  </span></span><br><span class="line"><span class="string">E                train  </span></span><br><span class="line"><span class="string">F                  foo  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>如果想对数据的 index 进行排序并输出:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">print(df2.sort_index(axis=<span class="number">1</span>, ascending=<span class="keyword">False</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">     F      E  D    C          B    A</span></span><br><span class="line"><span class="string">0  foo   test  3  1.0 2013-01-02  1.0</span></span><br><span class="line"><span class="string">1  foo  train  3  1.0 2013-01-02  1.0</span></span><br><span class="line"><span class="string">2  foo   test  3  1.0 2013-01-02  1.0</span></span><br><span class="line"><span class="string">3  foo  train  3  1.0 2013-01-02  1.0</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">如果是对数据 值 排序输出:</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">print(df2.sort_values(by=<span class="string">'B'</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">     A          B    C  D      E    F</span></span><br><span class="line"><span class="string">0  1.0 2013-01-02  1.0  3   test  foo</span></span><br><span class="line"><span class="string">1  1.0 2013-01-02  1.0  3  train  foo</span></span><br><span class="line"><span class="string">2  1.0 2013-01-02  1.0  3   test  foo</span></span><br><span class="line"><span class="string">3  1.0 2013-01-02  1.0  3  train  foo</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://morvanzhou.github.io/tutorials/data-manipulation/np-pd/3-1-pd-intro/" target="_blank" rel="noopener">Pandas 基本介绍</a></li></ul>]]></content>
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux入门教程</title>
      <link href="/2018/03/25/linux%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
      <content type="html"><![CDATA[<h1 id="Linux入门教程"><a href="#Linux入门教程" class="headerlink" title="Linux入门教程"></a>Linux入门教程</h1><h2 id="SSH-远程连接-Linux"><a href="#SSH-远程连接-Linux" class="headerlink" title="SSH 远程连接 Linux"></a>SSH 远程连接 Linux</h2><h3 id="Linux端配置"><a href="#Linux端配置" class="headerlink" title="Linux端配置"></a>Linux端配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure><p>查看IP地址：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure></p><h3 id="Mac端配置"><a href="#Mac端配置" class="headerlink" title="Mac端配置"></a>Mac端配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 用户名@IP地址 <span class="comment">#输入密码确认</span></span><br></pre></td></tr></table></figure><h3 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h3><p>Mac端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -f <span class="built_in">test</span> -C <span class="string">"test-key"</span> <span class="comment"># 一直回车</span></span><br><span class="line">cat test.pub <span class="comment"># 查看公钥内容</span></span><br></pre></td></tr></table></figure><p>配置公钥到服务器：将公钥内容添加到服务器的~/.ssh/authorized_keys 文件中.</p><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp   /home/yourname/.ssh/authorized_keys yourname@192.168.38.58:/home/yourname/.ssh/</span><br></pre></td></tr></table></figure><p>alias 实现命令快速登陆：做好配置之后，通过ssh可以直接登录了。对经常登录的服务器，可以将ssh登录命令的alias加到 ~/.bash_profile文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.bash_profile | grep 101</span><br><span class="line"><span class="built_in">alias</span> to-101=<span class="string">'ssh huqiu@192.168.154.101'</span></span><br></pre></td></tr></table></figure><p>登录的时候:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ to-101</span><br></pre></td></tr></table></figure><p>无法登录一般的原因：</p><ul><li><p>客户端的私钥和公钥文件位置必须位于 ~/.ssh 下。</p></li><li><p>确保双方 ~/.ssh 目录，父目录，公钥私钥，authorized_keys 文件的权限对当前用户至少要有执行权限，对其他用户最多只能有执行权限。</p></li><li><p>注意git登录，要求对公钥和私钥以及config文件，其他用户不能有任何权限。</p></li><li><p>服务器端 ~/.ssh/authorized_keys 文件名确保没错 :).</p></li></ul><p>ssh-copy-id：ssh-copy-id 是一个小脚本，你可以用这个小脚本完成以上工作。这个脚本在linux系统上一般都有。</p><p><a href="https://www.liaohuqiu.net/cn/posts/ssh-keygen-abc/" target="_blank" rel="noopener">ssh-keygen 基本用法</a></p><p>1) 使用 ssh-keygen 时，请先进入到 ~/.ssh 目录，不存在的话，请先创建。并且保证 ~/.ssh 以及所有父目录的权限不能大于 711</p><p>2) 使用 ssh-kengen 会在~/.ssh/目录下生成两个文件，不指定文件名和密钥类型的时候，默认生成的两个文件是：</p><ul><li>id_rsa</li><li>id_rsa.pub</li></ul><p>第一个是私钥文件，第二个是公钥文件。</p><p>生成ssh key的时候，可以通过 -f 选项指定生成文件的文件名，如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -f <span class="built_in">test</span>   -C <span class="string">"test key"</span> <span class="comment"># test - 文件名，"test key" - 备注</span></span><br></pre></td></tr></table></figure><h3 id="SSH-config"><a href="#SSH-config" class="headerlink" title="SSH config"></a>SSH config</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Host example                       <span class="comment"># 关键词</span></span><br><span class="line">HostName example.com           <span class="comment"># 主机地址</span></span><br><span class="line">User root                      <span class="comment"># 用户名</span></span><br><span class="line">IdentityFile ~/.ssh/id_ecdsa <span class="comment"># 认证文件</span></span><br><span class="line">Port 22                      <span class="comment"># 指定端口</span></span><br><span class="line">ControlMaster auto</span><br><span class="line">ControlPath /tmp/%r@%h:%p</span><br></pre></td></tr></table></figure><h1 id="OpenCV3-1配置"><a href="#OpenCV3-1配置" class="headerlink" title="OpenCV3.1配置"></a>OpenCV3.1配置</h1><h2 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line"><span class="comment"># 必须的，gcc编译环境</span></span><br><span class="line"></span><br><span class="line">sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev</span><br><span class="line"><span class="comment"># 必须的,包括cmake等工具</span></span><br><span class="line"></span><br><span class="line">sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev</span><br><span class="line"><span class="comment"># 可选的，看个人需要，总共5M左右</span></span><br><span class="line"></span><br><span class="line">sudo apt-get install libv4l-dev</span><br></pre></td></tr></table></figure><h2 id="下载-源码"><a href="#下载-源码" class="headerlink" title="下载 源码"></a>下载 源码</h2><p><a href="https://opencv.org/releases.html" target="_blank" rel="noopener">OpenCV</a></p><p>或着用git clone：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/opencv310</span><br><span class="line">    <span class="comment"># opencv310为自己建的，源码将放在这里</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/Itseez/opencv.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/Itseez/opencv_contrib.git</span><br></pre></td></tr></table></figure><h2 id="CMake-Opencv源码"><a href="#CMake-Opencv源码" class="headerlink" title="CMake Opencv源码"></a>CMake Opencv源码</h2><p>建立一个编译目录（例如：/build）把cmake后的文件都放在这里边。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/opencv</span><br><span class="line">mkdir build  //建立一个build目录，把cmake的文件都放着里边</span><br><span class="line"><span class="built_in">cd</span> build　　　//进入build目录</span><br></pre></td></tr></table></figure><p>cmake时ippicv_linux_20151201.tgz总是不能成功下载，故cmake之前将./downloads/linux-808b791a6eac9ed78d32a7666804320e 文件拷贝至./opencv-3.1.0/3rdparty/ippicv/ 路径下(先执行一次cmake 命令生成文件路径，在将ippicv_linux_20151201.tgz复制进去) ippicv_linux_20151201.tgz下载链接:链接: <a href="https://pan.baidu.com/s/1jBBPxXX_NqCodS5bAln4-g" target="_blank" rel="noopener">https://pan.baidu.com/s/1jBBPxXX_NqCodS5bAln4-g</a> 密码: x4sn</p><p>然后开始cmake，这里需要注意几个cmake的参数，比较重要。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/<span class="built_in">local</span> WITH_LIBV4L=ON ..</span><br></pre></td></tr></table></figure><p>切记最后’..’两个点之前要加空格！！</p><h2 id="把代码编译成可执行文件"><a href="#把代码编译成可执行文件" class="headerlink" title="把代码编译成可执行文件"></a>把代码编译成可执行文件</h2><p>这里官方推荐使用多进程编译，推荐七个进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j7 <span class="comment"># 并行运行七个jobs，这一步也在build目录中进行</span></span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">如果你要在python下运行opencv库的情况下，那就必须安装安装python-opencv</span><br><span class="line">sudo apt-get install python-opencv</span><br></pre></td></tr></table></figure><h2 id="配置库文件路径"><a href="#配置库文件路径" class="headerlink" title="配置库文件路径"></a>配置库文件路径</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c <span class="string">'echo "/usr/local/lib" &gt; /etc/ld.so.conf.d/opencv.conf'</span></span><br><span class="line"><span class="comment">#或者直接打开/etc/ld.so.conf.d/opencv.conf，添加/usr/local/lib</span></span><br><span class="line"><span class="comment">#使配置生效</span></span><br><span class="line">sudo  ldconfig(重要)</span><br></pre></td></tr></table></figure><h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo vim/etc/bash.bashrc   </span><br><span class="line"><span class="comment">#在最后加入以下两行代码</span></span><br><span class="line">PKG_CONFIG_PATH=<span class="variable">$PKG_CONFIG_PATH</span>:/usr/<span class="built_in">local</span>/lib/pkgconfig </span><br><span class="line"><span class="built_in">export</span> PKG_CONFIG_PATH  </span><br><span class="line"><span class="comment">#使配置生效</span></span><br><span class="line">sudo <span class="built_in">source</span> /etc/bash.bashrc </span><br><span class="line">（该步骤可能会报错找不到命令，原因是<span class="built_in">source</span>为root命令</span><br><span class="line">su（进入root权限）</span><br></pre></td></tr></table></figure><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --modversion opencv</span><br><span class="line">pkg-config --cflags opencv</span><br></pre></td></tr></table></figure><h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><p>我是用python+opencv的，我这里直接运行opencv自带的python的例子程序，TX1自带摄像头不能用，需要使用外接USB摄像头，插入USB接口即可，无需安装驱动，也无需改动测试代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;opencv3.1.0_dir&gt;/samples/python/</span><br><span class="line">python video.py</span><br><span class="line">python edge.py</span><br><span class="line">python facedetect.py</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.liaohuqiu.net/cn/posts/ssh-public-key-auto-login/" target="_blank" rel="noopener">https://www.liaohuqiu.net/cn/posts/ssh-public-key-auto-login/</a></li><li><a href="https://blog.csdn.net/asukasmallriver/article/details/72927860" target="_blank" rel="noopener">https://blog.csdn.net/asukasmallriver/article/details/72927860</a></li><li><a href="https://blog.csdn.net/u011440558/article/details/78358447" target="_blank" rel="noopener">https://blog.csdn.net/u011440558/article/details/78358447</a></li></ol>]]></content>
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Linux </category>
          
          <category> 入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ubuntu_16.04_env</title>
      <link href="/2018/03/25/ubuntu-16-04-env/"/>
      <content type="html"><![CDATA[<h1 id="Ubuntu-16-04-环境配置"><a href="#Ubuntu-16-04-环境配置" class="headerlink" title="Ubuntu 16.04 环境配置"></a>Ubuntu 16.04 环境配置</h1><h2 id="PCL1-8环境"><a href="#PCL1-8环境" class="headerlink" title="PCL1.8环境"></a>PCL1.8环境</h2><h3 id="第一步：安装依赖"><a href="#第一步：安装依赖" class="headerlink" title="第一步：安装依赖"></a>第一步：安装依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update  </span><br><span class="line">sudo apt-get install git build-essential linux-libc-dev  </span><br><span class="line">sudo apt-get install cmake cmake-gui   </span><br><span class="line">sudo apt-get install libusb-1.0-0-dev libusb-dev libudev-dev  </span><br><span class="line">sudo apt-get install mpi-default-dev openmpi-bin openmpi-common    </span><br><span class="line">sudo apt-get install libflann1.8 libflann-dev  </span><br><span class="line">sudo apt-get install libeigen3-dev  </span><br><span class="line">sudo apt-get install libboost-all-dev  </span><br><span class="line">sudo apt-get install libvtk5.10-qt4 libvtk5.10 libvtk5-dev  </span><br><span class="line">sudo apt-get install libqhull* libgtest-dev  </span><br><span class="line">sudo apt-get install freeglut3-dev pkg-config  </span><br><span class="line">sudo apt-get install libxmu-dev libxi-dev   </span><br><span class="line">sudo apt-get install mono-complete  </span><br><span class="line">sudo apt-get install qt-sdk openjdk-8-jdk openjdk-8-jre</span><br></pre></td></tr></table></figure><h3 id="第二步：下载源码"><a href="#第二步：下载源码" class="headerlink" title="第二步：下载源码"></a>第二步：下载源码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/PointCloudLibrary/pcl.git</span><br></pre></td></tr></table></figure><h3 id="第三步：编译源码"><a href="#第三步：编译源码" class="headerlink" title="第三步：编译源码"></a>第三步：编译源码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> pcl  </span><br><span class="line">mkdir release  </span><br><span class="line"><span class="built_in">cd</span> release  </span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=None -DCMAKE_INSTALL_PREFIX=/usr \  </span><br><span class="line">      -DBUILD_GPU=ON -DBUILD_apps=ON -DBUILD_examples=ON \  </span><br><span class="line">      -DCMAKE_INSTALL_PREFIX=/usr ..  </span><br><span class="line">make</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h3 id="第四步（可选-and-建议）：如果需要PCLVisualizer"><a href="#第四步（可选-and-建议）：如果需要PCLVisualizer" class="headerlink" title="第四步（可选 and 建议）：如果需要PCLVisualizer"></a>第四步（可选 and 建议）：如果需要PCLVisualizer</h3><p>安装OpenNI、OpenNI2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libopenni-dev   </span><br><span class="line">sudo apt-get install libopenni2-dev</span><br></pre></td></tr></table></figure><p>安装<a href="https://www.ensenso.com/support/sdk-download/?lang=de" target="_blank" rel="noopener">ensensor</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i ensenso-sdk-2.0.147-x64.deb </span><br><span class="line">sudo dpkg -i codemeter_6.40.2402.501_amd64.deb</span><br></pre></td></tr></table></figure><p>如缺少依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get -f install</span><br></pre></td></tr></table></figure><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ol><li><a href="https://blog.csdn.net/dantengc/article/details/78446600" target="_blank" rel="noopener">https://blog.csdn.net/dantengc/article/details/78446600</a></li></ol><h2 id="OpenCV环境"><a href="#OpenCV环境" class="headerlink" title="OpenCV环境"></a>OpenCV环境</h2><h2 id="Caffe-环境"><a href="#Caffe-环境" class="headerlink" title="Caffe 环境"></a>Caffe 环境</h2>]]></content>
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Linux </category>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>semap论文</title>
      <link href="/2018/03/25/semap%E8%AE%BA%E6%96%87/"/>
      <content type="html"><![CDATA[<h1 id="SeMap-数字化室内语义地图低成本自动化构建方法"><a href="#SeMap-数字化室内语义地图低成本自动化构建方法" class="headerlink" title="SeMap: 数字化室内语义地图低成本自动化构建方法"></a>SeMap: 数字化室内语义地图低成本自动化构建方法</h1><h2 id="场景图重建"><a href="#场景图重建" class="headerlink" title="场景图重建"></a>场景图重建</h2><p>使用Colmap工具来获取场景图重建结果</p><h2 id="Colmap使用方法"><a href="#Colmap使用方法" class="headerlink" title="Colmap使用方法"></a><a href="https://colmap.github.io/tutorial.html#quickstart" target="_blank" rel="noopener">Colmap使用方法</a></h2><p>场景图通过<a href="https://colmap.github.io/tutorial.html#feature-detection-and-extraction" target="_blank" rel="noopener">Feature Detection and Extraction</a>和<a href="https://colmap.github.io/tutorial.html#feature-matching-and-geometric-verification" target="_blank" rel="noopener">Feature Matching and Geometric Verification</a>两步完成。</p><p>首先使用GUI来操作。</p><h3 id="打开Colmap"><a href="#打开Colmap" class="headerlink" title="打开Colmap"></a><a href="https://colmap.github.io/tutorial.html#data-structure" target="_blank" rel="noopener">打开Colmap</a></h3><p>（1）Windows: COLMAP.bat</p><p>Mac: COLMAP.app</p><p>Linux可选为：./src/exe/colmap gui</p><p>（2）新建项目-GUI操作</p><p>File &gt; New project</p><p>在此步，首先确定生成的数据库保存位置，还要确定输入图片位置。为了方便起见，能够通过File &gt; Save project来保存整个项目。</p><p>File &gt; Open project为打开现有项目。</p><p>（3）新建项目-命令行操作</p><p>colmap gui 或 colmap gui –project_path path/to/project.ini</p><p>（4）例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/path/to/project/...</span><br><span class="line">+── images</span><br><span class="line">│   +── image1.jpg</span><br><span class="line">│   +── image2.jpg</span><br><span class="line">│   +── ...</span><br><span class="line">│   +── imageN.jpg</span><br><span class="line">+── database.db</span><br><span class="line">+── project.ini</span><br></pre></td></tr></table></figure><p>其中，/path/to/project/images为图片路径，/path/to/project/database.db为数据库保存路径，/path/to/project/project.ini为项目配置保存路径。</p><h3 id="Feature-Detection-and-Extraction"><a href="#Feature-Detection-and-Extraction" class="headerlink" title="Feature Detection and Extraction"></a>Feature Detection and Extraction</h3><p>(1) GUI操作</p><p>Processing &gt; Extract features</p><blockquote><p>如果导入现有的特征提取的文件，需有如下文件：<br><br>NUM_FEATURES 128 <br><br>X Y SCALE ORIENTATION D_1 D_2 D_3 … D_128<br><br>…<br><br>X Y SCALE ORIENTATION D_1 D_2 D_3 … D_128<br><br>where X, Y, SCALE, ORIENTATION are floating point numbers and D_1…D_128 values in the range 0…255. The file should have NUM_FEATURES lines with one line per feature. For example, if an image has 4 features, then the text file should look something like this:<br><br>4 128<br><br>1.2 2.3 0.1 0.3 1 2 3 4 … 21<br><br>2.2 3.3 1.1 0.3 3 2 3 2 … 32<br><br>0.2 1.3 1.1 0.3 3 2 3 2 … 2<br><br>1.2 2.3 1.1 0.3 3 2 3 2 … 3<br></p></blockquote><h3 id="Feature-Matching-and-Geometric-Verification"><a href="#Feature-Matching-and-Geometric-Verification" class="headerlink" title="Feature Matching and Geometric Verification"></a>Feature Matching and Geometric Verification</h3><p>Processing &gt; Match features</p><h3 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h3><p>（1）<a href="https://colmap.github.io/tutorial.html#database-management" target="_blank" rel="noopener">Database Management</a></p><p>Processing &gt; Manage database</p><p>（2）<a href="https://colmap.github.io/database.html#database-format" target="_blank" rel="noopener">Database Format</a></p><p>SQLite database file</p><p>The database contains the following tables:</p><ul><li>cameras</li><li>images</li><li>keypoints</li><li>descriptors</li><li>matches</li><li>inlier_matches</li></ul><p>Cameras and Images： The relation between cameras and images is 1-to-N. </p><p>Keypoints and Descriptors：The detected keypoints are stored as row-major float32 binary blobs, where the first two columns are the X and Y locations in the image, respectively. </p><p>Matches：Feature matching stores its output in the matches table and geometric verification in the inlier_matches table. COLMAP only uses the data in inlier_matches for reconstruction. Every entry in the two tables stores the feature matches between two unique images, where the pair_id is the row-major, linear index in the upper-triangular match matrix, generated as follows:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image_ids_to_pair_id</span><span class="params">(image_id1, image_id2)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> image_id1 &gt; image_id2:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2147483647</span> * image_id2 + image_id1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2147483647</span> * image_id1 + image_id2</span><br></pre></td></tr></table></figure><p>and image identifiers can be uniquely determined from the pair_id as:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pair_id_to_image_ids</span><span class="params">(pair_id)</span>:</span></span><br><span class="line">    image_id2 = pair_id % <span class="number">2147483647</span></span><br><span class="line">    image_id1 = (pair_id - image_id2) / <span class="number">2147483647</span></span><br><span class="line">    <span class="keyword">return</span> image_id1, image_id2</span><br></pre></td></tr></table></figure><p>The pair_id enables efficient database queries, as the matches tables may contain several hundred millions of entries. This scheme limits the maximum number of images in a database to 2147483647 (maximum value of signed 32-bit integers), i.e. image_id must be smaller than 2147483647.</p><p>The binary blobs in the matches tables are row-major uint32 matrices, where the left column are zero-based indices into the features of image_id1 and the second column into the features of image_id2. The column cols must be 2 and the rows column specifies the number of feature matches.</p>]]></content>
      
      <categories>
          
          <category> 学术 </category>
          
          <category> semap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学术 </tag>
            
            <tag> semap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>categories</title>
      <link href="/2018/03/24/categories/"/>
      <content type="html"><![CDATA[<h1 id="Categories"><a href="#Categories" class="headerlink" title="Categories"></a>Categories</h1><ul><li><p><font color="“blue”"><strong>编程: programming</strong></font></p><ul><li>C++</li><li>Java</li><li>Python</li><li>Matlab</li><li>Android</li><li>Linux</li><li>Git</li><li>Latex</li><li>PHP</li><li>IOS</li><li>数据库</li><li>网络编程</li><li>多线程</li><li>QT编程</li><li>MarkDown</li><li>DP<ul><li>Caffe</li><li>TF</li><li>PyTorch</li></ul></li><li>数据结构</li><li>算法</li></ul></li><li><p><font color="“blue”"><strong>学术: science</strong></font></p><ul><li>计算机视觉<ul><li>ICCV</li><li>CVPR</li><li>ECCV</li></ul></li><li>移动计算<ul><li>MobiCom</li><li>SigComm</li><li>InfoCom</li><li>NSDI</li><li>SenSys</li><li>PerCom</li><li>UbiComp</li></ul></li><li>机器学习&amp;深度学习<ul><li>AAAI</li><li>IJCAI</li></ul></li></ul></li><li><p><font color="“blue”"><strong>理论: theory</strong></font></p><ul><li>计算机视觉</li><li>移动计算</li><li>数学</li><li>优化算法</li><li>机器学习</li></ul></li><li><p><font color="“blue”"><strong>其他: other</strong></font></p><ul><li>Hexo博客</li><li>生活</li></ul></li></ul><h1 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h1><ul><li>论文</li><li>理论</li><li>其他</li><li>等等</li></ul>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
          <category> categories </category>
          
      </categories>
      
      
        <tags>
            
            <tag> categories </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>双目成像深度原理</title>
      <link href="/2018/03/24/%E5%8F%8C%E7%9B%AE%E6%88%90%E5%83%8F%E6%B7%B1%E5%BA%A6%E5%8E%9F%E7%90%86/"/>
      <content type="html"><![CDATA[<h1 id="相机内参数"><a href="#相机内参数" class="headerlink" title="相机内参数"></a>相机内参数</h1><p>与相机自身特性相关的参数，比如相机的焦距、像素大小等；</p><h1 id="相机外参数"><a href="#相机外参数" class="headerlink" title="相机外参数"></a>相机外参数</h1><p>在世界坐标系中的参数，比如相机的位置、旋转方向等</p><h1 id="坐标系转换"><a href="#坐标系转换" class="headerlink" title="坐标系转换"></a>坐标系转换</h1><h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><p>图像处理、立体视觉等等方向常常涉及到四个坐标系：世界坐标系、相机坐标系、图像坐标系、像素坐标系。例如下图：</p><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_1" alt=""></p><h2 id="坐标系转换-1"><a href="#坐标系转换-1" class="headerlink" title="坐标系转换"></a>坐标系转换</h2><h3 id="世界坐标系与相机坐标系"><a href="#世界坐标系与相机坐标系" class="headerlink" title="世界坐标系与相机坐标系"></a>世界坐标系与相机坐标系</h3><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_2" alt=""></p><p>于是，从世界坐标系到相机坐标系，涉及到旋转和平移（其实所有的运动也可以用旋转矩阵和平移向量来描述）。绕着不同的坐标轴旋转不同的角度，得到相应的旋转矩阵，如下图所示：</p><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_3" alt=""></p><p>从世界坐标系到相机坐标系的转换关系如下所示：</p><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_4" alt=""></p><p>那么点P在相机坐标系的坐标为：</p><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_8" alt=""></p><h3 id="相机坐标系与图像坐标系"><a href="#相机坐标系与图像坐标系" class="headerlink" title="相机坐标系与图像坐标系"></a>相机坐标系与图像坐标系</h3><p>相机坐标系到图像坐标系，属于透视投影关系，从3D转换到2D。 </p><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_5" alt=""></p><p>此时投影点p的单位还是mm，并不是pixel，需要进一步转换到像素坐标系。</p><h3 id="图像坐标系与像素坐标系"><a href="#图像坐标系与像素坐标系" class="headerlink" title="图像坐标系与像素坐标系"></a>图像坐标系与像素坐标系</h3><p>像素坐标系和图像坐标系都在成像平面上，只是各自的原点和度量单位不一样。图像坐标系的原点为相机光轴与成像平面的交点，通常情况下是成像平面的中点或者叫principal point。图像坐标系的单位是mm，属于物理单位，而像素坐标系的单位是pixel，我们平常描述一个像素点都是几行几列。所以这二者之间的转换如下：其中dx和dy表示每一列和每一行分别代表多少mm，即1pixel=dx mm </p><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_6" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>那么通过上面四个坐标系的转换就可以得到一个点从世界坐标系如何转换到像素坐标系的。</p><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_7" alt=""></p><p>其中，<img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_9" alt="">为相机的内参，<img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_10" alt="">为相机的外参，fx, fy,  cx/dx+u0, cy/dy+v0的单位均为像素。相机的内参和外参可以通过张正友标定获取,如下小节介绍。通过最终的转换关系来看，一个三维中的坐标点，的确可以在图像中找到一个对应的像素点，但是反过来，通过图像中的一个点找到它在三维中对应的点就很成了一个问题，因为我们并不知道等式左边的Zc的值。 </p><h4 id="相机内参K"><a href="#相机内参K" class="headerlink" title="相机内参K"></a>相机内参K</h4><p>在计算机视觉中，摄像机内参数矩阵如下：</p><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_11" alt=""></p><p>其中 f 为摄像机的焦距，单位一般是mm;dx,dy 为像元尺寸;u0,v0 为图像中心。fx = f/dx, fy = f/dy,分别称为x轴和y轴上的归一化焦距.</p><p>为更好的理解，举个实例：<br><br>现以NiKon D700相机为例进行求解其内参数矩阵：<br><br>就算大家身边没有这款相机也无所谓，可以在网上百度一下，很方便的就知道其一些参数—— <br><br>焦距 f = 35mm<br>   最高分辨率：4256×2832<br>     传感器尺寸：36.0×23.9 mm<br><br>根据以上定义可以有：<br><br>u0= 4256/2 = 2128<br>   v0= 2832/2 = 1416<br>  dx = 36.0/4256<br>   dy = 23.9/2832<br><br>fx = f/dx = 4137.8<br>   fy = f/dy = 4147.3<br></p><p>分辨率可以从显示分辨率与图像分辨率两个方向来分类。<br><br>[1]显示分辨率（屏幕分辨率）是屏幕图像的精密度，是指显示器所能显示的像素有多少。由于屏幕上的点、线和面都是由像素组成的，<br>显示器可显示的像素越多，画面就越精细，同样的屏幕区域内能显示的信息也越多，所以分辨率是个非常重要的性能指标之一。<br>可以把整个图像想象成是一个大型的棋盘，而分辨率的表示方式就是所有经线和纬线交叉点的数目。<br>显示分辨率一定的情况下，显示屏越小图像越清晰，反之，显示屏大小固定时，显示分辨率越高图像越清晰。<br><br>[2]图像分辨率则是单位英寸中所包含的像素点数，其定义更趋近于分辨率本身的定义。</p><h4 id="畸变参数（与点集如何畸变的2D几何相关。）"><a href="#畸变参数（与点集如何畸变的2D几何相关。）" class="headerlink" title="畸变参数（与点集如何畸变的2D几何相关。）"></a>畸变参数（与点集如何畸变的2D几何相关。）</h4><p>采用理想针孔模型，由于通过针孔的光线少，摄像机曝光太慢，在实际使用中均采用透镜，可以使图像生成迅速，但代价是引入了畸变。</p><p>有两种畸变对投影图像影响较大： 径向畸变和切向畸变。</p><p>(1) 对某些透镜，光线在远离透镜中心的地方比靠近中心的地方更加弯曲，产生“筒形”或“鱼眼”现象，称为径向畸变。一般来讲，成像仪中心的径向畸变为0，越向边缘移动，畸变越严重。不过径向畸变可以通过下面的泰勒级数展开式来校正：</p><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_12" alt=""></p><p>这里（x, y）是畸变点在成像仪上的原始位置，r为该点距离成像仪中心的距离，（xcorrected ，ycorrected ）是校正后的新位置。</p><p>对于一般的摄像机校正，通常使用泰勒级数中的前两项k1和k2就够了；对畸变很大的摄像机，比如鱼眼透镜，可以使用第三径向畸变项k3.</p><p>(2) 当成像仪被粘贴在摄像机的时候，会存在一定的误差，使得图像平面和透镜不完全平行，从而产生切向畸变。也就是说，如果一个矩形被投影到成像仪上时，可能会变成一个梯形。切向畸变可以通过如下公式来校正：</p><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_13" alt=""></p><p>这里（x, y）是畸变点在成像仪上的原始位置，r为该点距离成像仪中心的距离，（xcorrected ，ycorrected ）是校正后的新位置。</p><h4 id="摄像机的外参数"><a href="#摄像机的外参数" class="headerlink" title="摄像机的外参数"></a>摄像机的外参数</h4><p>旋转向量（大小为1×3的矢量或旋转矩阵3×3）和平移向量（tx,ty,tz）。</p><p>旋转向量:旋转向量是旋转矩阵紧凑的变现形式，旋转向量为1×3的行矢量。</p><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_14" alt=""></p><p>r就是旋转向量，旋转向量的方向是旋转轴 ,旋转向量的模为围绕旋转轴旋转的角度。</p><p>通过上面的公式，我们就可以求解出旋转矩阵R。同样的已知旋转矩阵，我们也可以通过下面的公式求解得到旋转向量：</p><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_15" alt=""></p><h1 id="相机标定（或摄像机标定）"><a href="#相机标定（或摄像机标定）" class="headerlink" title="相机标定（或摄像机标定）"></a>相机标定（或摄像机标定）</h1><p>摄像机标定(Camera calibration)简单来说是从世界坐标系换到图像坐标系的过程，也就是求最终的投影矩阵的过程。</p><p>那为什么要做相机标定呢？<br><br>【1】进行摄像机标定的目的：求出相机的内、外参数，以及畸变参数。<br><br>【2】标定相机后通常是想做两件事：一个是由于每个镜头的畸变程度各不相同，通过相机标定可以校正这种镜头畸变矫正畸变，生成矫正后的图像；另一个是根据获得的图像重构三维场景。<br><br>摄像机标定过程，简单的可以简单的描述为通过标定板，如下图，可以得到n个对应的世界坐标三维点Xi和对应的图像坐标二维点xi，这些三维点到二维点的转换都可以通过上面提到的相机内参K，相机外参R和t，以及畸变参数D，经过一系列的矩阵变换得到。<br></p><h2 id="标定原理"><a href="#标定原理" class="headerlink" title="标定原理"></a>标定原理</h2><p>原理推导请参考<a href="https://zhuanlan.zhihu.com/p/24651968" target="_blank" rel="noopener">张氏法相机标定</a></p><h2 id="标定方法"><a href="#标定方法" class="headerlink" title="标定方法"></a>标定方法</h2><h3 id="摄像机标定方法分类"><a href="#摄像机标定方法分类" class="headerlink" title="摄像机标定方法分类"></a>摄像机标定方法分类</h3><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_17" alt=""></p><h3 id="使用Matlab相机标定工具箱标定相机的基本步骤"><a href="#使用Matlab相机标定工具箱标定相机的基本步骤" class="headerlink" title="使用Matlab相机标定工具箱标定相机的基本步骤"></a>使用Matlab相机标定工具箱标定相机的基本步骤</h3><p>参考：</p><ol><li><a href="http://www.cnblogs.com/star91/p/6012425.html" target="_blank" rel="noopener">http://www.cnblogs.com/star91/p/6012425.html</a></li><li><a href="https://blog.csdn.net/wangxiaokun671903/article/details/38925553" target="_blank" rel="noopener">https://blog.csdn.net/wangxiaokun671903/article/details/38925553</a></li></ol><h3 id="使用OpenCV进行相机标定"><a href="#使用OpenCV进行相机标定" class="headerlink" title="使用OpenCV进行相机标定"></a>使用OpenCV进行相机标定</h3><p>参考：</p><ol><li><a href="https://blog.csdn.net/dcrmg/article/details/52929669" target="_blank" rel="noopener">Opencv 张正友相机标定傻瓜教程</a></li><li><a href="https://blog.csdn.net/u010784534/article/details/24323643" target="_blank" rel="noopener">使用OpenCV进行相机标定(基于OpenCV2.4.3)</a></li><li><a href="https://blog.csdn.net/dcrmg/article/details/52939318" target="_blank" rel="noopener">张正友相机标定Opencv实现以及标定流程&amp;&amp;标定结果评价&amp;&amp;图像矫正流程解析（附标定程序和棋盘图）</a></li></ol><h1 id="双目立体视觉深度相机详细原理"><a href="#双目立体视觉深度相机详细原理" class="headerlink" title="双目立体视觉深度相机详细原理"></a>双目立体视觉深度相机详细原理</h1><h2 id="理想双目相机成像模型"><a href="#理想双目相机成像模型" class="headerlink" title="理想双目相机成像模型"></a>理想双目相机成像模型</h2><p>首先我们从理想的情况开始分析:假设左右两个相机位于同一平面（光轴平行），且相机参数（如焦距f）一致。那么深度值的推导原理和公式如下。公式只涉及到初中学的三角形相似知识，不难看懂。</p><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_18" alt=""><br><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_19" alt=""><br><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_20" alt=""></p><p>根据上述推导，空间点P离相机的距离（深度）z=f*b/d，可以发现如果要计算深度z，必须要知道：</p><p>（1）、相机焦距f，左右相机基线b。这些参数可以通过先验信息或者相机标定得到。</p><p>（2）、视差d。需要知道左相机的每个像素点(xl, yl)和右相机中对应点(xr, yr)的对应关系。这是双目视觉的核心问题。</p><h2 id="极线约束"><a href="#极线约束" class="headerlink" title="极线约束"></a>极线约束</h2><p>那么问题来了，对于左图中的一个像素点，如何确定该点在右图中的位置？是不是需要我们在整个图像中地毯式搜索一个个匹配？</p><p>答案是：不需要。因为有极线约束（名字听着很吓人）。极线约束对于求解图像对中像素点的对应关系非常重要。</p><p>那什么是极线呢？如下图所示。C1，C2是两个相机，P是空间中的一个点，P和两个相机中心点C1、C2形成了三维空间中的一个平面PC1C2，称为极平面（Epipolar plane）。极平面和两幅图像相交于两条直线，这两条直线称为极线(Epipolar line)。P在相机C1中的成像点是P1，在相机C2中的成像点是P2，但是P的位置事先是未知的。</p><p>我们的目标是：对于左图的P1点，寻找它在右图中的对应点P2，这样就能确定P点的空间位置，也就是我们想要的空间物体和相机的距离（深度）。</p><p>所谓极线约束（Epipolar Constraint）就是指当同一个空间点在两幅图像上分别成像时，已知左图投影点p1，那么对应右图投影点p2一定在相对于p1的极线上，这样可以极大的缩小匹配范围。</p><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_21" alt=""></p><p>根据极线约束的定义，我们可以在下图中直观的看到P2一定在对极线上，所以我们只需要沿着极线搜索一定可以找到和P1的对应点P2。</p><p>细心的朋友会发现上述过程考虑的情况（两相机共面且光轴平行，参数相同）非常理想，相机C1，C2如果不是在同一直线上怎么办？</p><p>事实上，这种情况非常常见，因为有些场景下两个相机需要独立固定，很难保证光心C1，C2完全水平，即使是固定在同一个基板上也会因为装配的原因导致光心不完全水平。如下图所示。我们看到两个相机的极线不仅不平行，还不共面，之前的理想模型那一套推导结果用不了了，这可咋办呢？</p><p>把不理想情况转化为理想情况不就OK了！这就是图像矫正（Image Rectification）技术。</p><p>参考：<a href="https://zhuanlan.zhihu.com/p/32199990" target="_blank" rel="noopener">深度相机原理揭秘–双目立体视觉</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://www.bijishequ.com/detail/397458" target="_blank" rel="noopener">http://www.bijishequ.com/detail/397458</a></li><li><a href="https://www.cnblogs.com/Jessica-jie/p/6596450.html" target="_blank" rel="noopener">https://www.cnblogs.com/Jessica-jie/p/6596450.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/32199990" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32199990</a></li><li><a href="https://cloud.tencent.com/developer/article/1015777" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1015777</a></li></ol>]]></content>
      
      <categories>
          
          <category> 理论 </category>
          
          <category> 计算机视觉 </category>
          
          <category> 成像原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 理论 </tag>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于hexo+github免费搭建个人博客</title>
      <link href="/2018/03/04/%E5%9F%BA%E4%BA%8EHexo+GitHub%20Pages%20%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <content type="html"><![CDATA[<h1 id="一、Hexo简介"><a href="#一、Hexo简介" class="headerlink" title="一、Hexo简介"></a>一、Hexo简介</h1><p>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。这里我们选用的是GitHub。Hexo同时也是GitHub上的开源项目，参见：<a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">hexojs/hexo</a> 如果想要更加全面的了解Hexo，可以到其官网 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 了解更多的细节，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。</p><h1 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h1><h1 id="三、环境配置"><a href="#三、环境配置" class="headerlink" title="三、环境配置"></a>三、环境配置</h1><h2 id="1-本机环境配置"><a href="#1-本机环境配置" class="headerlink" title="1. 本机环境配置"></a>1. 本机环境配置</h2><ol><li><p>安装Node.js</p><p> 下载<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node.js</a>,注意安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js是否安装成功，在命令行中输入 node -v. 检测npm是否安装成功，在命令行中输入npm -v</p></li><li><p>安装Hexo</p></li></ol><ul><li><p>Hexo就是我们的个人博客网站的框架， 这里需要自己在电脑常里创建一个文件夹，可以命名为Blog，Hexo框架与以后你自己发布的网页都在这个文件夹中。创建好后，进入文件夹中,使用npm命令安装Hexo，输入：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo <span class="comment">#等待一会就会完成下载安装。</span></span><br><span class="line">hexo init <span class="comment">#该命令会在目标文件夹内建立网站所需要的所有文件</span></span><br><span class="line">npm install <span class="comment">#安装依赖包</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>到这里本地博客就搭建好了。执行以下命令（在你博客的对应文件夹路径下）:</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate <span class="comment"># Or hexo g</span></span><br><span class="line">hexo server   <span class="comment"># Or hexo s</span></span><br></pre></td></tr></table></figure></li><li><p>在浏览器输入<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 就可以进行查看了。当然这个博客是本地的，别人是无法访问的，之后我们需要部署到GitHub上。常用的Hexo 命令:</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g <span class="comment">#安装Hexo</span></span><br><span class="line">npm update hexo -g <span class="comment">#升级</span></span><br><span class="line">hexo init <span class="comment">#初始化博客</span></span><br><span class="line"><span class="comment"># 命令简写</span></span><br><span class="line">hexo n <span class="string">"我的博客"</span> == hexo new <span class="string">"我的博客"</span> <span class="comment">#新建文章</span></span><br><span class="line">hexo g == hexo generate <span class="comment">#生成</span></span><br><span class="line">hexo s == hexo server <span class="comment">#启动服务预览</span></span><br><span class="line">hexo d == hexo deploy <span class="comment">#部署</span></span><br><span class="line">hexo server <span class="comment">#Hexo会监视文件变动并自动更新，无须重启服务器</span></span><br><span class="line">hexo server -s <span class="comment">#静态模式</span></span><br><span class="line">hexo server -p 5000 <span class="comment">#更改端口</span></span><br><span class="line">hexo server -i 192.168.1.1 <span class="comment">#自定义 IP</span></span><br><span class="line">hexo clean <span class="comment">#清除缓存，若是网页正常情况下可以忽略这条命令</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-git环境配置"><a href="#2-git环境配置" class="headerlink" title="2. git环境配置"></a>2. git环境配置</h2><ol><li><p>注册Github账号并新建仓库</p><ul><li>注册过程就不多说了，注册完成之后需要新建一个仓库。需要注意的是新创建的仓库的名字，必须是username.github.io。例如我的username是XXX，那么新创建的仓库的名字便是XXX.github.io。</li></ul></li><li><p>配置SSH Key</p></li></ol><ul><li><p>这一步不是必须的，配置SSH Key的话之后每次更新博客就不用都输入用户名和密码，可以方便一些。</p><p>  (1)检查本机上是否已经存在SSH Key。打开终端，输入如下命令：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> .ssh</span><br><span class="line">ls -la</span><br></pre></td></tr></table></figure><p>  检查终端输出的文件列表中是否已经存在id_rsa.pub 或 id_dsa.pub 文件，如果文件已经存在，则直接进入第三步。</p><p>  (2)创建一个SSH Key。在终端输入如下命令:</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"your_email@example.com"</span></span><br></pre></td></tr></table></figure><pre><code>按下回车，让你输入文件名，直接回车会创建使用默认文件名的文件(推荐使用默认文件名)，然后会提示你输入两次密码，可以为空。</code></pre><p>  (3)添加SSH Key到Github</p><pre><code>如果你没有指定文件名（也就是使用的默认文件名），那么你的.ssh文件夹下，应该有一个id_rsa.pub文件了，打开该文件，复制里面的文本。然后登录Github，点击右上角头像右边的三角图标，点击Settings，然后在左边菜单栏点击SSH and GPG keys，点击New SSH key，Title 随便填一个，在Key栏填入你复制的内容，点击Add SSH key，就添加成功了。</code></pre><p>  (4)检验SSH Key是否配置成功。在终端输入如下命令:</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></li></ul><pre><code>    如果出现:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Are you sure you want to <span class="built_in">continue</span> connecting (yes/no)?</span><br></pre></td></tr></table></figure>    请输入yes再按回车。如果最后出现:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi username! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure>    就说明你的SSH Key配置成功了。</code></pre><h2 id="3-同步本地博客到Github"><a href="#3-同步本地博客到Github" class="headerlink" title="3. 同步本地博客到Github"></a>3. 同步本地博客到Github</h2><ol><li><p>上面只是在本地预览，接下来要做的就是就是推送网站，也就是发布网站，让我们的网站可以被更多的人访问。在设置之前，需要解释一个概念，在blog根目录里的_config.yml文件称为站点配置文件.</p></li><li><p>我们的Hexo与GitHub关联起来，打开站点的配置文件_config.yml，翻到最后修改为：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy: </span><br><span class="line">type: git</span><br><span class="line">repo: 这里填入你之前在GitHub上创建仓库的完整路径，记得加上 .git</span><br><span class="line">branch: master参考如下：</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>例子：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line"><span class="built_in">type</span>: git</span><br><span class="line">repo: https://github.com/xiaoqiangteng/xiaoqiangteng.github.io.git</span><br><span class="line">brabch: master</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>保存站点配置文件。其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。最后安装Git部署插件，输入命令：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>这时，我们分别输入三条命令：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li></ol><pre><code>其实第三条的 hexo d 就是部署网站命令，d是deploy的缩写。完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径</code></pre><ol><li><p>发布新的博客</p><ul><li><p>既然博客已经搭建好了，那么不发几篇博文有就没有意义了，使用下面的命令来新建一篇叫做”brightloong”的文章。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">'brightloong'</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><pre><code>- 命令执行之后，你会在你文件博客根目录的source/_post目录下找到你刚刚新建的md后缀的文件，hexo博客是使用markdown语法来书写的，如果不熟悉markdown语法可以快速的看一下[markdown](https://www.appinn.com/markdown/)语法说明.&gt; 注意：在冒号后面一定要加上一个空格，否则在生成静态文件的时候会报错，并且也不能将其成功推送到github。<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: brightloong #文章标题</span><br><span class="line">date: 2017-02-24 12:03:12 #创建时间</span><br><span class="line">tags: #文章标签，如果有多个标签可以使用[1,2,3]的形式，还有其他形式自己摸索吧</span><br><span class="line">---</span><br><span class="line"><span class="section">#这之后是正文</span></span><br></pre></td></tr></table></figure>- 文章编写好之后，只用以下命令生成静态文件并推送到github上，执行完成后打开自己的博客页面，是不是发现刚刚编写的文章出现了；如果你想删除某一篇文章，那么在source/_post目录下找到对应的文章将其删除后，同样执行一下命令就OK了。</code></pre><ol><li><p>站点配置文件_config.yml</p><ul><li><p>站点配置文件_config.yml是在你博客保存目录的根目录下，注意将它与主题配置文件进行区分，我使用的主题是Next主题。下面我先介绍下站点配置文件，我将一些主要的配置做了注释，如果你想了解更多的配置的含义和作用，请访问<a href="https://hexo.io/docs/configuration.html" target="_blank" rel="noopener">Hexo官方教程</a>查看。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">BrightLoong's</span> <span class="string">Blog</span> <span class="comment">#博客的标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="comment">#子标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">Remember</span> <span class="string">what</span> <span class="string">should</span> <span class="string">be</span> <span class="string">remembered,</span> <span class="string">and</span> <span class="string">forget</span> <span class="string">what</span> <span class="string">should</span> <span class="string">be</span> <span class="string">forgotten.Alter</span> <span class="string">what</span> <span class="string">is</span> <span class="string">changeable,</span> <span class="string">and</span> <span class="string">accept</span> <span class="string">what</span> <span class="string">is</span> <span class="string">mutable.</span> <span class="comment">#博客描述，可以是一段你喜欢的话，也可以是你博客的描述，只要你开心就好。</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">BrightLoong</span> <span class="comment">#作者</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-Hans</span> <span class="comment">#语言（我使用的是简体中文）</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="comment">#时区（默认使用电脑时间）</span></span><br><span class="line"><span class="comment">##之下的保持默认就好，没有什么需要更改的</span></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' #and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="attr">https://brightloong.github.io</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span> <span class="comment">#source目录</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span> <span class="comment">#标签目录</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span> </span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span> <span class="comment">#分类目录</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span> <span class="string">static/**</span> <span class="comment">#注意这个属性（跳过渲染），你暂时不用配置，我之后会讲到，这个也是我遇到的坑</span></span><br><span class="line"><span class="comment">##之下的保持默认就好，没有什么需要更改的</span></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># File name of new posts</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  line_number:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  auto_detect:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  tab_replace:</span></span><br><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line"><span class="comment"># Date / Time format</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="attr">HH:mm:ss</span></span><br><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span> <span class="comment">#你设置的主题，接下来我会说到这个</span></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repository:</span> <span class="attr">https://github.com/BrightLoong/BrightLoong.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="设置专属域名"><a href="#设置专属域名" class="headerlink" title="设置专属域名"></a>设置专属域名</h2><p>博客搭建好后，我们可以通过之前设置好的GitHub仓库地址来访问，比如：<a href="http://XXX.github.io，而且GitHub是免费替我们托管的的，如果我们想要设置自己的专属的域名，我们可以去阿里云购买域名，我们点击添加记录，设置主机记录为@，类型为A，到IP" target="_blank" rel="noopener">http://XXX.github.io，而且GitHub是免费替我们托管的的，如果我们想要设置自己的专属的域名，我们可以去阿里云购买域名，我们点击添加记录，设置主机记录为@，类型为A，到IP</a> 192.30.252.153（固定值）。按照如上设置完成之后， 可能不会立即生效，等个几分钟，在./source目录下新建文件CNAME（没有后缀名），文件中写上我们要绑定的域名，例如: XXX.com.部署到GitHub上。这时就可以通过<a href="http://XXX.com访问" target="_blank" rel="noopener">http://XXX.com访问</a>.</p><h1 id="四、Hexo配置"><a href="#四、Hexo配置" class="headerlink" title="四、Hexo配置"></a>四、Hexo配置</h1><h2 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h2><p>搭建自己的博客，最吸引人的莫过于那千变万化的主题了，大家可以在<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo官网</a>上看到无数漂亮、大方、简洁的主题。本人使用的是简洁的<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">Next主题</a>，你可以选择你喜欢的下载下来，将其解压放入themes目录中，比如我的目录是.\themes，然后修改我在上面提到的站点配置文件中的theme属性，为你刚刚放入themes目录中文件的名字（最好是对解压文件修改一个名字，否则名字可能会比较长，我把我下载下来的主题改文了next）,做完这些之后并不代表你完成了，你还需要参考你所下载的主题所说的配置步骤进行相关的配置，由于不同的主题配置过程也尽不相同，大家根据自己下载的主题去配置，我在这里只说我使用的Next主题如何配置。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：从下面开始所说的都是Next主题的相关配置。</p></blockquote><p>如果你使用的和我一样，也是Next的主题，那么你最好还是看官方提供<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">Next使用文档</a>，并且文档是中文版的,我也仅仅是讲一些容易被忽略的配置，以及我使用的配置，以及在使用过程中遇到的问题;至于如何更换头像，添加分类和标签页面、切换主题样式（Next主题包含3中样式）之类的，大家还是照着官方的做更好。</p><ol><li><p>配置网站图标 </p><p> 如何让网站前能显示自己想要的图标，我当时也是找了很久，最后发现是在主题配置文件（我的是F:\myblog\themes\next_config.yml）的最前面，有一个favicon属性，我把一个名字叫favicon.ico的图片放到了F:\myblog\source下，然后配置如下：</p> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">favicon:</span> <span class="string">/favicon.ico</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>首页显示阅读全文按钮</p><p> 首页的文章是不是默认展开了，显示出了整篇文章，怎么才能显示出如下的阅读全文的按钮。在主题配置文件中找到auto_excerpt属性进行配置:</p> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line"> <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">#改写为true</span></span><br><span class="line"><span class="attr">   length:</span> <span class="number">150</span> <span class="comment">#默认展示的高度</span></span><br></pre></td></tr></table></figure></li></ol><pre><code>你也可以在自己的博文中添加\&lt;!--more--&gt;来决定在首页展示到什么位置（我就喜欢用这种方式），这个标签后的内容就不会展示到首页啦。</code></pre><h2 id="修改文章内链接文本样式"><a href="#修改文章内链接文本样式" class="headerlink" title="修改文章内链接文本样式"></a>修改文章内链接文本样式</h2><p>修改文件 themes\next\source\css_common\components\post\post.styl，在末尾添加如下css样式，：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 文章内链接文本样式</span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0593d3</span>;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    <span class="selector-tag">color</span>: <span class="selector-id">#fc6423</span>;</span><br><span class="line">    <span class="selector-tag">border-bottom</span>: <span class="selector-tag">none</span>;</span><br><span class="line">    <span class="selector-tag">border-bottom</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#fc6423</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中选择.post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。</p><h2 id="在每篇文章末尾统一添加“本文结束”标记"><a href="#在每篇文章末尾统一添加“本文结束”标记" class="headerlink" title="在每篇文章末尾统一添加“本文结束”标记"></a>在每篇文章末尾统一添加“本文结束”标记</h2>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo使用攻略-添加分类及标签</title>
      <link href="/2018/03/04/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/"/>
      <content type="html"><![CDATA[<h1 id="Hexo使用攻略-添加分类及标签"><a href="#Hexo使用攻略-添加分类及标签" class="headerlink" title="Hexo使用攻略-添加分类及标签"></a>Hexo使用攻略-添加分类及标签</h1><h2 id="创建“分类”选项"><a href="#创建“分类”选项" class="headerlink" title="创建“分类”选项"></a>创建“分类”选项</h2><p>###生成“分类”页并添加tpye属性</p><p>打开命令行，进入博客所在文件夹。执行命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure><p>成功后会提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Created: ~/Documents/blog/source/categories/index.md</span><br></pre></td></tr></table></figure></p><p>根据上面的路径，找到index.md这个文件，打开后默认内容是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2017-05-27 13:47:40</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>保存并关闭文件。</p><h3 id="给文章添加“categories”属性"><a href="#给文章添加“categories”属性" class="headerlink" title="给文章添加“categories”属性"></a>给文章添加“categories”属性</h3><p>打开需要添加分类的文章，为其添加categories属性。下方的categories: web前端表示添加这篇文章到“web前端”这个分类。注意：hexo一篇文章只能属于一个分类，也就是说如果在“- web前端”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- web前端”下的 “-xxx ”分类）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: jQuery对表单的操作及更多应用</span><br><span class="line">date: 2017-05-26 12:12:57</span><br><span class="line">categories: </span><br><span class="line">- web前端</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了categories: xxx的文章才会被收录到首页的“分类”中。</p><p>注意：如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>或</p><h3 id="设置分类列表"><a href="#设置分类列表" class="headerlink" title="设置分类列表"></a>设置分类列表</h3><p>在我们编辑文章的时候，直接在categories:项填写属于哪个分类，但如果分类是中文的时候，路径也会包含中文。<br>比如分类我们设置的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">categories: 编程</span><br></pre></td></tr></table></figure><p>那在生成页面后，分类列表就会出现编程这个选项，他的访问路径是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">那在生成页面后，分类列表就会出现编程这个选项，他的访问路径是：</span><br></pre></td></tr></table></figure><p>如果我们想要把路径名和分类名分别设置，需要怎么办呢？</p><p>打开根目录下的配置文件_config.yml，找到如下位置做更改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Category &amp; Tag</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">编程: programming</span><br><span class="line">生活: life</span><br><span class="line">其他: other</span><br><span class="line">tag_map:</span><br></pre></td></tr></table></figure><p>在这里category_map:是设置分类的地方，每行一个分类，冒号前面是分类名称，后面是访问路径。</p><p>可以提前在这里设置好一些分类，当编辑的文章填写了对应的分类名时，就会自动的按照对应的路径来访问。</p><h2 id="创建“标签”选项"><a href="#创建“标签”选项" class="headerlink" title="创建“标签”选项"></a>创建“标签”选项</h2><h3 id="生成“标签”页并添加tpye属性"><a href="#生成“标签”页并添加tpye属性" class="headerlink" title="生成“标签”页并添加tpye属性"></a>生成“标签”页并添加tpye属性</h3><p>打开命令行，进入博客所在文件夹。执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure><p>成功后会提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Created: ~/Documents/blog/source/tags/index.md</span><br></pre></td></tr></table></figure><p>根据上面的路径，找到index.md这个文件，打开后默认内容是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2017-05-27 14:22:08</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>添加type: “tags”到内容中，添加后是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2017-05-27 13:47:40</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>保存并关闭文件。</p><h3 id="给文章添加“tags”属性"><a href="#给文章添加“tags”属性" class="headerlink" title="给文章添加“tags”属性"></a>给文章添加“tags”属性</h3><p>打开需要添加标签的文章，为其添加tags属性。下方的tags:下方的- jQuery - 表格<br>- 表单验证就是这篇文章的标签了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: jQuery对表单的操作及更多应用</span><br><span class="line">date: 2017-05-26 12:12:57</span><br><span class="line">categories: </span><br><span class="line">- web前端</span><br><span class="line">tags:</span><br><span class="line">- jQuery</span><br><span class="line">- 表格</span><br><span class="line">- 表单验证</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>至此，成功给文章添加分类，点击首页的“标签”可以看到该标签下的所有文章。当然，只有添加了tags: xxx的文章才会被收录到首页的“标签”中。</p><h2 id="新建页面的模板"><a href="#新建页面的模板" class="headerlink" title="新建页面的模板"></a>新建页面的模板</h2><p>打开scaffolds/post.md文件，在tages:上面加入categories:,保存后，重新执行hexo n ‘name’命令，会发现新建的页面里有categories:项了。</p><p>scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。</p><h2 id="菜单中添加链接"><a href="#菜单中添加链接" class="headerlink" title="菜单中添加链接"></a>菜单中添加链接</h2><p>编辑主题的 _config.yml ，将 menu 中的 categories: /categories 注释去掉，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /</span><br><span class="line">  categories: /categories</span><br><span class="line">  archives: /archives</span><br><span class="line">  tags: /tags</span><br></pre></td></tr></table></figure><p>在主题配置文件中添加分类选项</p><p>在主题配置文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">themes/_config.yml</span><br></pre></td></tr></table></figure><p>中添加以下代码（#号后为注释内容）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  主页: /</span><br><span class="line">  所有文章: /archives</span><br><span class="line">  技巧经验: /categories/技巧经验     # 博客首页展示文本： 访问路径/自定义归档名称</span><br><span class="line">  资料总结: /categories/资料总结</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/03/03/hello-world/"/>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
