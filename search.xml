<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>git教程</title>
      <link href="/2018/04/06/git%E6%95%99%E7%A8%8B/"/>
      <content type="html"><![CDATA[<h1 id="Github常用命令总结"><a href="#Github常用命令总结" class="headerlink" title="Github常用命令总结"></a>Github常用命令总结</h1><h2 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h2><p>本小节将远程仓库变为自己可推送数据的仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git://github.com/schacon/ticgit.git</span><br><span class="line">$ <span class="built_in">cd</span> grit</span><br><span class="line">$ git remote -v</span><br><span class="line">$ git remote add pb git://github.com/paulboone/ticgit.git</span><br><span class="line">$ git fetch pb</span><br><span class="line">$ git push origin master</span><br><span class="line">$ git remote show origin</span><br></pre></td></tr></table></figure><h1 id="Git命令总结"><a href="#Git命令总结" class="headerlink" title="Git命令总结"></a>Git命令总结</h1><ul><li>git init  命令把这个目录变成Git可以管理的仓库</li><li>git add  文件添加到仓库</li><li>git commit  文件提交到仓库</li><li>git log  历史记录</li><li>git log –pretty=oneline  历史记录</li><li>HEAD  当前版本</li><li>HEAD^  上一个版本</li><li>HEAD^^  上上一个版本</li><li>HEAD~100  往上100个版本</li><li>git reset –hard HEAD^  回退到上一个版本</li><li>git reflog  记录你的每一次命令</li><li>git diff HEAD – readme.txt  查看工作区和版本库里面最新版本的区别</li><li>git status  版本的状态</li><li>git checkout – file  丢弃工作区的修改</li><li>git reset HEAD file  暂存区的修改撤销掉（unstage），重新放回工作区</li><li>git reset  既可以回退版本，也可以把暂存区的修改回退到工作区</li><li>git rm  从版本库中删除该文件</li><li>git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:michaelliao/learngit.git  关联远程库</li><li>git push -u origin master  本地库的所有内容推送到远程库上</li><li>git push  本地库的内容推送到远程</li><li>git push origin master  推送最新修改</li><li>git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:michaelliao/gitskills.git  克隆一个本地库</li><li>git checkout -b dev  创建dev分支，然后切换到dev分支</li><li>git branch  查看当前分支</li><li>git checkout master  切换回master分支</li><li>git merge dev  把dev分支的工作成果合并到master分支上</li><li>git merge  合并指定分支到当前分支</li><li>git branch -d dev  删除dev分支</li><li>git branch <name>  创建分支</name></li><li>git checkout <name>  切换分支</name></li><li>git log –grap  分支合并图</li><li>git merge –no-ff -m “merge with no-ff” dev  强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息</li><li>git stash  把当前工作现场“储藏”起来，等以后恢复现场后继续工作</li><li>git stash list  工作现场</li><li>git stash apply  恢复stash内容并不删除</li><li>git stash drop  删除工作现场</li><li>git stash pop  恢复的同时把stash内容也删了</li><li>git branch -D <name>  丢弃一个没有被合并过的分支</name></li><li>git remote  查看远程库的信息</li><li>git remote -v  显示更详细的信息</li><li>git pull  最新的提交从origin/dev抓下来</li><li>git branch –set-upstream dev origin/dev  git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接，建立本地分支和远程分支的关联</li><li>git checkout -b branch-name origin/branch-name  在本地创建和远程分支对应的分支，本地和远程分支的名称最好一致</li><li>git tag <name>  打一个新标签</name></li><li>git tag  查看所有标签</li><li>git log –pretty=oneline –abbrev-commit  找到历史提交的commit id</li><li>git show <tagname>  查看标签信息</tagname></li><li>git tag -a <tagname> -m “blablabla…”  指定标签信息</tagname></li><li>git tag -s <tagname> -m “blablabla…”  用PGP签名标签</tagname></li><li>git push origin <tagname>  推送某个标签到远程</tagname></li><li>git push origin –tags  一次性推送全部尚未推送到远程的本地标签</li><li>git tag -d <tagname>  删除一个本地标签</tagname></li><li>git push origin :refs/tags/<tagname>  删除一个远程标签</tagname></li><li>git config –global alias.st status  告诉Git，以后st就表示status </li></ul><h1 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h1><ul><li><p>Linux上安装Git</p><p>  $ sudo apt-get install git</p></li><li><p>Mac OS X上安装Git</p><p>  $ brew install git</p></li><li><p>Windows上安装Git</p><p>  在Windows上使用Git，可以从Git官网直接下载安装程序，（网速慢的同学请移步国内镜像），然后按默认选项安装即可。</p><p>  安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p></li><li><p>安装完成后，还需要最后一步设置，在命令行输入：</p><p>  $ git config –global user.name “Your Name”</p><p>  $ git config –global user.email “<a href="mailto:email@example.com" target="_blank" rel="noopener">email@example.com</a>“</p><p>  因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</p><p>  注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p></li></ul><h1 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h1><p>版本库又名仓库，英文名repository。首先，选择一个合适的地方，创建一个空目录：</p><pre><code>$ mkdir learngit$ cd learngit$ pwd/Users/michael/learngit</code></pre><p>第二步，通过git init命令把这个目录变成Git可以管理的仓库：</p><pre><code>$ git initInitialized empty Git repository in /Users/michael/learngit/.git/</code></pre><p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p><p>如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。</p><p>把文件添加到版本库,现在我们编写一个readme.txt文件，内容如下：</p><pre><code>Git is a version control system.Git is free software.</code></pre><p>用命令git add告诉Git，把文件添加到仓库：</p><pre><code>$ git add readme.txt</code></pre><p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p><p>用命令git commit告诉Git，把文件提交到仓库：</p><pre><code>$ git commit -m &quot;wrote a readme file&quot;[master (root-commit) cb926e7] wrote a readme file1 file changed, 2 insertions(+)create mode 100644 readme.txt</code></pre><p>简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><p>git commit命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。</p><p>为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：</p><pre><code>$ git add file1.txt$ git add file2.txt file3.txt$ git commit -m &quot;add 3 files.&quot;</code></pre><h1 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h1><p>在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看</p><pre><code>$ git logcommit 3628164fb26d48395383f8f31179f24e0882e1e0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date:   Tue Aug 20 15:11:49 2013 +0800append GPLcommit ea34578d5496d7dd233c827ed32a8cd576c5ee85Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date:   Tue Aug 20 14:53:12 2013 +0800add distributedcommit cb926e7ea50ad11b8f9e909c05226233bf755030Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date:   Mon Aug 19 17:51:55 2013 +0800wrote a readme file</code></pre><p>git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。<br>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数：</p><pre><code>$ git log --pretty=oneline3628164fb26d48395383f8f31179f24e0882e1e0 append GPLea34578d5496d7dd233c827ed32a8cd576c5ee85 add distributedcb926e7ea50ad11b8f9e909c05226233bf755030 wrote a readme file</code></pre><p>需要友情提示的是，你看到的一大串类似3628164…882e1e0的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p><p>好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是“add distributed”的那个版本，怎么做呢？</p><p>首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交3628164…882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</p><p>现在，我们要把当前版本“append GPL”回退到上一个版本“add distributed”，就可以使用git reset命令：</p><pre><code>$ git reset --hard HEAD^HEAD is now at ea34578 add distributed</code></pre><p>看看readme.txt的内容是不是版本add distributed：</p><pre><code>$ cat readme.txtGit is a distributed version control system.Git is free software.</code></pre><p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？</p><p>在Git中，总是有后悔药可以吃的。当你用$ git reset –hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令：</p><pre><code>$ git reflogea34578 HEAD@{0}: reset: moving to HEAD^3628164 HEAD@{1}: commit: append GPLea34578 HEAD@{2}: commit: add distributedcb926e7 HEAD@{3}: commit (initial): wrote a readme file</code></pre><h1 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h1><ul><li><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。</p></li><li><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。</p></li><li><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p></li></ul><h1 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h1><p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了</p><p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了</p><p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：</p><pre><code>$ git rm test.txtrm &apos;test.txt&apos;$ git commit -m &quot;remove test.txt&quot;[master d17efd8] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt</code></pre><p> 现在，文件就从版本库中被删除了。</p><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p><pre><code>$ git checkout -- test.txt</code></pre><p>git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><h1 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h1><p>在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库</p><p>目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p><p>现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令：</p><pre><code>$ git remote add origin git@github.com:michaelliao/learngit.git</code></pre><p>添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。</p><p>下一步，就可以把本地库的所有内容推送到远程库上：</p><pre><code>$ git push -u origin masterCounting objects: 19, done.Delta compression using up to 4 threads.Compressing objects: 100% (19/19), done.Writing objects: 100% (19/19), 13.73 KiB, done.</code></pre><p>   Total 23 (delta 6), reused 0 (delta 0)<br>   To <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:michaelliao/learngit.git</p><pre><code>* [new branch]      master -&gt; masterBranch master set up to track remote branch master from origin.</code></pre><p>把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。</p><p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p>从现在起，只要本地作了提交，就可以通过命令：</p><pre><code>$ git push origin master</code></pre><p>把本地master分支的最新修改推送至GitHub</p><h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><ol><li>原理：</li></ol><p>在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p><p>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点，每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长</p><p>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev，你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变</p><p>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并，所以Git合并分支也很快！就改改指针，工作区内容也不变！合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：</p><ol><li>实战</li></ol><p>首先，我们创建dev分支，然后切换到dev分支：</p><pre><code>$ git checkout -b devSwitched to a new branch &apos;dev&apos;</code></pre><p>git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：</p><pre><code>$ git branch dev$ git checkout devSwitched to branch &apos;dev&apos;</code></pre><p>然后，用git branch命令查看当前分支</p><pre><code>$ git branch* dev  master</code></pre><p>git branch命令会列出所有分支，当前分支前面会标一个*号。</p><p>然后，我们就可以在dev分支上正常提交</p><pre><code>$ git add readme.txt $ git commit -m &quot;branch test&quot;[dev fec145a] branch test 1 file changed, 1 insertion(+)</code></pre><p>现在，dev分支的工作完成，我们就可以切换回master分支</p><pre><code>$ git checkout masterSwitched to branch &apos;master&apos;</code></pre><p>切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变</p><p>现在，我们把dev分支的工作成果合并到master分支上：</p><pre><code>$ git merge devUpdating d17efd8..fec145aFast-forward readme.txt |    1 + 1 file changed, 1 insertion(+)</code></pre><p>git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。</p><p>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p><p>当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。</p><p>合并完成后，就可以放心地删除dev分支了：</p><pre><code>$ git branch -d devDeleted branch dev (was fec145a).</code></pre><p>删除后，查看branch，就只剩下master分支了：</p><pre><code>$ git branch* master</code></pre><p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。</p><ol><li>小结</li></ol><p>Git鼓励大量使用分支：</p><p>查看分支：git branch</p><p>创建分支：git branch <name></name></p><p>切换分支：git checkout <name></name></p><p>创建+切换分支：git checkout -b <name></name></p><p>合并某分支到当前分支：git merge <name></name></p><p>删除分支：git branch -d <name></name></p><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>用git log –graph命令可以看到分支合并图。</p><h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><p>下面我们实战一下–no-ff方式的git merge：</p><p>首先，仍然创建并切换dev分支：</p><pre><code>$ git checkout -b devSwitched to a new branch &apos;dev&apos;</code></pre><p>修改readme.txt文件，并提交一个新的commit：</p><pre><code>$ git add readme.txt $ git commit -m &quot;add merge&quot;[dev 6224937] add merge 1 file changed, 1 insertion(+)</code></pre><p>现在，我们切换回master：</p><p>   $ git checkout master<br>   Switched to branch ‘master’<br>准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward：</p><pre><code>$ git merge --no-ff -m &quot;merge with no-ff&quot; devMerge made by the &apos;recursive&apos; strategy. readme.txt |    1 + 1 file changed, 1 insertion(+)</code></pre><p>因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。</p><p>合并后，我们用git log看看分支历史：</p><pre><code> $ git log --graph --pretty=oneline --abbrev-commit*   7825a50 merge with no-ff|\| * 6224937 add merge|/*   59bc1cb conflict fixed...</code></pre><p>可以看到，不使用Fast forward模式，merge后就像这样：</p><p>分支策略<br>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</p><p>你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</p><h2 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h2><p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交，并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p><p>幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p><pre><code>$ git stashSaved working directory and index state WIP on dev: 6224937 add mergeHEAD is now at 6224937 add merge</code></pre><p>现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p><p>首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：</p><pre><code>$ git checkout masterSwitched to branch &apos;master&apos;Your branch is ahead of &apos;origin/master&apos; by 6 commits.$ git checkout -b issue-101Switched to a new branch &apos;issue-101&apos;</code></pre><p>现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：</p><pre><code>$ git add readme.txt $ git commit -m &quot;fix bug 101&quot;[issue-101 cc17032] fix bug 101 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre><p>修复完成后，切换到master分支，并完成合并，最后删除issue-101分支：</p><pre><code>$ git checkout masterSwitched to branch &apos;master&apos;Your branch is ahead of &apos;origin/master&apos; by 2 commits.$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101Merge made by the &apos;recursive&apos; strategy. readme.txt |    2 +- 1 file changed, 1 insertion(+), 1 deletion(-)$ git branch -d issue-101Deleted branch issue-101 (was cc17032).</code></pre><p>太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！</p><pre><code>$ git checkout devSwitched to branch &apos;dev&apos;$ git status# On branch devnothing to commit (working directory clean)</code></pre><p>工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看：</p><pre><code>$ git stash liststash@{0}: WIP on dev: 6224937 add merge</code></pre><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p><p>一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；</p><p>另一种方式是用git stash pop，恢复的同时把stash内容也删了：</p><pre><code>$ git stash pop# On branch dev# Changes to be committed:#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)##       new file:   hello.py## Changes not staged for commit:#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)##       modified:   readme.txt#Dropped refs/stash@{0} (f624f8e5f082f2df2bed8a4e09c12fd2943bdd40)</code></pre><p>再用git stash list查看，就看不到任何stash内容了：</p><pre><code>$ git stash list</code></pre><p>你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：</p><pre><code>$ git stash apply stash@{0}</code></pre><h2 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h2><p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p><p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p><p>现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。</p><p>于是准备开发：</p><pre><code>$ git checkout -b feature-vulcanSwitched to a new branch &apos;feature-vulcan&apos;</code></pre><p>5分钟后，开发完毕：</p><pre><code>$ git add vulcan.py$ git status# On branch feature-vulcan# Changes to be committed:#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)##       new file:   vulcan.py#$ git commit -m &quot;add feature vulcan&quot;[feature-vulcan 756d4af] add feature vulcan 1 file changed, 2 insertions(+) create mode 100644 vulcan.py</code></pre><p>切回dev，准备合并：</p><pre><code>$ git checkout dev</code></pre><p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。</p><p>但是，就在此时，接到上级命令，因经费不足，新功能必须取消！虽然白干了，但是这个分支还是必须就地销毁：</p><pre><code>$ git branch -d feature-vulcanerror: The branch &apos;feature-vulcan&apos; is not fully merged.If you are sure you want to delete it, run &apos;git branch -D feature-vulcan&apos;.</code></pre><p>销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令git branch -D feature-vulcan。</p><p>现在我们强行删除：</p><pre><code>$ git branch -D feature-vulcanDeleted branch feature-vulcan (was 756d4af).</code></pre><h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。</p><p>要查看远程库的信息，用git remote：</p><pre><code>$ git remoteorigin</code></pre><p>或者，用git remote -v显示更详细的信息</p><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><pre><code>$ git push origin master</code></pre><p>如果要推送其他分支，比如dev，就改成：</p><pre><code>$ git push origin dev</code></pre><p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看：</p><pre><code>$ git branch* master* </code></pre><p>现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：</p><pre><code>$ git checkout -b dev origin/dev</code></pre><p>现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程</p><p>你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：</p><pre><code>$ git add hello.py $ git commit -m &quot;add coding: utf-8&quot;[dev bd6ae48] add coding: utf-8 1 file changed, 1 insertion(+) $ git push origin devTo git@github.com:michaelliao/learngit.git ! [rejected]        dev -&gt; dev (non-fast-forward)error: failed to push some refs to &apos;git@github.com:michaelliao/learngit.git&apos;hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Merge the remote changes (e.g. &apos;git pull&apos;)hint: before pushing again.hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.</code></pre><p>推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：</p><pre><code>$ git pullremote: Counting objects: 5, done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 3 (delta 0)Unpacking objects: 100% (3/3), done.From github.com:michaelliao/learngit   fc38031..291bea8  dev        -&gt; origin/devThere is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for details    git pull &lt;remote&gt; &lt;branch&gt;If you wish to set tracking information for this branch you can do so with:    git branch --set-upstream dev origin/&lt;branch&gt;</code></pre><p>git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：</p><pre><code>$ git branch --set-upstream dev origin/devBranch dev set up to track remote branch dev from origin.</code></pre><p>再pull：</p><pre><code>$ git pullAuto-merging hello.pyCONFLICT (content): Merge conflict in hello.pyAutomatic merge failed; fix conflicts and then commit the result.</code></pre><p>这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：</p><pre><code>$ git commit -m &quot;merge &amp; fix hello.py&quot;[dev adca45d] merge &amp; fix hello.py$ git push origin devCounting objects: 10, done.Delta compression using up to 4 threads.Compressing objects: 100% (5/5), done.Writing objects: 100% (6/6), 747 bytes, done.Total 6 (delta 0), reused 0 (delta 0)To git@github.com:michaelliao/learngit.git   291bea8..adca45d  dev -&gt; dev</code></pre><p>因此，多人协作的工作模式通常是这样：</p><p>首先，可以试图用git push origin branch-name推送自己的修改；</p><ol><li><p>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p></li><li><p>如果合并有冲突，则解决冲突，并在本地提交；</p></li><li><p>没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！</p></li><li><p>如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name。</p></li></ol><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><p>小结</p><ul><li><p>查看远程库信息，使用git remote -v；</p></li><li><p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p></li><li><p>从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；</p></li><li><p>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；</p></li><li><p>建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；</p></li><li><p>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</p></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a></li><li><a href="https://git-scm.com" target="_blank" rel="noopener">https://git-scm.com</a></li></ul>]]></content>
      
      <categories>
          
          <category> 编程 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ILSVRC2015数据集转VOC2007数据集格式</title>
      <link href="/2018/04/05/ILSVRC2015%E6%95%B0%E6%8D%AE%E9%9B%86%E8%BD%ACVOC2007%E6%95%B0%E6%8D%AE%E9%9B%86%E6%A0%BC%E5%BC%8F/"/>
      <content type="html"><![CDATA[<h1 id="下载imageNet2015数据集"><a href="#下载imageNet2015数据集" class="headerlink" title="下载imageNet2015数据集"></a>下载imageNet2015数据集</h1><p>image-net官网下载：image-net.org</p><h1 id="VOC2007数据格式介绍"><a href="#VOC2007数据格式介绍" class="headerlink" title="VOC2007数据格式介绍"></a>VOC2007数据格式介绍</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">├── Annotations</span><br><span class="line">│   ├── 000001.xml</span><br><span class="line">│   └── 000002.xml</span><br><span class="line">|   |__ ...</span><br><span class="line">├── ImageSets</span><br><span class="line">│   └── Main</span><br><span class="line">│       ├── test.txt</span><br><span class="line">│       ├── train.txt</span><br><span class="line">│       └── val.txt</span><br><span class="line">└── JPEGImages</span><br><span class="line">    ├── 000001.jpg</span><br><span class="line">    └── 000002.jpg</span><br><span class="line">    |__ ...</span><br></pre></td></tr></table></figure><p>JPEGImages文件夹中包含了PASCAL VOC所提供的所有的图片信息，包括了训练图片和测试图片。</p><p>Annotations文件夹中存放的是xml格式的标签文件，每一个xml文件都对应于JPEGImages文件夹中的一张图片。</p><p>xml文件的具体格式如下：（对于2007_000392.jpg）:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">annotation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">folder</span>&gt;</span>VOC2012<span class="tag">&lt;/<span class="name">folder</span>&gt;</span>                           </span><br><span class="line"><span class="tag">&lt;<span class="name">filename</span>&gt;</span>2007_000392.jpg<span class="tag">&lt;/<span class="name">filename</span>&gt;</span>                               //文件名</span><br><span class="line"><span class="tag">&lt;<span class="name">source</span>&gt;</span>                                                           //图像来源（不重要）</span><br><span class="line"><span class="tag">&lt;<span class="name">database</span>&gt;</span>The VOC2007 Database<span class="tag">&lt;/<span class="name">database</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">annotation</span>&gt;</span>PASCAL VOC2007<span class="tag">&lt;/<span class="name">annotation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">image</span>&gt;</span>flickr<span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">size</span>&gt;</span>                           //图像尺寸（长宽以及通道数）</span><br><span class="line"><span class="tag">&lt;<span class="name">width</span>&gt;</span>500<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">height</span>&gt;</span>332<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">depth</span>&gt;</span>3<span class="tag">&lt;/<span class="name">depth</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">size</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">segmented</span>&gt;</span>1<span class="tag">&lt;/<span class="name">segmented</span>&gt;</span>                           //是否用于分割（在图像物体识别中01无所谓）</span><br><span class="line"><span class="tag">&lt;<span class="name">object</span>&gt;</span>                                                           //检测到的物体</span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>horse<span class="tag">&lt;/<span class="name">name</span>&gt;</span>                                         //物体类别</span><br><span class="line"><span class="tag">&lt;<span class="name">pose</span>&gt;</span>Right<span class="tag">&lt;/<span class="name">pose</span>&gt;</span>                                         //拍摄角度</span><br><span class="line"><span class="tag">&lt;<span class="name">truncated</span>&gt;</span>0<span class="tag">&lt;/<span class="name">truncated</span>&gt;</span>                                   //是否被截断（0表示完整）</span><br><span class="line"><span class="tag">&lt;<span class="name">difficult</span>&gt;</span>0<span class="tag">&lt;/<span class="name">difficult</span>&gt;</span>                                   //目标是否难以识别（0表示容易识别）</span><br><span class="line"><span class="tag">&lt;<span class="name">bndbox</span>&gt;</span>                                                   //bounding-box（包含左下角和右上角xy坐标）</span><br><span class="line"><span class="tag">&lt;<span class="name">xmin</span>&gt;</span>100<span class="tag">&lt;/<span class="name">xmin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ymin</span>&gt;</span>96<span class="tag">&lt;/<span class="name">ymin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xmax</span>&gt;</span>355<span class="tag">&lt;/<span class="name">xmax</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ymax</span>&gt;</span>324<span class="tag">&lt;/<span class="name">ymax</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bndbox</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span>&gt;</span>                                                           //检测到多个物体</span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>person<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pose</span>&gt;</span>Unspecified<span class="tag">&lt;/<span class="name">pose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">truncated</span>&gt;</span>0<span class="tag">&lt;/<span class="name">truncated</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">difficult</span>&gt;</span>0<span class="tag">&lt;/<span class="name">difficult</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bndbox</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xmin</span>&gt;</span>198<span class="tag">&lt;/<span class="name">xmin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ymin</span>&gt;</span>58<span class="tag">&lt;/<span class="name">ymin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xmax</span>&gt;</span>286<span class="tag">&lt;/<span class="name">xmax</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ymax</span>&gt;</span>197<span class="tag">&lt;/<span class="name">ymax</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bndbox</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">annotation</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ImageSets存放的是每一种类型的challenge对应的图像数据。<br>在ImageSets下有四个文件夹：</p><p>其中Action下存放的是人的动作（例如running、jumping等等，这也是VOC challenge的一部分）</p><p>Layout下存放的是具有人体部位的数据（人的head、hand、feet等等，这也是VOC challenge的一部分）</p><p>Main下存放的是图像物体识别的数据，总共分为20类。</p><p>Segmentation下存放的是可用于分割的数据。</p><p>在这里主要考察Main文件夹。</p><p>Main文件夹下包含了20个分类的***_train.txt、***_val.txt和***_trainval.txt。</p><p>这些txt中的内容都差不多如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">000012</span><br><span class="line">000017</span><br><span class="line">000023</span><br><span class="line">000026</span><br><span class="line">000032</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>表示图像的name。</p><h1 id="ILSVRC2015数据集介绍"><a href="#ILSVRC2015数据集介绍" class="headerlink" title="ILSVRC2015数据集介绍"></a>ILSVRC2015数据集介绍</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">├── Annotations</span><br><span class="line">│   └── CLS-LOC</span><br><span class="line">│       └── train</span><br><span class="line">│           ├── n01440764</span><br><span class="line">│           │   ├── n01440764_18.xml</span><br><span class="line">│           │   └── n01440764_37.xml</span><br><span class="line">|           |   |__ ...</span><br><span class="line">│           └── n01443537</span><br><span class="line">│               ├── n01443537_16.xml</span><br><span class="line">│               └── n01443537_2.xml</span><br><span class="line">|               |__ ...</span><br><span class="line">├── Data</span><br><span class="line">│   └── CLS-LOC</span><br><span class="line">│       ├── <span class="built_in">test</span></span><br><span class="line">│       ├── train</span><br><span class="line">│       │   ├── n01440764</span><br><span class="line">│       │   │   ├── n01440764_36.JPEG</span><br><span class="line">│       │   │   └── n01440764_37.JPEG</span><br><span class="line">|       |       |__ ...</span><br><span class="line">│       │   └── n01443537</span><br><span class="line">│       │       ├── n01443537_16.JPEG</span><br><span class="line">│       │       └── n01443537_2.JPEG</span><br><span class="line">|       |       |__ ...</span><br><span class="line">│       └── val</span><br><span class="line">├── ImageSets</span><br><span class="line">│   └── CLS-LOC</span><br><span class="line">│       ├── test.txt</span><br><span class="line">│       ├── train_cls.txt</span><br><span class="line">│       ├── train_loc.txt</span><br><span class="line">│       └── val.txt</span><br><span class="line">└── devkit</span><br><span class="line">    ├── COPYING</span><br><span class="line">    ├── data</span><br><span class="line">    │   └── map_clsloc.txt</span><br><span class="line">    |   |__ ...</span><br><span class="line">    ├── evaluation</span><br><span class="line">    │   └── VOCreadxml.m</span><br><span class="line">    |   |__ ...</span><br><span class="line">    └── readme.txt</span><br></pre></td></tr></table></figure><p>ILSVRC2015_devkit\devkit\data\map_clsloc.txt文件描述了类别对应关系。</p><h1 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h1><h2 id="图片JPEG转jpg格式"><a href="#图片JPEG转jpg格式" class="headerlink" title="图片JPEG转jpg格式"></a>图片JPEG转jpg格式</h2><p>VOC2007中的原图片的数据格式为.jpg格式，而ILSVRC2015数据集中的原始图片为.JPEG格式。考虑到有些深度神经网络只支持.jpg格式的图片。因此，首先将.JPEG格式图片转换为.jpg格式的图片。转换代码可参考如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">clc;</span><br><span class="line">clear all;</span><br><span class="line"> </span><br><span class="line">maindir = <span class="string">'/Users/xiaoqiangteng/Downloads/imageset/JPEGImages1/'</span>;</span><br><span class="line">subdir =  dir( maindir ); <span class="comment">% 遍历所有子文件夹</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">length</span>( subdir )</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">isequal</span>( subdir( <span class="built_in">i</span> ).name, <span class="string">'.'</span> ) || ...</span><br><span class="line">        <span class="built_in">isequal</span>( subdir( <span class="built_in">i</span> ).name, <span class="string">'..'</span> ) || ...</span><br><span class="line">        ~subdir( <span class="built_in">i</span> ).isdir )   <span class="comment">% 过滤空文件夹</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">     </span><br><span class="line">    subdirpath = fullfile( maindir, subdir( <span class="built_in">i</span> ).name, <span class="string">'*.JPEG'</span> ); <span class="comment">%subdir( i ).name = 'n00007846'; subdirpath = S:\ImageNet\JPEGImages1\n00007846\*.JPEG;</span></span><br><span class="line">    images = dir( subdirpath );   <span class="comment">% ÔÚÕâ¸ö×ÓÎÄ¼þ¼ÐÏÂÕÒºó×ºÎªjpegµÄÎÄ¼þ</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span> : <span class="built_in">length</span>( images )</span><br><span class="line">        imagepath = fullfile(maindir, subdir( <span class="built_in">i</span> ).name, images( <span class="built_in">j</span> ).name);</span><br><span class="line">        imgdata = imread( imagepath);   <span class="comment">% ÕâÀï½øÐÐÄãµÄ¶ÁÈ¡²Ù×÷</span></span><br><span class="line">        subdirpath1 = strcat(maindir, subdir( <span class="built_in">i</span> ).name);</span><br><span class="line">        subdirpath = strcat(subdirpath1, <span class="string">'/'</span>);</span><br><span class="line">        jpgPath = [subdirpath, images( j ).name(<span class="number">1</span>:end<span class="number">-5</span>), <span class="string">'.jpg'</span>];</span><br><span class="line">        imwrite(imgdata, jpgPath, <span class="string">'mode'</span>,<span class="string">'lossless'</span>);</span><br><span class="line">        delete(imagepath, images( <span class="built_in">j</span> ).name);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>待解决的问题：</p><p>函数imwrite(imgdata, jpgPath);默认参数会改变图片大小。</p><p>imwrite(imgdata, jpgPath, ‘mode’,’lossless’);加入特定模式后，图片损坏。</p><h2 id="转换XML文件"><a href="#转换XML文件" class="headerlink" title="转换XML文件"></a>转换XML文件</h2><p>参考这篇<a href="http://blog.csdn.net/samylee/article/details/51201744，他是将每个图片的数据写成了一个txt文件，然后用txt转化为xml文件。我模仿这种方法，那么我得先获得txt文件，所以现在的第一步是要将我的imageNet的annotation，即xml文件转化为参考博客所提到的txt文件。" target="_blank" rel="noopener">http://blog.csdn.net/samylee/article/details/51201744，他是将每个图片的数据写成了一个txt文件，然后用txt转化为xml文件。我模仿这种方法，那么我得先获得txt文件，所以现在的第一步是要将我的imageNet的annotation，即xml文件转化为参考博客所提到的txt文件。</a></p><h3 id="XML文件转txt文件"><a href="#XML文件转txt文件" class="headerlink" title="XML文件转txt文件"></a>XML文件转txt文件</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%createtxt.m</span></span><br><span class="line">clc;</span><br><span class="line">clear all;</span><br><span class="line"> </span><br><span class="line">RootPath = <span class="string">'/Users/xiaoqiangteng/Downloads/imageset/'</span>;</span><br><span class="line">[dir_name, count, label] = importDataFiles(RootPath);</span><br><span class="line"></span><br><span class="line">path_image = <span class="string">'/Users/xiaoqiangteng/Downloads/imageset/JPEGImages2/'</span>;<span class="comment">%原始图片文件夹</span></span><br><span class="line">path_xml = <span class="string">'/Users/xiaoqiangteng/Downloads/imageset/Annotations1/'</span>;</span><br><span class="line">path_label = <span class="string">'/Users/xiaoqiangteng/Downloads/imageset/labels/'</span>;<span class="comment">%生成的txt文件夹</span></span><br><span class="line">subdir = dir(path_xml);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">3</span> : <span class="built_in">length</span>( subdir )</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">isequal</span>( subdir( <span class="built_in">i</span> ).name, <span class="string">'.'</span> ) || ...</span><br><span class="line">        <span class="built_in">isequal</span>( subdir( <span class="built_in">i</span> ).name, <span class="string">'..'</span> ) || ...</span><br><span class="line">        ~subdir( <span class="built_in">i</span> ).isdir )   <span class="comment">% 过滤空文件夹</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">      </span><br><span class="line">    subdirpath = fullfile(path_xml, subdir( <span class="built_in">i</span> ).name, <span class="string">'*.xml'</span>);</span><br><span class="line">    xml_files1 = dir( subdirpath );   <span class="comment">% ÔÚÕâ¸ö×ÓÎÄ¼þ¼ÐÏÂÕÒºó×ºÎªxmlµÄÎÄ¼þ</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">%XML文件排序</span></span><br><span class="line">    xml_files2 = [];</span><br><span class="line">    int_xml_files = [];</span><br><span class="line">    int_xml = [];</span><br><span class="line">    xml_files = [];</span><br><span class="line">    length_xml = <span class="built_in">length</span>(xml_files1);</span><br><span class="line">    <span class="keyword">for</span> k = <span class="number">1</span>:<span class="built_in">length</span>(xml_files1)</span><br><span class="line">        xml_files2(k).name = xml_files1(k).name(<span class="number">11</span>:<span class="keyword">end</span><span class="number">-4</span>);</span><br><span class="line">        int_xml_files(k) = str2num(xml_files2(k).name);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    int_xml = sort(int_xml_files);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ii = <span class="number">1</span>:<span class="built_in">length</span>(xml_files1)</span><br><span class="line">        xml_files3 = strcat(subdir( <span class="built_in">i</span> ).name, <span class="string">'_'</span>);</span><br><span class="line">        xml_files4 = strcat(xml_files3, num2str(int_xml(ii)));</span><br><span class="line">        xml_files(ii).name = strcat(xml_files4, <span class="string">'.xml'</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    mkdir(path_label, subdir( <span class="built_in">i</span> ).name);</span><br><span class="line">    pathtxt1 = strcat(path_label, subdir( <span class="built_in">i</span> ).name);</span><br><span class="line">    pathtxt2 = strcat(pathtxt1, <span class="string">'/'</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 遍历XML文件</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span> : <span class="built_in">length</span>(xml_files)</span><br><span class="line">        <span class="built_in">disp</span>(<span class="built_in">j</span>);</span><br><span class="line">         <span class="keyword">try</span></span><br><span class="line">            pathtxt = [pathtxt2 xml_files( j ).name(<span class="number">1</span>:end<span class="number">-4</span>) <span class="string">'.txt'</span>];</span><br><span class="line">            subdir_xml = fullfile(path_xml, subdir( <span class="built_in">i</span> ).name, xml_files( <span class="built_in">j</span> ).name);</span><br><span class="line">            str = fileread(subdir_xml);</span><br><span class="line">            v = xml_parse( str );</span><br><span class="line">            xmin = v.object.bndbox.xmin;</span><br><span class="line">            ymin = v.object.bndbox.ymin;</span><br><span class="line">            xmax = v.object.bndbox.xmax;</span><br><span class="line">            ymax = v.object.bndbox.ymax;</span><br><span class="line">            filename = v.filename;</span><br><span class="line">            fid = fopen(pathtxt,<span class="string">'wt'</span>);</span><br><span class="line">            fprintf(fid,<span class="string">'%s%s'</span>,filename,<span class="string">'.JPEG'</span>);</span><br><span class="line">            fprintf(fid,<span class="string">'%c'</span>,<span class="string">' '</span>);</span><br><span class="line">            fprintf(fid,<span class="string">'%s'</span>, label&#123;i<span class="number">-2</span>&#125;);</span><br><span class="line">            fprintf(fid,<span class="string">'%c'</span>,<span class="string">' '</span>);</span><br><span class="line">            fprintf(fid,<span class="string">'%c'</span>,xmin);</span><br><span class="line">            fprintf(fid,<span class="string">'%c'</span>,<span class="string">' '</span>);</span><br><span class="line">            fprintf(fid,<span class="string">'%c'</span>,ymin);</span><br><span class="line">            fprintf(fid,<span class="string">'%c'</span>,<span class="string">' '</span>);</span><br><span class="line">            fprintf(fid,<span class="string">'%c'</span>,xmax);</span><br><span class="line">            fprintf(fid,<span class="string">'%c'</span>,<span class="string">' '</span>);</span><br><span class="line">            fprintf(fid,<span class="string">'%c'</span>,ymax);</span><br><span class="line">            fclose(fid);</span><br><span class="line">         <span class="keyword">catch</span></span><br><span class="line"><span class="comment">%             delete_image1 = strcat(path_image, subdir( i ).name);</span></span><br><span class="line"><span class="comment">%             delete_image2 = strcat(delete_image1, '/');</span></span><br><span class="line"><span class="comment">%             delete_image = [delete_image2, xml_files( j ).name(1:end-4), '.JPEG'];</span></span><br><span class="line"><span class="comment">%             delete(delete_image);</span></span><br><span class="line">             delete_xml1 = strcat(path_xml, subdir( <span class="built_in">i</span> ).name);</span><br><span class="line">             delete_xml2 = strcat(delete_xml1, <span class="string">'/'</span>);</span><br><span class="line">             delete_xml = [delete_xml2, xml_files( j ).name(<span class="number">1</span>:end<span class="number">-4</span>), <span class="string">'.xml'</span>];</span><br><span class="line">             delete(delete_xml);</span><br><span class="line">             <span class="built_in">disp</span>(<span class="string">'Wrong'</span>);</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>importDataFiles(RootPath)函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[dir_name, count, label]</span>=<span class="title">importDataFiles</span><span class="params">(RootPath)</span></span></span><br><span class="line"><span class="comment">%&lt;=============================Êý¾ÝÅúÁ¿µ¼Èë===============================&gt;%</span></span><br><span class="line">DirOutput = dir(fullfile(RootPath));           <span class="comment">%¶ÁÈ¡Ê½Ñù±àºÅÎÄ¼þÃû,dir</span></span><br><span class="line">SimpleName = &#123;DirOutput(<span class="number">3</span>:end).name&#125;';           <span class="comment">%º¯Êý¶Á³öµÄ½á¹ûÎª½á¹¹Êý×é£¬</span></span><br><span class="line">LenSimFile = <span class="built_in">length</span>(SimpleName);<span class="comment">%µÃµ½ËùÓÐtxtÎÄ¼þµÄ¸öÊý</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:LenSimFile</span><br><span class="line">    fileName = fullfile(RootPath,SimpleName&#123;i&#125;);</span><br><span class="line">    <span class="keyword">switch</span> SimpleName&#123;i&#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'map_clsloc.txt'</span></span><br><span class="line">            [dir_name, count, label] = textread(fileName,<span class="string">'%s%d%s'</span>);</span><br><span class="line">    <span class="keyword">end</span>    </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>改代码通过遍历xml文件来生成txt文件。原因在于原始图片文件夹内的图片多余对应的xml文件。</p><p>可能存在的问题：</p><p>（1）以上matlab代码通过使用XML 函数来解析XML文件，即xml_parse()函数。需要先下载该函数的工具包，下载地址：<a href="https://cn.mathworks.com/matlabcentral/fileexchange/4278-xml-toolbox?focused=5055046&amp;tab=function" target="_blank" rel="noopener">https://cn.mathworks.com/matlabcentral/fileexchange/4278-xml-toolbox?focused=5055046&amp;tab=function</a></p><p>但是该工具包在高版本的matlab已不支持，请尝试低版本的Matlab。楼主使用matlab 2014a版本，可运行。</p><p>（2）待解决的问题</p><p>以上代码仅仅支持XML中存在一个object对象。若存在多个object对象，即会报错，运行catch语句块，将不能够读取的xml文件从原文件夹中删除，以此来保证xml文件的数量同txt文件的数量相同。但是，该问题应该很好能够解决。</p><h3 id="TXT转XML"><a href="#TXT转XML" class="headerlink" title="TXT转XML"></a>TXT转XML</h3><p>接下来就可以进行将txt转化为pascal voc格式的xml文件了，在当前目录下创建一个Annotations的文件夹，代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%writeanno.m</span></span><br><span class="line">clc;</span><br><span class="line">clear all;</span><br><span class="line"> </span><br><span class="line">path_image = <span class="string">'/home/teng/programmings/datasets/imagenet/imagenet/JPEGImages/'</span>;</span><br><span class="line">path_label = <span class="string">'/home/teng/programmings/datasets/imagenet/imagenet/labels/'</span>;<span class="comment">%txt�ļ����·��</span></span><br><span class="line">path_xml = <span class="string">'/home/teng/programmings/datasets/imagenet/imagenet/Annotations/'</span>; <span class="comment">%xml�ļ����·��</span></span><br><span class="line">subdir = dir(path_label);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">3</span> : <span class="built_in">length</span>( subdir )</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">isequal</span>( subdir( <span class="built_in">i</span> ).name, <span class="string">'.'</span> ) || ...</span><br><span class="line">        <span class="built_in">isequal</span>( subdir( <span class="built_in">i</span> ).name, <span class="string">'..'</span> ) || ...</span><br><span class="line">        ~subdir( <span class="built_in">i</span> ).isdir )   <span class="comment">% �����Ŀ¼���</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">      </span><br><span class="line">    subdirpath = fullfile(path_label, subdir( <span class="built_in">i</span> ).name, <span class="string">'*.txt'</span>);</span><br><span class="line">    txt_files = dir( subdirpath );   <span class="comment">% ��������ļ������Һ�׺Ϊjpg���ļ�</span></span><br><span class="line">    </span><br><span class="line">    mkdir(path_xml, subdir( <span class="built_in">i</span> ).name);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">length</span>(txt_files)</span><br><span class="line">        <span class="built_in">disp</span>(<span class="built_in">i</span>, <span class="built_in">j</span>)</span><br><span class="line">        path_label_dir1 = strcat(path_label, subdir( <span class="built_in">i</span> ).name);</span><br><span class="line">        path_label_dir = strcat(path_label_dir1, <span class="string">'/'</span>);</span><br><span class="line">        msg = textread(strcat(path_label_dir, txt_files(<span class="built_in">j</span>).name(<span class="number">1</span>:<span class="keyword">end</span><span class="number">-4</span>),<span class="string">'.txt'</span>),<span class="string">'%s'</span>);</span><br><span class="line">        clear rec;</span><br><span class="line">        path_xml_subdir1 = strcat(path_xml, subdir( <span class="built_in">i</span> ).name);</span><br><span class="line">        path_xml_subdir = strcat(path_xml_subdir1, <span class="string">'/'</span>);</span><br><span class="line">        path = [path_xml_subdir txt_files(j).name(<span class="number">1</span>:end<span class="number">-4</span>) <span class="string">'.xml'</span>];</span><br><span class="line">        fid=fopen(path,<span class="string">'w'</span>);</span><br><span class="line">        rec.annotation.folder = <span class="string">'VOC2007'</span>;<span class="comment">%数据集名</span></span><br><span class="line">        rec.annotation.filename = strcat(txt_files(<span class="built_in">j</span>).name(<span class="number">1</span>:<span class="keyword">end</span><span class="number">-4</span>), <span class="string">'.JPEG'</span>);<span class="comment">%图片�?</span></span><br><span class="line">        rec.annotation.source.database = <span class="string">'The VOC2007 Database'</span>;<span class="comment">%随便�?    </span></span><br><span class="line">        rec.annotation.source.annotation = <span class="string">'PASCAL VOC2007'</span>;<span class="comment">%随便�?    </span></span><br><span class="line">        rec.annotation.source.image = <span class="string">'flickr'</span>;<span class="comment">%随便�?   </span></span><br><span class="line">        rec.annotation.source.flickrid = <span class="string">'0'</span>;<span class="comment">%随便�?</span></span><br><span class="line">        rec.annotation.owner.flickrid = <span class="string">'I do not know'</span>;<span class="comment">%随便�?    </span></span><br><span class="line">        rec.annotation.owner.name = <span class="string">'I do not know'</span>;<span class="comment">%随便�?</span></span><br><span class="line"></span><br><span class="line">        path_image_subdir1 = strcat(path_image, subdir( <span class="built_in">i</span> ).name);</span><br><span class="line">        path_image_subdir = strcat(path_image_subdir1, <span class="string">'/'</span>);</span><br><span class="line">        img = imread([path_image_subdir txt_files(j).name(<span class="number">1</span>:end<span class="number">-4</span>) <span class="string">'.JPEG'</span>]);</span><br><span class="line">        rec.annotation.<span class="built_in">size</span>.width = int2str(<span class="built_in">size</span>(img,<span class="number">2</span>));</span><br><span class="line">        rec.annotation.<span class="built_in">size</span>.height = int2str(<span class="built_in">size</span>(img,<span class="number">1</span>));</span><br><span class="line">        rec.annotation.<span class="built_in">size</span>.depth = int2str(<span class="built_in">size</span>(img,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        rec.annotation.segmented = <span class="string">'0'</span>;<span class="comment">%不用于分�?    </span></span><br><span class="line">        rec.annotation.object.name = msg&#123;<span class="number">2</span>&#125;;<span class="comment">%类别�?    </span></span><br><span class="line">        rec.annotation.object.pose = <span class="string">'Left'</span>;<span class="comment">%不指定姿�?    </span></span><br><span class="line">        rec.annotation.object.truncated = <span class="string">'1'</span>;<span class="comment">%没有被删�?    </span></span><br><span class="line">        rec.annotation.object.difficult = <span class="string">'0'</span>;<span class="comment">%不是难以识别的目�?    </span></span><br><span class="line">        rec.annotation.object.bndbox.xmin = msg&#123;<span class="number">3</span>&#125;;<span class="comment">%坐标x1</span></span><br><span class="line">        rec.annotation.object.bndbox.ymin = msg&#123;<span class="number">4</span>&#125;;<span class="comment">%坐标y1</span></span><br><span class="line">        rec.annotation.object.bndbox.xmax = msg&#123;<span class="number">5</span>&#125;;<span class="comment">%坐标x2</span></span><br><span class="line">        rec.annotation.object.bndbox.ymax = msg&#123;<span class="number">6</span>&#125;;<span class="comment">%坐标y2</span></span><br><span class="line">        writexml(fid,rec,<span class="number">0</span>);</span><br><span class="line">        fclose(fid);</span><br><span class="line">    <span class="keyword">end</span>   </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>writexml函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%writexml.m</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xml</span> = <span class="title">writexml</span><span class="params">(fid,rec,depth)</span></span></span><br><span class="line"></span><br><span class="line">fn=fieldnames(rec);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(fn)</span><br><span class="line">    f=rec.(fn&#123;i&#125;);</span><br><span class="line">    <span class="keyword">if</span> ~<span class="built_in">isempty</span>(f)</span><br><span class="line">        <span class="keyword">if</span> isstruct(f)</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:<span class="built_in">length</span>(f)            </span><br><span class="line">                fprintf(fid,<span class="string">'%s'</span>,<span class="built_in">repmat</span>(char(<span class="number">9</span>),<span class="number">1</span>,depth));</span><br><span class="line">                a=<span class="built_in">repmat</span>(char(<span class="number">9</span>),<span class="number">1</span>,depth);</span><br><span class="line">                fprintf(fid,<span class="string">'&lt;%s&gt;\n'</span>,fn&#123;i&#125;);</span><br><span class="line">                writexml(fid,rec.(fn&#123;i&#125;)(<span class="built_in">j</span>),depth+<span class="number">1</span>);</span><br><span class="line">                fprintf(fid,<span class="string">'%s'</span>,<span class="built_in">repmat</span>(char(<span class="number">9</span>),<span class="number">1</span>,depth));</span><br><span class="line">                fprintf(fid,<span class="string">'&lt;/%s&gt;\n'</span>,fn&#123;i&#125;);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> ~iscell(f)</span><br><span class="line">                f=&#123;f&#125;;</span><br><span class="line">            <span class="keyword">end</span>       </span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:<span class="built_in">length</span>(f)</span><br><span class="line">                fprintf(fid,<span class="string">'%s'</span>,<span class="built_in">repmat</span>(char(<span class="number">9</span>),<span class="number">1</span>,depth));</span><br><span class="line">                fprintf(fid,<span class="string">'&lt;%s&gt;'</span>,fn&#123;i&#125;);</span><br><span class="line">                <span class="keyword">if</span> ischar(f&#123;j&#125;)</span><br><span class="line">                    fprintf(fid,<span class="string">'%s'</span>,f&#123;j&#125;);</span><br><span class="line">                <span class="keyword">elseif</span> isnumeric(f&#123;j&#125;)&amp;&amp;<span class="built_in">numel</span>(f&#123;j&#125;)==<span class="number">1</span></span><br><span class="line">                    fprintf(fid,<span class="string">'%s'</span>,num2str(f&#123;j&#125;));</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    error(<span class="string">'unsupported type'</span>);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                fprintf(fid,<span class="string">'&lt;/%s&gt;\n'</span>,fn&#123;i&#125;);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="移动目录内所有文件夹内的文件至上层目录"><a href="#移动目录内所有文件夹内的文件至上层目录" class="headerlink" title="移动目录内所有文件夹内的文件至上层目录"></a>移动目录内所有文件夹内的文件至上层目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">read_dir</span></span>()&#123;</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> `ls <span class="variable">$1</span>`       <span class="comment">#注意此处这是两个反引号，表示运行系统命令</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="variable">$1</span><span class="string">"/"</span><span class="variable">$file</span> ]  <span class="comment">#注意此处之间一定要加上空格，否则会报错</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$1</span><span class="variable">$file</span></span><br><span class="line">read_dir <span class="variable">$1</span><span class="string">"/"</span><span class="variable">$file</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">mv <span class="variable">$1</span><span class="string">"/"</span><span class="variable">$file</span> /home/teng/programmings/datasets/imagenet/imagenet/Annotations</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">delete_dir</span></span>()&#123;</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> `ls <span class="variable">$1</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="variable">$1</span><span class="string">"/"</span><span class="variable">$file</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$1</span>$<span class="string">"/"</span>file</span><br><span class="line">rm -rf <span class="variable">$1</span><span class="string">"/"</span><span class="variable">$file</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#读取第一个参数</span></span><br><span class="line">read_dir <span class="variable">$1</span></span><br><span class="line">delete_dir <span class="variable">$1</span></span><br></pre></td></tr></table></figure><p>这一步的目的在于将Annotations文件夹内的所有xml文件置于一个目录下。</p><h2 id="imageSets文件夹"><a href="#imageSets文件夹" class="headerlink" title="imageSets文件夹"></a>imageSets文件夹</h2><p>代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%createimagesets.m</span></span><br><span class="line">clc;</span><br><span class="line">clear all;</span><br><span class="line">  </span><br><span class="line">file = dir(<span class="string">'/home/teng/programmings/datasets/imagenet/imagenet/Annotations/'</span>);</span><br><span class="line">len = <span class="built_in">length</span>(file)<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num_trainval=sort(randperm(len, <span class="built_in">floor</span>(<span class="number">9</span>*len/<span class="number">10</span>)));<span class="comment">%trainval集占所有数据的9/10，可以根据需要设置</span></span><br><span class="line">num_train=sort(num_trainval(randperm(<span class="built_in">length</span>(num_trainval), <span class="built_in">floor</span>(<span class="number">5</span>*<span class="built_in">length</span>(num_trainval)/<span class="number">6</span>))));<span class="comment">%train集占trainval集的5/6，可以根据需要设置</span></span><br><span class="line">num_val=setdiff(num_trainval,num_train);<span class="comment">%trainval集剩下的作为val集</span></span><br><span class="line">num_test=setdiff(<span class="number">1</span>:len,num_trainval);<span class="comment">%所有数据中剩下的作为test集</span></span><br><span class="line">path = <span class="string">'/home/teng/programmings/datasets/imagenet/imagenet/ImageSets/Main/'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fid=fopen(strcat(path, <span class="string">'trainval.txt'</span>),<span class="string">'a+'</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(num_trainval)</span><br><span class="line">    s = sprintf(<span class="string">'%s'</span>,file(num_trainval(<span class="built_in">i</span>)+<span class="number">2</span>).name);</span><br><span class="line">    fprintf(fid,[s(<span class="number">1</span>:length(s)<span class="number">-4</span>) <span class="string">'\r\n'</span>]);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fclose(fid);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fid=fopen(strcat(path, <span class="string">'train.txt'</span>),<span class="string">'a+'</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(num_train)</span><br><span class="line">    s = sprintf(<span class="string">'%s'</span>,file(num_train(<span class="built_in">i</span>)+<span class="number">2</span>).name);</span><br><span class="line">    fprintf(fid,[s(<span class="number">1</span>:length(s)<span class="number">-4</span>) <span class="string">'\r\n'</span>]);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fclose(fid);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fid=fopen(strcat(path, <span class="string">'val.txt'</span>),<span class="string">'a+'</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(num_val)</span><br><span class="line">    s = sprintf(<span class="string">'%s'</span>,file(num_val(<span class="built_in">i</span>)+<span class="number">2</span>).name);</span><br><span class="line">    fprintf(fid,[s(<span class="number">1</span>:length(s)<span class="number">-4</span>) <span class="string">'\r\n'</span>]);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fclose(fid);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fid=fopen(strcat(path, <span class="string">'test.txt'</span>),<span class="string">'a+'</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(num_test)</span><br><span class="line">    s = sprintf(<span class="string">'%s'</span>,file(num_test(<span class="built_in">i</span>)+<span class="number">2</span>).name);</span><br><span class="line">    fprintf(fid,[s(<span class="number">1</span>:length(s)<span class="number">-4</span>) <span class="string">'\r\n'</span>]);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fclose(fid);</span><br></pre></td></tr></table></figure><p>这样所需的文件夹我们都已备齐，将imageSets，Annotations和JPEGiImage文件夹分别放入voc数据集的对应位置，在这之前先将其原来的文件夹删除。</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li><a href="https://blog.csdn.net/xbcReal/article/details/51259558" target="_blank" rel="noopener">https://blog.csdn.net/xbcReal/article/details/51259558</a></li><li><a href="https://blog.csdn.net/samylee/article/details/51201744" target="_blank" rel="noopener">https://blog.csdn.net/samylee/article/details/51201744</a></li><li><a href="https://blog.csdn.net/sinat_30071459/article/details/50723212" target="_blank" rel="noopener">https://blog.csdn.net/sinat_30071459/article/details/50723212</a></li></ol>]]></content>
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 深度学习 </category>
          
          <category> 数据集制作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>radio_map_construciton_update论文阅读</title>
      <link href="/2018/04/04/radio-map-construciton-update%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
      <content type="html"><![CDATA[<h1 id="信号指纹地图构建与更新论文阅读"><a href="#信号指纹地图构建与更新论文阅读" class="headerlink" title="信号指纹地图构建与更新论文阅读"></a>信号指纹地图构建与更新论文阅读</h1><h2 id="论文一：A-novel-radio-map-construction-method-to-reduce-collection-effort-for-indoor-localization-2016"><a href="#论文一：A-novel-radio-map-construction-method-to-reduce-collection-effort-for-indoor-localization-2016" class="headerlink" title="论文一：A novel radio map construction method to reduce collection effort for indoor localization (2016)"></a>论文一：A novel radio map construction method to reduce collection effort for indoor localization (2016)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">He, C., Guo, S., Wu, Y., &amp; Yang, Y. (2016). A novel radio map construction method to reduce collection effort <span class="keyword">for</span> indoor localization. Measurement, 94, 423-431.</span><br></pre></td></tr></table></figure><p><strong>Radio map construction</strong></p><p>linear interpolation or bilinear interpolation is utilized to reduce human effort [4] and manifold alignment (流形对齐) is used to simulate radio map in [13], <font color="red"> but these methods are complex and do not consider the indoor environment. </font></p><p>In order to reduce human effort on collecting RSS values at each calibration point, we propose an efficient and simple method of radio map construction based on the signal propagation model related to real-time indoor environment. <font color="red"> The locations of three APs are known a prior and the distance among the three APs can be calculated based on their coordinates and denoted as d12; d13; d23, respectively.</font></p><p><strong>Performance evaluation</strong></p><p>In the experiment, the radio signal propagates with 802.11b/g protocol, and the radio channels are orthogonal in order to avoid interference. The sampling rate of collecting signal strength is one sample every 3 s and the signal strength is set to the maximum signal strength 10 dBm and minimum signal strength 90 dBm. With these settings, we collect 200 samples at each primary calibration point near the preselected APs.</p><p>[4] M. Redzic, C. Brennan, N. O’Connor, SEAMLOC: seamless indoor localisation based on reduced number of calibration points, IEEE Trans. Mobile Comput. 13(6) (2014) 1326–1337.</p><p>[13] S. Sorour, Y. Lostanlen, S. Valaee, K. Majeed, Joint indoor localization and radio map construction with limited deployment load, IEEE Trans. Mob. Comput. 14(5) (2015) 1031–1043.</p><h2 id="论文二：AdaMap-Adaptive-Radiomap-for-Indoor-Localization-2015"><a href="#论文二：AdaMap-Adaptive-Radiomap-for-Indoor-Localization-2015" class="headerlink" title="论文二：AdaMap: Adaptive Radiomap for Indoor Localization (2015)"></a>论文二：AdaMap: Adaptive Radiomap for Indoor Localization (2015)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yang, Z., Wang, Y., &amp; Song, L. (2015, June). Adamap: Adaptive radiomap <span class="keyword">for</span> indoor localization. In International Conference on Ad-Hoc Networks and Wireless (pp. 134-147). Springer, Cham.</span><br></pre></td></tr></table></figure><p>In wireless networks, radiomap (also known as fingerprinting) based locating techniques are commonly used to cope the diverse fading signatures of radio signal, in which probabilistic or static radiomaps are trained in offline phase. A challenging problem of radiomap locating is that the radiomap can be outdated when environments change. Reconstruction of radiomap is time consuming and laborious. In this paper, we exploit the inter-beacon radio signal strength (RSS) to construct adaptive radiomap (AdaMap) by an online self-adjusted linear regression model. The distinct feature of AdaMap is that not only the radio signatures at the training locations vary with the online interbeacon RSS measurements, but also the coefficients of the model are selfadjusted when the environments change significantly, so that AdaMap is highly adaptive to the environment changes. The proposed schemes are evaluated by extensive simulations, with comparisons to the state of art of the radiomap wireless localization methods. The results showed that AdaMap presented dramatical advantages in preserving positioning accuracy when the environments changed over time.</p><h2 id="论文三：Automatic-Radio-Map-Adaptation-for-Indoor-Localization-Using-Smartphones-2018"><a href="#论文三：Automatic-Radio-Map-Adaptation-for-Indoor-Localization-Using-Smartphones-2018" class="headerlink" title="论文三：Automatic Radio Map Adaptation for Indoor Localization Using Smartphones (2018)"></a>论文三：Automatic Radio Map Adaptation for Indoor Localization Using Smartphones (2018)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Wu, C., Yang, Z., &amp; Xiao, C. (2018). Automatic Radio Map Adaptation <span class="keyword">for</span> Indoor Localization Using Smartphones. IEEE Transactions on Mobile Computing, 17(3), 517-528.</span><br></pre></td></tr></table></figure><font color="red">  Radio map update using the PDR algorithm </font><h2 id="论文四：Automatic-Signal-Strength-Map-Construction-in-Indoor-Positioning-System-Based-on-Round-Trip-Time-of-Flight-Measurements-and-Inertial-Navigation-2016"><a href="#论文四：Automatic-Signal-Strength-Map-Construction-in-Indoor-Positioning-System-Based-on-Round-Trip-Time-of-Flight-Measurements-and-Inertial-Navigation-2016" class="headerlink" title="论文四：Automatic Signal Strength Map Construction in Indoor Positioning System Based on Round Trip Time of Flight Measurements and Inertial Navigation (2016)"></a>论文四：Automatic Signal Strength Map Construction in Indoor Positioning System Based on Round Trip Time of Flight Measurements and Inertial Navigation (2016)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Galov, A., &amp; Moschevikin, A. (2016, September). Automatic signal strength map construction <span class="keyword">in</span> indoor positioning system based on round trip time of flight measurements and inertial navigation. In Wireless Systems within the Conferences on Intelligent Data Acquisition and Advanced Computing Systems (IDAACS-SWS), 2016 3rd International Symposium on (pp. 25-29). IEEE.</span><br></pre></td></tr></table></figure><font color="red">  Radio map construction using the PDR algorithm </font><h2 id="伦恩五：CARM-Crowd-Sensing-Accurate-Outdoor-RSS-Maps-with-Error-Prone-Smartphone-Measurements-2016"><a href="#伦恩五：CARM-Crowd-Sensing-Accurate-Outdoor-RSS-Maps-with-Error-Prone-Smartphone-Measurements-2016" class="headerlink" title="伦恩五：CARM: Crowd-Sensing Accurate Outdoor RSS Maps with Error-Prone Smartphone Measurements (2016)"></a>伦恩五：CARM: Crowd-Sensing Accurate Outdoor RSS Maps with Error-Prone Smartphone Measurements (2016)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Xiang, C., Yang, P., Tian, C., Zhang, L., Lin, H., Xiao, F., ... &amp; Liu, Y. (2016). Carm: crowd-sensing accurate outdoor rss maps with error-prone smartphone measurements. IEEE Transactions on Mobile Computing, 15(11), 2669-2681.</span><br></pre></td></tr></table></figure><font color="red"> Outdoor RSS Maps construction </font><h2 id="论文六：Constructing-Adaptive-Indoor-Radio-Maps-for-Dynamic-Wireless-Environments-2013"><a href="#论文六：Constructing-Adaptive-Indoor-Radio-Maps-for-Dynamic-Wireless-Environments-2013" class="headerlink" title="论文六：Constructing Adaptive Indoor Radio Maps for Dynamic Wireless Environments (2013)"></a>论文六：Constructing Adaptive Indoor Radio Maps for Dynamic Wireless Environments (2013)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cai, X., Chen, L., &amp; Chen, G. (2013, December). Constructing adaptive indoor radio maps <span class="keyword">for</span> dynamic wireless environments. In Ubiquitous Intelligence and Computing, 2013 IEEE 10th International Conference on and 10th International Conference on Autonomic and Trusted Computing (UIC/ATC) (pp. 41-47). IEEE.</span><br></pre></td></tr></table></figure><p>Abstract</p><p>In received signal strength fingerprints based indoor localization systems, the radio map built by labeled<br>wireless fingerprints is easily outdated over time, while recalibrating the overall radio map is time consuming. To avoid the tedious task, we propose to employ <font color="red">manifold alignment</font> to label the current radio map from outdated radio map, with the constraint of the Hidden Markov Model trained by trajectories of the received signal strength readings. Manifold alignment can align the low-dimensional manifold structures of two different data sets and transfer knowledge across them. Transition matrix generated by Hidden Markov Model provides addition local weights to the alignment process. The proposed algorithms are tested in a real world <font color="red">ZigBee</font> environment. Experiment results show that our method outperforms state-of-the-art  ransfer learning algorithms.</p><h2 id="论文七：Crowd-Assisted-Radio-Map-Construction-for-Wi-Fi-Positioning-Systems（2017）"><a href="#论文七：Crowd-Assisted-Radio-Map-Construction-for-Wi-Fi-Positioning-Systems（2017）" class="headerlink" title="论文七：Crowd-Assisted Radio Map Construction for Wi-Fi Positioning Systems（2017）"></a>论文七：Crowd-Assisted Radio Map Construction for Wi-Fi Positioning Systems（2017）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ahn, J., &amp; Han, D. (2017, September). Crowd-assisted radio map construction <span class="keyword">for</span> Wi-Fi positioning systems. In Indoor Positioning and Indoor Navigation (IPIN), 2017 International Conference on (pp. 1-8). IEEE.</span><br></pre></td></tr></table></figure><p>Abstract</p><p>Numerous attempts have been made to estimate position using Wi-Fi signals. Radio map, which is the collection of the received signal strength indicator (RSSI) of Wi-Fi signals along with their collected location information, is essential for the estimation of positon in a high resolution. However, the radio map construction is not only labor intensive, but also it requires periodic updates to cope with the changes of Wi-Fi environments. This paper proposes a practical location-labeling method for crowdsourced fingerprints to construct Wi-Fi radio maps in a large shopping mall environment. In the first step, the initial radio map is constructed based on a small number of reference data obtained from mobile payment transactions. In the second step, the path of the crowdsourced fingerprint sequence is accumulated and then their collected locations are estimated to improve the radio map. Experiments performed at a landmark building revealed the proposed method was effective in location-labeling of crowdsourced fingerprints.</p><h2 id="论文八：Crowdsourcing-based-WiFi-Fingerprint-Update-for-Indoor-Localization-2017"><a href="#论文八：Crowdsourcing-based-WiFi-Fingerprint-Update-for-Indoor-Localization-2017" class="headerlink" title="论文八：Crowdsourcing-based WiFi Fingerprint Update for Indoor Localization (2017)"></a>论文八：Crowdsourcing-based WiFi Fingerprint Update for Indoor Localization (2017)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fu, N., Zhang, J., Yu, W., &amp; Wang, C. (2017, May). Crowdsourcing-based wifi fingerprint update <span class="keyword">for</span> indoor localization. In Proceedings of the ACM Turing 50th Celebration Conference-China (p. 34). ACM.</span><br></pre></td></tr></table></figure><font color="red">  Radio map update using the PDR algorithm </font><h2 id="论文九：DorFin-WiFi-Fingerprint-based-Localization-Revisited-2013"><a href="#论文九：DorFin-WiFi-Fingerprint-based-Localization-Revisited-2013" class="headerlink" title="论文九：DorFin: WiFi Fingerprint-based Localization Revisited (2013)"></a>论文九：DorFin: WiFi Fingerprint-based Localization Revisited (2013)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Wu, C., Yang, Z., Zhou, Z., Liu, Y., &amp; Liu, M. (2013). DorFin: WiFi fingerprint-based localization revisited. arXiv preprint arXiv:1308.6663.</span><br></pre></td></tr></table></figure><p>Abstract</p><p>Although WiFi fingerprint-based indoor localization is attractive, its accuracy remains a primary challenge especially in mobile environments. Existing approaches either appeal to physical layer information or rely on extra wireless signals for high accuracy. In this paper, we revisit the RSS fingerprint-based localization scheme and reveal crucial observations that act as the root causes of localization errors, yet are surprisingly overlooked or even unseen in previous works. Specifically, we recognize APs’ diverse discrimination for fingerprinting a specific location, observe the RSS inconsistency caused by signal fluctuations and human body blockages, and uncover the RSS outdated problem<br>on commodity smartphones. Inspired by these insights, we devise a discrimination factor to quantify different APs’ discrimination, incorporate robust regression to tolerate outlier measurements, and reassemble different fingerprints to cope with outdated RSSs. Combining these techniques in a unified solution, we propose DorFin, a novel scheme of <font color="red"> fingerprint generation</font>, representation, and matching, which yields remarkable accuracy without incurring extra cost. Extensive experiments demonstrate that DorFin achieves mean error of 2 meters and more importantly, bounds the 95th percentile error under 5.5 meters; these are about 56% and 69% lower, respectively, compared with the stateofthe-art schemes such as Horus and RADAR.</p><h2 id="论文十：Gain-Without-Pain-Accurate-WiFi-based-Localization-using-Fingerprint-Spatial-Gradient"><a href="#论文十：Gain-Without-Pain-Accurate-WiFi-based-Localization-using-Fingerprint-Spatial-Gradient" class="headerlink" title="论文十：Gain Without Pain: Accurate WiFi-based Localization using Fingerprint Spatial Gradient"></a>论文十：Gain Without Pain: Accurate WiFi-based Localization using Fingerprint Spatial Gradient</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Wu, C., Xu, J., Yang, Z., Lane, N. D., &amp; Yin, Z. (2017). Gain without pain: Accurate WiFi-based localization using fingerprint spatial gradient. Proceedings of the ACM on Interactive, Mobile, Wearable and Ubiquitous Technologies, 1(2), 29.</span><br></pre></td></tr></table></figure><p>Among numerous indoor localization systems proposed during the past decades, WiFi fingerprint-based localization has been one of the most attractive solutions, which is known to be free of extra infrastructure and specialized hardware. However, current WiFi fingerprinting suffers from a pivotal problem of RSS fluctuations caused by unpredictable environmental dynamics.The RSS variations lead to severe spatial ambiguity and temporal instability in RSS fingerprinting, both impairing the location accuracy. To overcome such drawbacks, we propose <font color="red">fingerprint spatial gradient (FSG), a more stable and distinctive form than RSS fingerprints, which exploits the spatial relationships among the RSS fingerprints of multiple neighbouring locations.</font>As a spatially relative form, FSG is more resistant to RSS uncertainties. Based on the concept of FSG, we design novel algorithms to construct FSG on top of a general RSS fingerprint database and then propose effective FSG matching methods for location estimation. Unlike previous works, the resulting system, named ViVi, yields performance gain without the pains of introducing extra information or additional service restrictions or assuming impractical RSS models. Extensive experiments in different buildings demonstrate that ViVi achieves great performance, outperforming the best among four comparative start-of-the-art approaches by 29% in mean accuracy and 19% in 95th percentile accuracy and outweighing the worst one by 39% and 24% respectively. We envision FSG as a promising supplement and alternative to existing RSS fingerprinting for future WiFi localization.</p><h2 id="论文十一：Indoor-Localization-and-Automatic-Fingerprint-Update-with-Altered-AP-Signals-2017"><a href="#论文十一：Indoor-Localization-and-Automatic-Fingerprint-Update-with-Altered-AP-Signals-2017" class="headerlink" title="论文十一：Indoor Localization and Automatic Fingerprint Update with Altered AP Signals (2017)"></a>论文十一：Indoor Localization and Automatic Fingerprint Update with Altered AP Signals (2017)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">He, S., Lin, W., &amp; Chan, S. H. G. (2017). Indoor localization and automatic fingerprint update with altered AP signals. IEEE Transactions on Mobile Computing, 16(7), 1897-1910.</span><br></pre></td></tr></table></figure><h2 id="论文十二：Indoor-Localization-and-Radio-Map-Estimation-using-Unsupervised-Manifold-Alignment-with-Geometry-Perturbation-（2016）"><a href="#论文十二：Indoor-Localization-and-Radio-Map-Estimation-using-Unsupervised-Manifold-Alignment-with-Geometry-Perturbation-（2016）" class="headerlink" title="论文十二：Indoor Localization and Radio Map Estimation using Unsupervised Manifold Alignment with Geometry Perturbation （2016）"></a>论文十二：Indoor Localization and Radio Map Estimation using Unsupervised Manifold Alignment with Geometry Perturbation （2016）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Majeed, K., Sorour, S., Al-Naffouri, T. Y., &amp; Valaee, S. (2016). Indoor localization and radio map estimation using unsupervised manifold alignment with geometry perturbation. IEEE Transactions on Mobile Computing, 15(11), 2794-2808.</span><br></pre></td></tr></table></figure><p>Abstract</p><p>The Received Signal Strength (RSS) based fingerprinting approaches for indoor localization pose a need for updating the fingerprint databases due to dynamic nature of the indoor environment. This process is hectic and time-consuming when the size of the indoor area is large. The semi-supervised approaches reduce this workload and achieve good accuracy around 15% of the fingerprinting load but the performance is severely degraded if it is reduced below this level. We propose an indoor localization framework that uses <font color="red"> unsupervised manifold alignment</font>. It requires only 1% of the fingerprinting load, some crowd sourced readings and plan coordinates of the indoor area. The 1% fingerprinting load is used only in perturbing the local geometries of the plan coordinates. The proposed framework achieves less than 5m mean localization error, which is considerably better than semi-supervised approaches at very small amount of fingerprinting load. In addition, the few location estimations together with few fingerprints help to<br>estimate the complete radio map of the indoor environment. The estimation of radio map does not demand extra workload rather it employs the already available information from the proposed indoor localization framework. The testing results for radio map estimation show almost 50% performance improvement by using this information as compared to using only fingerprints.</p><h2 id="论文十三：iUpdater-Low-Cost-RSS-Fingerprints-Updating-for-Device-free-Localization（2017）"><a href="#论文十三：iUpdater-Low-Cost-RSS-Fingerprints-Updating-for-Device-free-Localization（2017）" class="headerlink" title="论文十三：iUpdater: Low Cost RSS Fingerprints Updating for Device-free Localization（2017）"></a>论文十三：iUpdater: Low Cost RSS Fingerprints Updating for Device-free Localization（2017）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Chang, L., Xiong, J., Wang, Y., Chen, X., Hu, J., &amp; Fang, D. (2017, June). iUpdater: Low Cost RSS Fingerprints Updating <span class="keyword">for</span> Device-free Localization. In Distributed Computing Systems (ICDCS), 2017 IEEE 37th International Conference on (pp. 900-910). IEEE.</span><br></pre></td></tr></table></figure><h2 id="论文十四：Joint-Indoor-Localization-and-Radio-Map-Construction-with-Limited-Deployment-Load-（2015）"><a href="#论文十四：Joint-Indoor-Localization-and-Radio-Map-Construction-with-Limited-Deployment-Load-（2015）" class="headerlink" title="论文十四：Joint Indoor Localization and Radio Map Construction with Limited Deployment Load （2015）"></a>论文十四：Joint Indoor Localization and Radio Map Construction with Limited Deployment Load （2015）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sorour, S., Lostanlen, Y., Valaee, S., &amp; Majeed, K. (2015). Joint indoor localization and radio map construction with limited deployment load. IEEE Transactions on Mobile Computing, 14(5), 1031-1043.</span><br></pre></td></tr></table></figure><p>Abstract</p><p>One major bottleneck in the practical implementation of received signal strength (RSS) based indoor localization systems is the extensive deployment efforts required to construct the radio maps through fingerprinting. In this paper, we aim to design an indoor localization scheme that can be directly employed without building a full fingerprinted radio map of the indoor environment. By accumulating the information of localized RSSs, this scheme can also simultaneously construct the radio map with limited calibration. To design this scheme, we employ a source data set that possesses the same spatial correlation of the RSSs in the indoor environment under study. The knowledge of this data set is then transferred to a limited number of calibration fingerprints and one or several RSS observations with unknown locations, in order to perform direct localization of these observations using <font color="red"> manifold alignment</font>.We test two different source data sets, namely a simulated radio propagation map and the environments plan coordinates. For moving users, we exploit the correlation of their observations to improve the localization accuracy. The online testing in two indoor environments shows that the plan coordinates achieves better results than the simulated radio maps, and a negligible degradation with 70-85% reduction in calibration load.</p><h2 id="论文十五：MobiBee-A-Mobile-Treasure-Hunt-Game-for-Location-dependent-Fingerprint-Collection"><a href="#论文十五：MobiBee-A-Mobile-Treasure-Hunt-Game-for-Location-dependent-Fingerprint-Collection" class="headerlink" title="论文十五：MobiBee: A Mobile Treasure Hunt Game for Location-dependent Fingerprint Collection"></a>论文十五：MobiBee: A Mobile Treasure Hunt Game for Location-dependent Fingerprint Collection</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Xu, Q., &amp; Zheng, R. (2016, September). Mobibee: A mobile treasure hunt game <span class="keyword">for</span> location-dependent fingerprint collection. In Proceedings of the 2016 ACM International Joint Conference on Pervasive and Ubiquitous Computing: Adjunct (pp. 1472-1477). ACM.</span><br></pre></td></tr></table></figure><p>Constructing a location-dependent fingerprint map is one of the essential steps for fingerprint-based indoor localization. A comprehensive site survey is time-consuming, laborintensive, and subjects to environmental changes. In this work, we develop <font color="red"> a mobile participatory game, MobiBee, to collect fingerprints with the help of quick response (QR) codes (posted on walls or pillars as location tags)</font>. Various incentive strategies, including monetary, entertainment and competition, are utilized. The location marker is deliberately designed to ensure that fingerprints are collected at the targeted locations in a stationary manner. Interestingly, a few instances of QR code forgery have been identified during the game play, which exposes the vulnerability of using QR code in indoor localization. A fraud detection mechanism is hence proposed. Experiments show that the proposed approach can accurately detect the QR code forgery and improve indoor localization accuracy.</p><h2 id="论文十六：A-Visual-Based-Approach-for-Indoor-Radio-Map-Construction-Using-Smartphones"><a href="#论文十六：A-Visual-Based-Approach-for-Indoor-Radio-Map-Construction-Using-Smartphones" class="headerlink" title="论文十六：A Visual-Based Approach for Indoor Radio Map Construction Using Smartphones"></a>论文十六：A Visual-Based Approach for Indoor Radio Map Construction Using Smartphones</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Liu, T., Zhang, X., Li, Q., &amp; Fang, Z. (2017). A Visual-Based Approach <span class="keyword">for</span> Indoor Radio Map Construction Using Smartphones. Sensors, 17(8), 1790.</span><br></pre></td></tr></table></figure><p>Abstract</p><p>Localization of users in indoor spaces is a common issue in many applications. Among various technologies, a Wi-Fi fingerprinting based localization solution has attracted much attention, since it can be easily deployed using the existing off-the-shelf mobile devices and wireless networks. However, the collection of the Wi-Fi radio map is quite labor-intensive, which limits its potential for large-scale application. In this paper, a visual-based approach is proposed for the construction of a radio map in anonymous indoor environments. <font color="red">This approach collects multi-sensor data, e.g.,Wi-Fi signals, video frames, inertial readings, when people are walking in indoor environments with smartphones in their hands. Then, it spatially recovers the trajectories of people by using both visual and inertial information. Finally, it estimates the location of fingerprints from the trajectories and constructs a Wi-Fi radio map.</font> Experiment results show that the average location error of the fingerprints is about 0.53 m. A weighted k-nearest neighbor method is also used to evaluate the constructed radio map. The average localization error is about 3.2 m, indicating that the quality of the constructed radio map is at the same level as those constructed by site surveying. However, this approach can greatly reduce the human labor cost, which increases the potential for applying it to large indoor environments.</p>]]></content>
      
      <categories>
          
          <category> 学术 </category>
          
          <category> 信号指纹 </category>
          
          <category> 指纹地图构建与更新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学术 </tag>
            
            <tag> 信号指纹 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++教程-cmake</title>
      <link href="/2018/04/03/C++%E6%95%99%E7%A8%8B-cmake/"/>
      <content type="html"><![CDATA[<h1 id="Cmake入门"><a href="#Cmake入门" class="headerlink" title="Cmake入门"></a>Cmake入门</h1><h2 id="CMake编译原理"><a href="#CMake编译原理" class="headerlink" title="CMake编译原理"></a>CMake编译原理</h2><p>CMake是一种跨平台编译工具，比make更为高级，使用起来要方便得多。CMake主要是编写CMakeLists.txt文件，然后用cmake命令将CMakeLists.txt文件转化为make所需要的makefile文件，最后用make命令编译源码生成可执行程序或共享库（so(shared object)）。因此CMake的编译基本就两个步骤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>cmake  指向CMakeLists.txt所在的目录，例如cmake .. 表示CMakeLists.txt在当前目录的上一级目录。cmake后会生成很多编译的中间文件以及makefile文件，所以一般建议新建一个新的目录，专门用来编译，例如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>make根据生成makefile文件，编译程序。</p><h2 id="使用Cmake编译程序"><a href="#使用Cmake编译程序" class="headerlink" title="使用Cmake编译程序"></a>使用Cmake编译程序</h2><h3 id="源码文件介绍"><a href="#源码文件介绍" class="headerlink" title="源码文件介绍"></a>源码文件介绍</h3><p>本文以一个例子入手介绍，即开平方。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── CMakeLists.txt</span><br><span class="line">└── src</span><br><span class="line">    ├── main.cpp</span><br><span class="line">    ├── test_math.cpp</span><br><span class="line">    └── test_math.h</span><br></pre></td></tr></table></figure><p>其中，src目录存放所有的源代码，即test_math.cpp、test_math.h和main.cpp。每个源代码文件内容如下：</p><p>test_math.h:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEST4_TEST_MATH_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST4_TEST_MATH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cal_sqrt</span><span class="params">(<span class="keyword">double</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//TEST4_TEST_MATH_H</span></span></span><br></pre></td></tr></table></figure><p>test_math.cpp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test_math.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cal_sqrt</span><span class="params">(<span class="keyword">double</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.cpp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test_math.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">49.0</span>;</span><br><span class="line">    <span class="keyword">double</span> b = <span class="number">0.0</span>;</span><br><span class="line">    b = cal_sqrt(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sqrt result:%f\n"</span>,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写CMakeLists-txt"><a href="#编写CMakeLists-txt" class="headerlink" title="编写CMakeLists.txt"></a>编写CMakeLists.txt</h3><p>CMakeLists.txt文件，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1.</span>cmake verson，指定cmake版本</span><br><span class="line">cmake_minimum_required(VERSION <span class="number">3.8</span>)</span><br><span class="line"></span><br><span class="line">#<span class="number">2.</span>project name，指定项目的名称，一般和项目的文件夹名称对应</span><br><span class="line">project(test4)</span><br><span class="line"></span><br><span class="line">#<span class="number">3.</span>head file path，头文件目录</span><br><span class="line">#INCLUDE_DIRECTORIES(include)</span><br><span class="line"></span><br><span class="line">#<span class="number">4.</span>source directory，源文件目录</span><br><span class="line">AUX_SOURCE_DIRECTORY(src DIR_SRCS)</span><br><span class="line"></span><br><span class="line">#<span class="number">5.</span><span class="built_in">set</span> environment variable，设置环境变量，编译用到的源文件全部都要放到这里，否则编译能够通过，但是执行的时候会出现各种问题，比如<span class="string">"symbol lookup error xxxxx , undefined symbol"</span></span><br><span class="line">SET(TEST_MATH $&#123;DIR_SRCS&#125;)</span><br><span class="line"></span><br><span class="line">#<span class="number">7.</span>add link library，添加可执行文件所需要的库，比如我们用到了libm.so（命名规则：lib+name+.so），就添加该库的名称</span><br><span class="line">#TARGET_LINK_LIBRARIES($&#123;PROJECT_NAME&#125; m)</span><br><span class="line"></span><br><span class="line">#<span class="number">6.</span>add executable file，添加要编译的可执行文件</span><br><span class="line">ADD_EXECUTABLE($&#123;PROJECT_NAME&#125; $&#123;TEST_MATH&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br></pre></td></tr></table></figure><h3 id="编译和运行程序"><a href="#编译和运行程序" class="headerlink" title="编译和运行程序"></a>编译和运行程序</h3><p>由于编译中出现许多中间的文件，因此最好新建一个独立的目录build，在该目录下进行编译，编译步骤如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>build下生成的目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">├── CMakeLists.txt</span><br><span class="line">├── cmake-build-debug</span><br><span class="line">│   ├── CMakeCache.txt</span><br><span class="line">│   ├── CMakeFiles</span><br><span class="line">│   │   ├── 3.8.2</span><br><span class="line">│   │   │   ├── CMakeCCompiler.cmake</span><br><span class="line">│   │   │   ├── CMakeCXXCompiler.cmake</span><br><span class="line">│   │   │   ├── CMakeDetermineCompilerABI_C.bin</span><br><span class="line">│   │   │   ├── CMakeDetermineCompilerABI_CXX.bin</span><br><span class="line">│   │   │   ├── CMakeSystem.cmake</span><br><span class="line">│   │   │   ├── CompilerIdC</span><br><span class="line">│   │   │   │   ├── CMakeCCompilerId.c</span><br><span class="line">│   │   │   │   ├── a.out</span><br><span class="line">│   │   │   │   └── tmp</span><br><span class="line">│   │   │   └── CompilerIdCXX</span><br><span class="line">│   │   │       ├── CMakeCXXCompilerId.cpp</span><br><span class="line">│   │   │       ├── a.out</span><br><span class="line">│   │   │       └── tmp</span><br><span class="line">│   │   ├── CMakeDirectoryInformation.cmake</span><br><span class="line">│   │   ├── CMakeOutput.log</span><br><span class="line">│   │   ├── CMakeTmp</span><br><span class="line">│   │   ├── Makefile.cmake</span><br><span class="line">│   │   ├── Makefile2</span><br><span class="line">│   │   ├── TargetDirectories.txt</span><br><span class="line">│   │   ├── clion-environment.txt</span><br><span class="line">│   │   ├── clion-log.txt</span><br><span class="line">│   │   ├── cmake.check_cache</span><br><span class="line">│   │   ├── feature_tests.bin</span><br><span class="line">│   │   ├── feature_tests.c</span><br><span class="line">│   │   ├── feature_tests.cxx</span><br><span class="line">│   │   ├── progress.marks</span><br><span class="line">│   │   └── test4.dir</span><br><span class="line">│   │       ├── CXX.includecache</span><br><span class="line">│   │       ├── DependInfo.cmake</span><br><span class="line">│   │       ├── build.make</span><br><span class="line">│   │       ├── cmake_clean.cmake</span><br><span class="line">│   │       ├── depend.internal</span><br><span class="line">│   │       ├── depend.make</span><br><span class="line">│   │       ├── flags.make</span><br><span class="line">│   │       ├── link.txt</span><br><span class="line">│   │       ├── progress.make</span><br><span class="line">│   │       └── src</span><br><span class="line">│   │           ├── main.cpp.o</span><br><span class="line">│   │           └── test_math.cpp.o</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── cmake_install.cmake</span><br><span class="line">│   ├── test4</span><br><span class="line">│   └── test4.cbp</span><br><span class="line">└── src</span><br><span class="line">    ├── main.cpp</span><br><span class="line">    ├── test_math.cpp</span><br><span class="line">    └── test_math.h</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://www.cnblogs.com/cv-pr/p/6206921.html" target="_blank" rel="noopener">http://www.cnblogs.com/cv-pr/p/6206921.html</a></li></ul>]]></content>
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++ </category>
          
          <category> cmake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>colmap源码解读</title>
      <link href="/2018/04/03/colmap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
      <content type="html"><![CDATA[<h1 id="feature-extractor-cc"><a href="#feature-extractor-cc" class="headerlink" title="feature_extractor.cc"></a>feature_extractor.cc</h1><h2 id="include"><a href="#include" class="headerlink" title="#include "></a>#include <memory></memory></h2><p>1 auto_ptr</p><p>C++的auto_ptr所做的事情，就是动态分配对象以及当对象不再需要时自动执行清理。</p><p>使用std::auto_ptr，要#include <memory>。</memory></p><p>double *p = new double;//为指针分配内存</p><p>std::auto_ptr<double> autop(p);</double></p><p>//继承性指针，必须依赖上面的指针p</p><p>//创建智能指针管理指针p指向的内存，可以自动释放内存，不用delete就可以自动删除</p><p>//搭配原生指针p使用，不用担心多delete或者少delete</p><p>//auto_ptr更多用于管理类和对象的内存</p><p>2 unique_ptr</p><p>unique_ptr是一种定义在<memory>中的智能指针(smart pointer)。它持有对对象的独有权——两个unique_ptr不能指向一个对象，不能进行复制操作只能进行移动操作。unique_ptr在超出作用域，即以下情况时它指向的对象会被摧毁：</memory></p><p>unique_ptr指向的对象被破坏</p><p>对象通过operator=（）或reset（）被指定到另一个指针）</p><p>unique_ptr还可能没有对象，这种情况被称为empty。</p><p>//C++11新指针</p><p>//std::unique_ptr&lt;指针指向的变量数据类型&gt;指针变量名(new 指针指向的变量数据类型);</p><p>std::unique_ptr<double>pdb(new double);</double></p>]]></content>
      
      <categories>
          
          <category> 编程 </category>
          
          <category> colmap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> colmap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++教程-glog功能介绍</title>
      <link href="/2018/04/03/C++%E6%95%99%E7%A8%8B-glog%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/"/>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Google glog是一个基于程序级记录日志信息的c++库，编程使用方式与c++的stream操作类似，例：</p><pre><code>LOG(INFO) &lt;&lt; &quot;Found &quot; &lt;&lt; num_cookies &lt;&lt; &quot; cookies&quot;;</code></pre><p>“LOG”宏为日志输出关键字，“INFO”为严重性程度。</p><p>主要支持功能：</p><ul><li>参数设置，以命令行参数的方式设置标志参数来控制日志记录行为；</li><li>严重性分级，根据日志严重性分级记录日志；</li><li>可有条件地记录日志信息；</li><li>条件中止程序。丰富的条件判定宏，可预设程序终止条件；</li><li>异常信号处理。程序异常情况，可自定义异常处理过程；</li><li>支持debug功能。可只用于debug模式；</li><li>自定义日志信息；</li><li>线程安全日志记录方式；</li><li>系统级日志记录；</li><li>google perror风格日志信息；</li><li>精简日志字符串信息。</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>最新版本：0.3.1  <a href="http://code.google.com/p/google-glog/" target="_blank" rel="noopener">http://code.google.com/p/google-glog/</a></p><p>安装只需：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>简单示例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"glog/logging.h"</span>   <span class="comment">// glog 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  google::InitGoogleLogging(argv[<span class="number">0</span>]);    <span class="comment">// 初始化</span></span><br><span class="line">  <span class="comment">// FLAGS_log_dir=".";   </span></span><br><span class="line">  LOG(INFO) &lt;&lt; <span class="string">"hello glog"</span>;     <span class="comment">// 打印log：“hello glog.  类似于C++ stream。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Makefile:</p><p>LIB=$(HOME)/install/glog/lib    #glog 安装路径</p><p>INCLUDE=$(HOME)/install/glog/include</p><p>test_glog : main.o</p><pre><code>g++ -o $@ $^ -L$(LIB) -lglog –lpthread   #-lpthread 因为glog在多线程中需要一些锁机制。</code></pre><p>main.o: main.cpp</p><pre><code>g++ -c -o $@ $^ -I$(INCLUDE)</code></pre><p>说明：</p><p>glog 默认对log分为4级： INFO,  WARNING,  ERROR,  FATAL.  打印log语句类似于C++中的stream，实际上LOG(INFO) 宏返回的是一个继承自std::ostrstream类的对象。</p><p>编译运行上述demo， glog默认会在/tmp/目录下生成log日志文件：test_glog.search-x2.username.log.INFO.20111003-161341.2083</p><p>文件名各字段对应含义为：</p><p><program name="">.<hostname>.<user name="">.log.<severity level="">.<date>.<time>.<pid></pid></time></date></severity></user></hostname></program></p><p>其中：</p><p>1），<program name=""> 其实对应google::InitGoogleLogging(argv[0])；中的argv[0]，即通过改变google::InitGoogleLogging的参数可以修改日志文件的名称。</program></p><p>2），每个级别的日志会输出到不同的文件中。并且高级别日志文件会同样输入到低级别的日志文件中。 即：FATAL的信息会同时记录在INFO，WARNING，ERROR，FATAL日志文件中。默认情况下，glog还会将会将FATAL的日志发送到stderr中。</p><p>现在的问题是：log总不能都打印到/tmp/目录下吧。</p><p>参数设置：</p><p>不同于log4系列的日志系统通过配置文件的方式， glog采用命令的方式来来配置参数。在glog的官方文档里，提到如下两种方式来配置参数（以修改日志目录为例：）</p><p>1），gflags：</p><p>./your_application –log_dir=.</p><p>（gflags 我还没有使用过）</p><p>2），export 修改环境变量，如下所示：修改GLOG_log_dir为上层目录</p><p>3）以上两种方法都需要使用命令行，除此之外，还可以直接在程序中指定（官方文档中没有提到， glog源代码中也不鼓励这么用，但确实是可行的）：</p><p>在glog/logging.h 头文件287—350行，有诸如“GLOG_log_dir”等变量的宏定义， 则其GLOG_log_dir实际为FLAGS_log_dir,  因此只需要在程序中设置FLAGS_log_dir的值即可。其他变量类似。取消main.cpp中的注释行“// FLAGS_log_dir=”.”; ” 试试吧</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://blog.51cto.com/mengjh/546766" target="_blank" rel="noopener">http://blog.51cto.com/mengjh/546766</a></li><li><a href="http://www.cnblogs.com/foreveryl/archive/2011/10/14/2212265.html" target="_blank" rel="noopener">http://www.cnblogs.com/foreveryl/archive/2011/10/14/2212265.html</a></li></ul>]]></content>
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++ </category>
          
          <category> glog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux-深度学习环境配置</title>
      <link href="/2018/03/31/linux-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <content type="html"><![CDATA[<h1 id="Ubuntu16-04-cuda8-0-GPU驱动配置"><a href="#Ubuntu16-04-cuda8-0-GPU驱动配置" class="headerlink" title="Ubuntu16.04 cuda8.0 GPU驱动配置"></a>Ubuntu16.04 cuda8.0 GPU驱动配置</h1><h2 id="检查是否正确识别显卡"><a href="#检查是否正确识别显卡" class="headerlink" title="检查是否正确识别显卡"></a>检查是否正确识别显卡</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci | grep -i nvidia</span><br></pre></td></tr></table></figure><h2 id="查看是否已有安装的NVIDIA驱动"><a href="#查看是否已有安装的NVIDIA驱动" class="headerlink" title="查看是否已有安装的NVIDIA驱动"></a>查看是否已有安装的NVIDIA驱动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep nvidia</span><br></pre></td></tr></table></figure><h2 id="查看集显驱动"><a href="#查看集显驱动" class="headerlink" title="查看集显驱动"></a>查看集显驱动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep nouveau</span><br></pre></td></tr></table></figure><h2 id="关闭桌面服务"><a href="#关闭桌面服务" class="headerlink" title="关闭桌面服务"></a>关闭桌面服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service lightdm stop</span><br></pre></td></tr></table></figure><h2 id="GPU驱动配置"><a href="#GPU驱动配置" class="headerlink" title="GPU驱动配置"></a>GPU驱动配置</h2><p>根据GPU型号从相应网站下载驱动，例如使用NVIDIA Tesla M60，从<a href="http://www.nvidia.cn/Download/index.aspx?lang=cn" target="_blank" rel="noopener">NVIDIA网站</a>选择对应的型号和操作系统，CUDA Toolkit版本，下载驱动文件，如NVIDIA-Linux-x86_64-375.66.run，运行驱动文件，根据提示安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh  NVIDIA-Linux-x86_64-375.66.run</span><br></pre></td></tr></table></figure><h3 id="卸载掉原有驱动"><a href="#卸载掉原有驱动" class="headerlink" title="卸载掉原有驱动"></a>卸载掉原有驱动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove –purge nvidia*</span><br></pre></td></tr></table></figure><h3 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h3><p>安装驱动可能需要的依赖(可选):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> apt-get update</span><br><span class="line"></span><br><span class="line"><span class="variable">$sudo</span> apt-get install dkms build-essential linux-headers-generic</span><br></pre></td></tr></table></figure><p>进入命令行界面</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-Alt+F1</span><br></pre></td></tr></table></figure></code></pre><p>给驱动run文件赋予执行权限</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod a+x NVIDIA-Linux-x86_64-375.20.run</span><br></pre></td></tr></table></figure></code></pre><p>安装: 注意下面参数</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo ./NVIDIA-Linux-x86_64-375.20.run –no-x-check –no-nouveau-check –no-opengl-files </span><br><span class="line"><span class="comment"># –no-x-check安装驱动时关闭X服务 </span></span><br><span class="line"><span class="comment"># –no-nouveau-check 安装驱动时禁用nouveau </span></span><br><span class="line"><span class="comment"># –no-opengl-files 只安装驱动文件，不安装OpenGL文件</span></span><br></pre></td></tr></table></figure></code></pre><p>重启</p><p>注意：安装CUDA时一定使用runfile文件，这样可以进行选择。不再选择安装驱动，以及在弹出xorg.conf时选择NO<br>不要使用ubuntu设置中附加驱动中驱动</p><h2 id="安装cuda"><a href="#安装cuda" class="headerlink" title="安装cuda"></a>安装<a href="https://developer.nvidia.com/cuda-80-ga2-download-archive" target="_blank" rel="noopener">cuda</a></h2><p>注意这里下载的是cuda8.0的runfile（local）文件。 </p><p>这里是nvidia给出的官方安装指南（遇到问题时可以查阅) </p><p>下载完cuda8.0后，执行如下语句，运行runfile文件： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh cuda_8.0.27_linux.run</span><br></pre></td></tr></table></figure><p>因为驱动之前已经安装，这里就不要选择安装驱动。其余的都直接默认或者选择是即可。</p><p>使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/profile</span><br></pre></td></tr></table></figure><p>打开“profile”文件，在末尾处添加（注意不要有空格，不然会报错):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/cuda-8.0/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/cuda-8.0/lib64<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure><p>重启电脑：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><p>测试cuda的Samples:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/cuda-8.0/samples/1_Utilities/deviceQuery</span><br><span class="line">sudo make</span><br><span class="line">./deviceQuery</span><br></pre></td></tr></table></figure><h1 id="OpenCV3-1配置"><a href="#OpenCV3-1配置" class="headerlink" title="OpenCV3.1配置"></a>OpenCV3.1配置</h1><h2 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line"><span class="comment"># 必须的，gcc编译环境</span></span><br><span class="line"></span><br><span class="line">sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev</span><br><span class="line"><span class="comment"># 必须的,包括cmake等工具</span></span><br><span class="line"></span><br><span class="line">sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev</span><br><span class="line"><span class="comment"># 可选的，看个人需要，总共5M左右</span></span><br><span class="line"></span><br><span class="line">sudo apt-get install libv4l-dev</span><br></pre></td></tr></table></figure><h2 id="下载-源码"><a href="#下载-源码" class="headerlink" title="下载 源码"></a>下载 源码</h2><p><a href="https://opencv.org/releases.html" target="_blank" rel="noopener">OpenCV</a></p><p>或着用git clone：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/opencv310</span><br><span class="line">    <span class="comment"># opencv310为自己建的，源码将放在这里</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/Itseez/opencv.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/Itseez/opencv_contrib.git</span><br></pre></td></tr></table></figure><h2 id="CMake-Opencv源码"><a href="#CMake-Opencv源码" class="headerlink" title="CMake Opencv源码"></a>CMake Opencv源码</h2><p>建立一个编译目录（例如：/build）把cmake后的文件都放在这里边。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/opencv</span><br><span class="line">mkdir build  //建立一个build目录，把cmake的文件都放着里边</span><br><span class="line"><span class="built_in">cd</span> build　　　//进入build目录</span><br></pre></td></tr></table></figure><p>cmake时ippicv_linux_20151201.tgz总是不能成功下载，故cmake之前将./downloads/linux-808b791a6eac9ed78d32a7666804320e 文件拷贝至./opencv-3.1.0/3rdparty/ippicv/ 路径下(先执行一次cmake 命令生成文件路径，在将ippicv_linux_20151201.tgz复制进去) 首先，手动下载<a href="https://raw.githubusercontent.com/Itseez/opencv_3rdparty/81a676001ca8075ada498583e4166079e5744668/ippicv/ippicv_linux_20151201.tgz" target="_blank" rel="noopener">ippicv</a></p><p>然后开始cmake，这里需要注意几个cmake的参数，比较重要。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/<span class="built_in">local</span> WITH_LIBV4L=ON ..</span><br></pre></td></tr></table></figure><p>切记最后’..’两个点之前要加空格！！</p><h2 id="把代码编译成可执行文件"><a href="#把代码编译成可执行文件" class="headerlink" title="把代码编译成可执行文件"></a>把代码编译成可执行文件</h2><p>这里官方推荐使用多进程编译，推荐七个进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 报错：</span></span><br><span class="line"><span class="comment"># modules/cudalegacy/src/graphcuts.cpp:120:54: error: </span></span><br><span class="line"><span class="comment"># ‘NppiGraphcutState’ has not been declared</span></span><br><span class="line"><span class="comment"># typedef NppStatus (*init_func_t)(NppiSize oSize, </span></span><br><span class="line"><span class="comment"># NppiGraphcutState** ppState, Npp8u* pDeviceMem);</span></span><br><span class="line"><span class="comment"># 这是因为opecv3.0与cuda8.0不兼容导致的。解决办法： </span></span><br><span class="line"><span class="comment"># 修改 ～/opencv/modules/cudalegacy/src/graphcuts.cpp文件内容</span></span><br><span class="line"><span class="comment"># 将  </span></span><br><span class="line"><span class="comment"># #if !defined (HAVE_CUDA) || defined (CUDA_DISABLER)   </span></span><br><span class="line"><span class="comment"># 改为  </span></span><br><span class="line"><span class="comment"># #if !defined (HAVE_CUDA) || defined (CUDA_DISABLER) || (CUDART_VERSION &gt;= 8000) </span></span><br><span class="line">make -j7 <span class="comment"># 并行运行七个jobs，这一步也在build目录中进行</span></span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">如果你要在python下运行opencv库的情况下，那就必须安装安装python-opencv</span><br><span class="line">sudo apt-get install python-opencv</span><br></pre></td></tr></table></figure><h2 id="配置库文件路径"><a href="#配置库文件路径" class="headerlink" title="配置库文件路径"></a>配置库文件路径</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c <span class="string">'echo "/usr/local/lib" &gt; /etc/ld.so.conf.d/opencv.conf'</span></span><br><span class="line"><span class="comment">#或者直接打开/etc/ld.so.conf.d/opencv.conf，添加/usr/local/lib</span></span><br><span class="line"><span class="comment">#使配置生效</span></span><br><span class="line">sudo  ldconfig(重要)</span><br></pre></td></tr></table></figure><h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo vim/etc/bash.bashrc   </span><br><span class="line"><span class="comment">#在最后加入以下两行代码</span></span><br><span class="line">PKG_CONFIG_PATH=<span class="variable">$PKG_CONFIG_PATH</span>:/usr/<span class="built_in">local</span>/lib/pkgconfig </span><br><span class="line"><span class="built_in">export</span> PKG_CONFIG_PATH  </span><br><span class="line"><span class="comment">#使配置生效</span></span><br><span class="line">sudo <span class="built_in">source</span> /etc/bash.bashrc </span><br><span class="line">（该步骤可能会报错找不到命令，原因是<span class="built_in">source</span>为root命令</span><br><span class="line">su（进入root权限）</span><br></pre></td></tr></table></figure><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --modversion opencv</span><br><span class="line">pkg-config --cflags opencv</span><br></pre></td></tr></table></figure><h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><p>我是用python+opencv的，我这里直接运行opencv自带的python的例子程序，TX1自带摄像头不能用，需要使用外接USB摄像头，插入USB接口即可，无需安装驱动，也无需改动测试代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;opencv3.1.0_dir&gt;/samples/python/</span><br><span class="line">python video.py</span><br><span class="line">python edge.py</span><br><span class="line">python facedetect.py</span><br></pre></td></tr></table></figure><h1 id="Caffe配置"><a href="#Caffe配置" class="headerlink" title="Caffe配置"></a>Caffe配置</h1><p>安装的路径下 clone ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/BVLC/caffe.git</span><br></pre></td></tr></table></figure><p>进入 caffe ，将 Makefile.config.example 文件复制一份并更名为 Makefile.config ，也可以在 caffe 目录下直接调用以下命令完成复制操作 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp Makefile.config.example Makefile.config</span><br></pre></td></tr></table></figure><p>复制一份的原因是编译 caffe 时需要的是 Makefile.config 文件，而Makefile.config.example 只是caffe 给出的配置文件例子，不能用来编译 caffe。</p><p>参考我的Makefile.config：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Refer to http://caffe.berkeleyvision.org/installation.html</span></span><br><span class="line"><span class="comment"># Contributions simplifying and improving our build system are welcome!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cuDNN acceleration switch (uncomment to build with cuDNN).</span></span><br><span class="line"><span class="comment"># USE_CUDNN := 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU-only switch (uncomment to build without GPU support).</span></span><br><span class="line"><span class="comment"># CPU_ONLY := 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># uncomment to disable IO dependencies and corresponding data layers</span></span><br><span class="line"><span class="comment"># USE_OPENCV := 0</span></span><br><span class="line"><span class="comment"># USE_LEVELDB := 0</span></span><br><span class="line"><span class="comment"># USE_LMDB := 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># uncomment to allow MDB_NOLOCK when reading LMDB files (only if necessary)</span></span><br><span class="line"><span class="comment">#You should not set this flag if you will be reading LMDBs with any</span></span><br><span class="line"><span class="comment">#possibility of simultaneous read and write</span></span><br><span class="line"><span class="comment"># ALLOW_LMDB_NOLOCK := 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment if you're using OpenCV 3</span></span><br><span class="line">OPENCV_VERSION := 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># To customize your choice of compiler, uncomment and set the following.</span></span><br><span class="line"><span class="comment"># N.B. the default for Linux is g++ and the default for OSX is clang++</span></span><br><span class="line"><span class="comment"># CUSTOM_CXX := g++</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CUDA directory contains bin/ and lib/ directories that we need.</span></span><br><span class="line">CUDA_DIR := /usr/<span class="built_in">local</span>/cuda</span><br><span class="line"><span class="comment"># On Ubuntu 14.04, if cuda tools are installed via</span></span><br><span class="line"><span class="comment"># "sudo apt-get install nvidia-cuda-toolkit" then use this instead:</span></span><br><span class="line"><span class="comment"># CUDA_DIR := /usr</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CUDA architecture setting: going with all of them.</span></span><br><span class="line"><span class="comment"># For CUDA &lt; 6.0, comment the *_50 lines for compatibility.</span></span><br><span class="line">CUDA_ARCH := -gencode arch=compute_20,code=sm_20 \</span><br><span class="line">-gencode arch=compute_20,code=sm_21 \</span><br><span class="line">-gencode arch=compute_30,code=sm_30 \</span><br><span class="line">-gencode arch=compute_35,code=sm_35 \</span><br><span class="line">-gencode arch=compute_50,code=sm_50 \</span><br><span class="line">-gencode arch=compute_50,code=compute_50</span><br><span class="line"></span><br><span class="line"><span class="comment"># BLAS choice:</span></span><br><span class="line"><span class="comment"># atlas for ATLAS (default)</span></span><br><span class="line"><span class="comment"># mkl for MKL</span></span><br><span class="line"><span class="comment"># open for OpenBlas</span></span><br><span class="line">BLAS := open</span><br><span class="line"><span class="comment"># Custom (MKL/ATLAS/OpenBLAS) include and lib directories.</span></span><br><span class="line"><span class="comment"># Leave commented to accept the defaults for your choice of BLAS</span></span><br><span class="line"><span class="comment"># (which should work)!</span></span><br><span class="line"><span class="comment"># BLAS_INCLUDE := /path/to/your/blas</span></span><br><span class="line"><span class="comment"># BLAS_LIB := /path/to/your/blas</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Homebrew puts openblas in a directory that is not on the standard search path</span></span><br><span class="line"><span class="comment"># BLAS_INCLUDE := $(shell brew --prefix openblas)/include</span></span><br><span class="line"><span class="comment"># BLAS_LIB := $(shell brew --prefix openblas)/lib</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This is required only if you will compile the matlab interface.</span></span><br><span class="line"><span class="comment"># MATLAB directory should contain the mex binary in /bin.</span></span><br><span class="line"><span class="comment"># MATLAB_DIR := /usr/local</span></span><br><span class="line"><span class="comment"># MATLAB_DIR := /Applications/MATLAB_R2012b.app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> this is required only if you will compile the python interface.</span></span><br><span class="line"><span class="comment"># We need to be able to find Python.h and numpy/arrayobject.h.</span></span><br><span class="line">PYTHON_INCLUDE := /usr/include/python2.7 \</span><br><span class="line">/usr/lib64/python2.7/site-packages/numpy/core/include</span><br><span class="line"><span class="comment"># Anaconda Python distribution is quite popular. Include path:</span></span><br><span class="line"><span class="comment"># Verify anaconda location, sometimes it's in root.</span></span><br><span class="line"><span class="comment"># ANACONDA_HOME := $(HOME)/anaconda</span></span><br><span class="line"><span class="comment"># PYTHON_INCLUDE := $(ANACONDA_HOME)/include \</span></span><br><span class="line"><span class="comment"># $(ANACONDA_HOME)/include/python2.7 \</span></span><br><span class="line"><span class="comment"># $(ANACONDA_HOME)/lib/python2.7/site-packages/numpy/core/include \</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We need to be able to find libpythonX.X.so or .dylib.</span></span><br><span class="line">PYTHON_LIB := /usr/lib</span><br><span class="line"><span class="comment"># PYTHON_LIB := $(ANACONDA_HOME)/lib</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Homebrew installs numpy in a non standard path (keg only)</span></span><br><span class="line"><span class="comment"># PYTHON_INCLUDE += $(dir $(shell python -c 'import numpy.core; print(numpy.core.__file__)'))/include</span></span><br><span class="line"><span class="comment"># PYTHON_LIB += $(shell brew --prefix numpy)/lib</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment to support layers written in Python (will link against Python libs)</span></span><br><span class="line">WITH_PYTHON_LAYER := 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Whatever else you find you need goes here.</span></span><br><span class="line">INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/<span class="built_in">local</span>/include /usr/include/hdf5/serial/</span><br><span class="line">LIBRARY_DIRS := $(PYTHON_LIB) /usr/<span class="built_in">local</span>/lib /usr/lib /usr/lib/x86_64-linux-gnu /usr/lib/x86_64-linux-gnu/hdf5/serial</span><br><span class="line"></span><br><span class="line"><span class="comment"># If Homebrew is installed at a non standard location (for example your home directory) and you use it for general dependencies</span></span><br><span class="line"><span class="comment"># INCLUDE_DIRS += $(shell brew --prefix)/include</span></span><br><span class="line"><span class="comment"># LIBRARY_DIRS += $(shell brew --prefix)/lib</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment to use `pkg-config` to specify OpenCV library paths.</span></span><br><span class="line"><span class="comment"># (Usually not necessary -- OpenCV libraries are normally installed in one of the above $LIBRARY_DIRS.)</span></span><br><span class="line"><span class="comment"># USE_PKG_CONFIG := 1</span></span><br><span class="line"></span><br><span class="line">BUILD_DIR := build</span><br><span class="line">DISTRIBUTE_DIR := distribute</span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment for debugging. Does not work on OSX due to https://github.com/BVLC/caffe/issues/171</span></span><br><span class="line"><span class="comment"># DEBUG := 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The ID of the GPU that 'make runtest' will use to run unit tests.</span></span><br><span class="line">TEST_GPUID := 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># enable pretty build (comment to see full commands)</span></span><br><span class="line">Q ?= @</span><br></pre></td></tr></table></figure><p>可以开始编译了，在 caffe 目录下执行 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make all -j8</span><br><span class="line">sudo make runtest -j8</span><br><span class="line">sudo make pycaffe -j8 <span class="comment"># 安装 pycaffe notebook 接口环境</span></span><br></pre></td></tr></table></figure><h1 id="darknet配置"><a href="#darknet配置" class="headerlink" title="darknet配置"></a><a href="https://pjreddie.com/darknet/yolo/" target="_blank" rel="noopener">darknet</a>配置</h1><p>环境: Ubuntu16.04 + Titan X + Cuda8.0 + OpenCV3.1 + Python2.7</p><p>请参考前文。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/pjreddie/darknet</span><br><span class="line"><span class="built_in">cd</span> darknet</span><br><span class="line"><span class="comment"># 配置Makefile</span></span><br><span class="line"><span class="comment"># GPU=1</span></span><br><span class="line"><span class="comment"># CUDNN=0</span></span><br><span class="line"><span class="comment"># OPENCV=1</span></span><br><span class="line"><span class="comment"># DEBUG=0</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>可能出现的报错：</p><p>（1）error:/usr/bin/ld: 找不到 -lippicv<br><br>collect2: error: ld returned 1 exit status <br><br>Makefile:82: recipe for target ‘libdarknet.so’ failed <br></p><p>解决方法：找到-lippicv对应的库（libippicv.a），该库位于 安装目录./opencv-3.1.0/3rdparty/ippicv/unpack/ippicv_lnx/lib/intel64文件夹下 ，进入该文件夹下执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sudo cp sudo cp libippicv.a /usr/<span class="built_in">local</span>/lib/</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">继续执行make 即可。</span><br><span class="line"></span><br><span class="line">（2）找不到nvcc</span><br><span class="line"></span><br><span class="line">解决方法：修改darknet下的Makefile文件，将其中的NVCC=nvcc改为/usr/<span class="built_in">local</span>/cuda-*/bin/nvcc即安装的cuda版本信息</span><br><span class="line"></span><br><span class="line">保存  继续执行make 即可。</span><br><span class="line"></span><br><span class="line">下载权重测试:</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">wget http://pjreddie.com/media/files/yolo.weights  </span><br><span class="line">./darknet yolo <span class="built_in">test</span> cfg/yolo.cfg yolo.weights data/dog.jpg   </span><br><span class="line">./darknet detect cfg/yolo.cfg yolo.weights data/dog.jpg</span><br></pre></td></tr></table></figure><ul><li><a href="https://blog.csdn.net/ch_liu23/article/details/53558549" target="_blank" rel="noopener">YOLOv2训练自己的数据集（VOC格式）</a></li><li><a href="https://blog.csdn.net/jozeeh/article/details/79087311" target="_blank" rel="noopener">YOLOv2目标检测<em>单目标</em>训练自己数据全过程（自用）</a></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.liaohuqiu.net/cn/posts/ssh-public-key-auto-login/" target="_blank" rel="noopener">https://www.liaohuqiu.net/cn/posts/ssh-public-key-auto-login/</a></li><li><a href="https://blog.csdn.net/asukasmallriver/article/details/72927860" target="_blank" rel="noopener">https://blog.csdn.net/asukasmallriver/article/details/72927860</a></li><li><a href="https://blog.csdn.net/u011440558/article/details/78358447" target="_blank" rel="noopener">https://blog.csdn.net/u011440558/article/details/78358447</a></li><li><a href="https://www.mtyun.com/library/how-to-install-caffe-on-centos7" target="_blank" rel="noopener">https://www.mtyun.com/library/how-to-install-caffe-on-centos7</a></li><li><a href="https://blog.csdn.net/qq_28413479/article/details/76377184" target="_blank" rel="noopener">https://blog.csdn.net/qq_28413479/article/details/76377184</a></li><li><a href="https://blog.csdn.net/yhaolpz/article/details/71375762" target="_blank" rel="noopener">https://blog.csdn.net/yhaolpz/article/details/71375762</a></li></ol>]]></content>
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Linux </category>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Linux </tag>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深度学习-TensorFlow教程</title>
      <link href="/2018/03/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-TensorFlow%E6%95%99%E7%A8%8B/"/>
      <content type="html"><![CDATA[<h1 id="TensorFlow简介"><a href="#TensorFlow简介" class="headerlink" title="TensorFlow简介"></a>TensorFlow简介</h1><p>TensorFlow是Google开发的一款神经网络的Python外部的结构包, 也是一个采用数据流图来进行数值计算的开源软件库.TensorFlow 让我们可以先绘制计算结构图, 也可以称是一系列可人机交互的计算操作, 然后把编辑好的Python文件 转换成 更高效的C++, 并在后端进行计算.</p><h1 id="TensorFlow安装"><a href="#TensorFlow安装" class="headerlink" title="TensorFlow安装"></a>TensorFlow安装</h1><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><h3 id="Dock安装"><a href="#Dock安装" class="headerlink" title="Dock安装"></a>Dock安装</h3><p>Docker安装请参考<a href="http://mapstec.com/2018/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4GPU%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">实验室GPU服务器部署教程</a></p><h3 id="TensorFlow安装方式一"><a href="#TensorFlow安装方式一" class="headerlink" title="TensorFlow安装方式一"></a>TensorFlow安装方式一</h3><ol><li><p>下载镜像</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull tensorflow/tensorflow</span><br></pre></td></tr></table></figure></li><li><p>创建Tensorflow容器</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --name my-tensorflow -it -p 8888:8888 -v ~/tensorflow:/<span class="built_in">test</span>/data tensorflow/tensorflow</span><br><span class="line"><span class="comment"># --name：创建的容器名，即my-tensorflow</span></span><br><span class="line"><span class="comment"># -it：保留命令行运行</span></span><br><span class="line"><span class="comment"># p 8888:8888：将本地的8888端口和http://localhost:8888/映射</span></span><br><span class="line"><span class="comment"># -v ~/tensorflow:/test/data:将本地的~/tensorflow挂载到容器内的/# test/data下</span></span><br><span class="line"><span class="comment"># tensorflow/tensorflow ：默认是tensorflow/tensorflow:latest,指定使用的镜像</span></span><br></pre></td></tr></table></figure></li><li><p>拷贝带token的URL在浏览器打开</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://[all ip addresses on your system]:8888/?token=649d7cab1734e01db75b6c2b476ea87aa0b24dde56662a27</span><br></pre></td></tr></table></figure></li><li><p>显示Jupyter Notebook，Jupyter Notebook（此前被称为 IPython notebook）是一个交互式笔记本。示例中已经显示了Tensorflow的入门教程，点开一个可以看见。</p></li><li><p>关闭容器</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop my-tensortflow</span><br></pre></td></tr></table></figure></li><li><p>再次打开</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start my-tensortflow</span><br></pre></td></tr></table></figure></li></ol><h3 id="TensorFlow安装方式二"><a href="#TensorFlow安装方式二" class="headerlink" title="TensorFlow安装方式二"></a>TensorFlow安装方式二</h3><ol><li><p>下载镜像</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull tensorflow/tensorflow</span><br></pre></td></tr></table></figure></li><li><p>创建Tensorflow容器</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name bash_tensorflow tensorflow/tensorflow /bin/bash</span><br><span class="line"><span class="comment"># 这样我们就创建了名为bash_tensorflow的容器</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>start命令启动容器</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start bash_tensorflow</span><br></pre></td></tr></table></figure></li><li><p>再连接上容器</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker attach bash_tensorflow</span><br><span class="line"><span class="comment"># 可以看到我们用终端连接上了容器，和操作Linux一样了。</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Pip安装"><a href="#Pip安装" class="headerlink" title="Pip安装"></a>Pip安装</h2><h3 id="Linux-和-MacOS"><a href="#Linux-和-MacOS" class="headerlink" title="Linux 和 MacOS"></a>Linux 和 MacOS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu/Linux 64-位 系统的执行代码:</span></span><br><span class="line">$ sudo apt-get install python-pip python-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mac OS X 系统的执行代码:</span></span><br><span class="line">$ sudo easy_install --upgrade pip</span><br><span class="line">$ sudo easy_install --upgrade six</span><br></pre></td></tr></table></figure><ol><li><p>CPU 版</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 2+ 的用户:</span></span><br><span class="line">$ pip install tensorflow</span><br><span class="line"></span><br><span class="line"><span class="comment"># python 3+ 的用户:</span></span><br><span class="line">$ pip3 install tensorflow</span><br></pre></td></tr></table></figure></li><li><p>GPU 版</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libcupti-dev</span><br><span class="line">$ sudo apt-get install python-pip python-dev   <span class="comment"># for Python 2.7</span></span><br><span class="line">$ sudo apt-get install python3-pip python3-dev <span class="comment"># for Python 3.n</span></span><br><span class="line">$ pip install tensorflow      <span class="comment"># Python 2.7; CPU support (no GPU support)</span></span><br><span class="line">$ pip3 install tensorflow     <span class="comment"># Python 3.n; CPU support (no GPU support)</span></span><br><span class="line">$ pip install tensorflow-gpu  <span class="comment"># Python 2.7;  GPU support</span></span><br><span class="line">$ pip3 install tensorflow-gpu <span class="comment"># Python 3.n; GPU support</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>测试</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow</span><br></pre></td></tr></table></figure></li></ol><h1 id="TensorFlow-教程"><a href="#TensorFlow-教程" class="headerlink" title="TensorFlow 教程"></a>TensorFlow 教程</h1><h2 id="Session-会话控制"><a href="#Session-会话控制" class="headerlink" title="Session 会话控制"></a>Session 会话控制</h2><p>参考：</p><ul><li><a href="https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/2-3-session/" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/2-3-session/</a></li></ul><p>Session 是 Tensorflow 为了控制,和输出文件的执行的语句. 运行 session.run() 可以获得你要得知的运算结果, 或者是你所要运算的部分.</p><p>例子讲解：建立两个 matrix ,输出两个 matrix 矩阵相乘的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># create two matrixes</span></span><br><span class="line"></span><br><span class="line">matrix1 = tf.constant([[<span class="number">3</span>,<span class="number">3</span>]])</span><br><span class="line">matrix2 = tf.constant([[<span class="number">2</span>],</span><br><span class="line">                       [<span class="number">2</span>]])</span><br><span class="line">product = tf.matmul(matrix1,matrix2)</span><br></pre></td></tr></table></figure><p>因为 product 不是直接计算的步骤, 所以我们会要使用 Session 来激活 product 并得到计算结果. 有两种形式使用会话控制 Session 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># method 1</span></span><br><span class="line">sess = tf.Session()</span><br><span class="line">result = sess.run(product)</span><br><span class="line">print(result)</span><br><span class="line">sess.close()</span><br><span class="line"><span class="comment"># [[12]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># method 2</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    result2 = sess.run(product)</span><br><span class="line">    print(result2)</span><br><span class="line"><span class="comment"># [[12]]</span></span><br></pre></td></tr></table></figure><h2 id="Variable-变量"><a href="#Variable-变量" class="headerlink" title="Variable 变量"></a>Variable 变量</h2><p>参考：</p><ul><li><a href="https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/2-4-variable/" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/2-4-variable/</a></li></ul><p>在 Tensorflow 中，定义了某字符串是变量，它才是变量。定义语法： state = tf.Variable()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">state = tf.Variable(<span class="number">0</span>, name=<span class="string">'counter'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义常量 one</span></span><br><span class="line">one = tf.constant(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义加法步骤 (注: 此步并没有直接计算)</span></span><br><span class="line">new_value = tf.add(state, one)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 State 更新成 new_value</span></span><br><span class="line">update = tf.assign(state, new_value)</span><br></pre></td></tr></table></figure><p>如果你在 Tensorflow 中设定了变量，那么初始化变量是最重要的！！所以定义了变量以后, 一定要定义 init = tf.initialize_all_variables() .</p><p>到这里变量还是没有被激活，需要再在 sess 里, sess.run(init) , 激活 init 这一步.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果定义 Variable, 就一定要 initialize</span></span><br><span class="line"><span class="comment"># init = tf.initialize_all_variables() # tf 马上就要废弃这种写法</span></span><br><span class="line">init = tf.global_variables_initializer()  <span class="comment"># 替换成这样就好</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用 Session</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(init)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        sess.run(update)</span><br><span class="line">        print(sess.run(state))</span><br></pre></td></tr></table></figure><p>注意：直接 print(state) 不起作用！！</p><p>一定要把 sess 的指针指向 state 再进行 print 才能得到想要的结果！</p><h2 id="Placeholder-传入值"><a href="#Placeholder-传入值" class="headerlink" title="Placeholder 传入值"></a>Placeholder 传入值</h2><p>参考：</p><ul><li><a href="https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/2-5-placeholde/" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/2-5-placeholde/</a></li></ul><p>placeholder 是 Tensorflow 中的占位符，暂时储存变量.</p><p>Tensorflow 如果想要从外部传入data, 那就需要用到 tf.placeholder(), 然后以这种形式传输数据 sess.run(<strong>*, feed_dict={input: </strong>}).</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment">#在 Tensorflow 中需要定义 placeholder 的 type ，一般为 float32 形式</span></span><br><span class="line">input1 = tf.placeholder(tf.float32)</span><br><span class="line">input2 = tf.placeholder(tf.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># mul = multiply 是将input1和input2 做乘法运算，并输出为 output </span></span><br><span class="line">ouput = tf.multiply(input1, input2)</span><br></pre></td></tr></table></figure><p>接下来, 传值的工作交给了 sess.run() , 需要传入的值放在了feed_dict={} 并一一对应每一个 input. placeholder 与 feed_dict={} 是绑定在一起出现的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    print(sess.run(ouput, feed_dict=&#123;input1: [<span class="number">7.</span>], input2: [<span class="number">2.</span>]&#125;))</span><br><span class="line"><span class="comment"># [ 14.]</span></span><br></pre></td></tr></table></figure><h2 id="建造神经网络"><a href="#建造神经网络" class="headerlink" title="建造神经网络"></a>建造神经网络</h2><p>参考：</p><ul><li><a href="https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/3-2-create-NN/" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/3-2-create-NN/</a></li></ul><h3 id="add-layer-功能"><a href="#add-layer-功能" class="headerlink" title="add_layer 功能"></a>add_layer 功能</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_layer</span><span class="params">(inputs, in_size, out_size, activation_function=None)</span>:</span></span><br><span class="line">    Weights = tf.Variable(tf.random_normal([in_size, out_size]))</span><br><span class="line">    biases = tf.Variable(tf.zeros([<span class="number">1</span>, out_size]) + <span class="number">0.1</span>)</span><br><span class="line">    Wx_plus_b = tf.matmul(inputs, Weights) + biases</span><br><span class="line">    <span class="keyword">if</span> activation_function <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        outputs = Wx_plus_b</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        outputs = activation_function(Wx_plus_b)</span><br><span class="line">    <span class="keyword">return</span> outputs</span><br></pre></td></tr></table></figure><h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><p>构建所需的数据。 这里的x_data和y_data并不是严格的一元二次函数的关系，因为我们多加了一个noise,这样看起来会更像真实情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x_data = np.linspace(<span class="number">-1</span>,<span class="number">1</span>,<span class="number">300</span>, dtype=np.float32)[:, np.newaxis]</span><br><span class="line">noise = np.random.normal(<span class="number">0</span>, <span class="number">0.05</span>, x_data.shape).astype(np.float32)</span><br><span class="line">y_data = np.square(x_data) - <span class="number">0.5</span> + noise</span><br></pre></td></tr></table></figure><p>利用占位符定义我们所需的神经网络的输入。 tf.placeholder()就是代表占位符，这里的None代表无论输入有多少都可以，因为输入只有一个特征，所以这里是1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xs = tf.placeholder(tf.float32, [<span class="keyword">None</span>, <span class="number">1</span>])</span><br><span class="line">ys = tf.placeholder(tf.float32, [<span class="keyword">None</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>接下来，我们就可以开始定义神经层了。 通常神经层都包括输入层、隐藏层和输出层。这里的输入层只有一个属性， 所以我们就只有一个输入；隐藏层我们可以自己假设，这里我们假设隐藏层有10个神经元； 输出层和输入层的结构是一样的，所以我们的输出层也是只有一层。 所以，我们构建的是——输入层1个、隐藏层10个、输出层1个的神经网络。</p><h3 id="搭建网络"><a href="#搭建网络" class="headerlink" title="搭建网络"></a>搭建网络</h3><p>利用之前的add_layer()函数，这里使用 Tensorflow 自带的激励函数tf.nn.relu。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l1 = add_layer(xs, <span class="number">1</span>, <span class="number">10</span>, activation_function=tf.nn.relu)</span><br></pre></td></tr></table></figure><p>接着，定义输出层。此时的输入就是隐藏层的输出——l1，输入有10层（隐藏层的输出层），输出有1层。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prediction = add_layer(l1, <span class="number">10</span>, <span class="number">1</span>, activation_function=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p>计算预测值prediction和真实值的误差，对二者差的平方求和再取平均。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loss = tf.reduce_mean(tf.reduce_sum(tf.square(ys - prediction),</span><br><span class="line">                     reduction_indices=[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><p>接下来，是很关键的一步，如何让机器学习提升它的准确率。tf.train.GradientDescentOptimizer()中的值通常都小于1，这里取的是0.1，代表以0.1的效率来最小化误差loss。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_step = tf.train.GradientDescentOptimizer(<span class="number">0.1</span>).minimize(loss)</span><br></pre></td></tr></table></figure><p>使用变量时，都要对它进行初始化，这是必不可少的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># init = tf.initialize_all_variables() # tf 马上就要废弃这种写法</span></span><br><span class="line">init = tf.global_variables_initializer()  <span class="comment"># 替换成这样就好</span></span><br></pre></td></tr></table></figure><p>定义Session，并用 Session 来执行 init 初始化步骤。 （注意：在tensorflow中，只有session.run()才会执行我们定义的运算。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(init)</span><br></pre></td></tr></table></figure><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>机器学习的内容是train_step, 用 Session 来 run 每一次 training 的数据，逐步提升神经网络的预测准确性。 (注意：当运算要用到placeholder时，就需要feed_dict这个字典来指定输入。)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    <span class="comment"># training</span></span><br><span class="line">    sess.run(train_step, feed_dict=&#123;xs: x_data, ys: y_data&#125;)</span><br></pre></td></tr></table></figure><p>每50步我们输出一下机器学习的误差。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># to see the step improvement</span></span><br><span class="line">    print(sess.run(loss, feed_dict=&#123;xs: x_data, ys: y_data&#125;))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.021204619</span></span><br><span class="line"><span class="number">0.009980676</span></span><br><span class="line"><span class="number">0.007174721</span></span><br><span class="line"><span class="number">0.006633012</span></span><br><span class="line"><span class="number">0.00622975</span></span><br><span class="line"><span class="number">0.005894037</span></span><br><span class="line"><span class="number">0.005621146</span></span><br><span class="line"><span class="number">0.0053801737</span></span><br><span class="line"><span class="number">0.00519997</span></span><br><span class="line"><span class="number">0.005050111</span></span><br><span class="line"><span class="number">0.004922069</span></span><br><span class="line"><span class="number">0.0048095705</span></span><br><span class="line"><span class="number">0.0047140927</span></span><br><span class="line"><span class="number">0.0046234317</span></span><br><span class="line"><span class="number">0.0045334958</span></span><br><span class="line"><span class="number">0.0044504963</span></span><br><span class="line"><span class="number">0.004378309</span></span><br><span class="line"><span class="number">0.0043256846</span></span><br><span class="line"><span class="number">0.0042802156</span></span><br><span class="line"><span class="number">0.0042369063</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 深度学习 </category>
          
          <category> TF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> TF </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>实验室GPU服务器部署教程</title>
      <link href="/2018/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4GPU%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/"/>
      <content type="html"><![CDATA[<h1 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a><a href="https://docs.docker.com/install/linux/ubuntu/" target="_blank" rel="noopener">Docker</a> 安装</h1><p>参考：<a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/#set-up-the-repository" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/ubuntu/#set-up-the-repository</a></p><ol><li><p>Prerequisites</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">To install Docker CE, you need the 64-bit version of one of these Ubuntu versions:</span><br><span class="line"></span><br><span class="line">Artful 17.10 (Docker CE 17.11 Edge and higher only)</span><br><span class="line">Xenial 16.04 (LTS)</span><br><span class="line">Trusty 14.04 (LTS)</span><br></pre></td></tr></table></figure></li><li><p>Uninstall old versions</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io</span><br></pre></td></tr></table></figure></li><li><p>Install Docker CE</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"><span class="comment"># Install packages to allow apt to use a repository over HTTPS</span></span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br><span class="line"><span class="comment"># Add Docker’s official GPG key:</span></span><br><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">$ sudo apt-key fingerprint 0EBFCD88</span><br><span class="line"><span class="comment"># Use the following command to set up the stable repository.</span></span><br><span class="line">$ sudo add-apt-repository \</span><br><span class="line">   <span class="string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">   <span class="variable">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">   stable"</span></span><br><span class="line">$ sudo apt-get update</span><br><span class="line"><span class="comment"># Install the latest version of Docker CE</span></span><br><span class="line">$ sudo apt-get install docker-ce</span><br><span class="line"><span class="comment"># Verify that Docker CE is installed correctly by running the hello-world image.</span></span><br><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>UPGRADE DOCKER CE</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>Uninstall Docker CE</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get purge docker-ce</span><br><span class="line">$ sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure></li></ol><h1 id="Docker-备份、恢复和迁移"><a href="#Docker-备份、恢复和迁移" class="headerlink" title="Docker 备份、恢复和迁移"></a>Docker 备份、恢复和迁移</h1><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>首先，为了备份Docker中的容器，我们会想看看我们想要备份的容器列表。要达成该目的，我们需要在我们运行着Docker引擎，并已创建了容器的Linux机器中运行 docker ps 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker ps</span></span><br></pre></td></tr></table></figure><p>在此之后，我们要选择我们想要备份的容器，然后去创建该容器的快照。我们可以使用 docker commit 命令来创建快照。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker commit -p 30b8f18f20b4 container-backup</span></span><br></pre></td></tr></table></figure><p>该命令会生成一个作为Docker镜像的容器快照，我们可以通过运行 docker images 命令来查看Docker镜像，如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker images</span></span><br></pre></td></tr></table></figure><p>正如我们所看见的，上面做的快照已经作为Docker镜像保存了。现在，为了备份该快照，我们有两个选择，一个是我们可以登录进Docker注册中心，并推送该镜像；另一个是我们可以将Docker镜像打包成tar包备份，以供今后使用。</p><p>如果我们想要在<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker注册中心</a>上传或备份镜像，我们只需要运行 docker login 命令来登录进Docker注册中心，然后推送所需的镜像即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker login</span></span><br><span class="line"><span class="comment"># docker tag a25ddfec4d2a arunpyasi/container-backup:test</span></span><br><span class="line"><span class="comment"># docker push arunpyasi/container-backup</span></span><br></pre></td></tr></table></figure><p>如果我们不想备份到docker注册中心，而是想要将此镜像保存在本地机器中，以供日后使用，那么我们可以将其作为tar包备份。要完成该操作，我们需要运行以下 docker save 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker save -o ~/container-backup.tar container-backup</span></span><br></pre></td></tr></table></figure><p>要验证tar包是否已经生成，我们只需要在保存tar包的目录中运行 ls 命令即可。</p><h2 id="恢复容器"><a href="#恢复容器" class="headerlink" title="恢复容器"></a>恢复容器</h2><p>接下来，在我们成功备份了我们的Docker容器后，我们现在来恢复这些制作了Docker镜像快照的容器。如果我们已经在注册中心推送了这些Docker镜像，那么我们仅仅需要把那个Docker镜像拖回并直接运行即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker pull arunpyasi/container-backup:test</span></span><br></pre></td></tr></table></figure><p>但是，如果我们将这些Docker镜像作为tar包文件备份到了本地，那么我们只要使用 docker load 命令，后面加上tar包的备份路径，就可以加载该Docker镜像了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker load -i ~/container-backup.tar</span></span><br></pre></td></tr></table></figure><p>现在，为了确保这些Docker镜像已经加载成功，我们来运行 docker images 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker images</span></span><br></pre></td></tr></table></figure><p>在镜像被加载后，我们将用加载的镜像去运行Docker容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker run -d -p 80:80 container-backup</span></span><br></pre></td></tr></table></figure><h2 id="迁移Docker容器"><a href="#迁移Docker容器" class="headerlink" title="迁移Docker容器"></a>迁移Docker容器</h2><p>迁移容器同时涉及到了上面两个操作，备份和恢复。我们可以将任何一个Docker容器从一台机器迁移到另一台机器。在迁移过程中，首先我们将把容器备份为Docker镜像快照。然后，该Docker镜像或者是被推送到了Docker注册中心，或者被作为tar包文件保存到了本地。如果我们将镜像推送到了Docker注册中心，我们简单地从任何我们想要的机器上使用 docker run 命令来恢复并运行该容器。但是，如果我们将镜像打包成tar包备份到了本地，我们只需要拷贝或移动该镜像到我们想要的机器上，加载该镜像并运行需要的容器即可。</p><h1 id="Docker-SSH-访问"><a href="#Docker-SSH-访问" class="headerlink" title="Docker SSH 访问"></a>Docker SSH 访问</h1><p>假设我们已经pull了一个docker 镜像，如下图所示的tensorflow/tensorflow。</p><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --name my-tensorflow -it -p 8888:8888 -v ~/tensorflow:/<span class="built_in">test</span>/data tensorflow/tensorflow</span><br><span class="line"><span class="comment"># --name：创建的容器名，即my-tensorflow</span></span><br><span class="line"><span class="comment"># -it：保留命令行运行</span></span><br><span class="line"><span class="comment"># p 8888:8888：将本地的8888端口和http://localhost:8888/映射</span></span><br><span class="line"><span class="comment"># -v ~/tensorflow:/test/data:将本地的~/tensorflow挂载到容器内的/# test/data下</span></span><br><span class="line"><span class="comment"># tensorflow/tensorflow ：默认是tensorflow/tensorflow:latest,指定使用的镜像</span></span><br></pre></td></tr></table></figure></code></pre><p>如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name tf tensorflow/tensorflow /bin/bash</span><br><span class="line"><span class="comment"># 这样我们就创建了名为tf的容器</span></span><br><span class="line">docker start tf</span><br><span class="line">docker attach tf</span><br></pre></td></tr></table></figure><h2 id="修改容器的root密码"><a href="#修改容器的root密码" class="headerlink" title="修改容器的root密码"></a>修改容器的root密码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-get install vim -y</span><br><span class="line">apt-get install openssh-server -y</span><br><span class="line">apt-get install passwd</span><br><span class="line">passwd root</span><br></pre></td></tr></table></figure><h2 id="修改ssh配置"><a href="#修改ssh配置" class="headerlink" title="修改ssh配置"></a>修改ssh配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line"><span class="comment"># 修改PermitRootLogin yes  </span></span><br><span class="line">UsePAM no</span><br></pre></td></tr></table></figure><h2 id="启动ssh服务"><a href="#启动ssh服务" class="headerlink" title="启动ssh服务"></a>启动ssh服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service ssh start</span><br></pre></td></tr></table></figure><h2 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h2 id="提交容器成为新的镜像"><a href="#提交容器成为新的镜像" class="headerlink" title="提交容器成为新的镜像"></a>提交容器成为新的镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如叫做ubuntu-ssh，输入docker commit 容器ID ubuntu-ssh</span><br></pre></td></tr></table></figure><h2 id="启动这个镜像的容器，并映射本地的一个闲置的端口"><a href="#启动这个镜像的容器，并映射本地的一个闲置的端口" class="headerlink" title="启动这个镜像的容器，并映射本地的一个闲置的端口"></a>启动这个镜像的容器，并映射本地的一个闲置的端口</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p 50001:22 tf-ssh /bin/bash</span><br></pre></td></tr></table></figure><h2 id="ssh登录"><a href="#ssh登录" class="headerlink" title="ssh登录"></a>ssh登录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@127.0.0.1 -p 50001</span><br></pre></td></tr></table></figure><h2 id="Docker后台运行"><a href="#Docker后台运行" class="headerlink" title="Docker后台运行"></a>Docker后台运行</h2><h1 id="阿里云加速器设置"><a href="#阿里云加速器设置" class="headerlink" title="阿里云加速器设置"></a>阿里云加速器设置</h1><p>由于官方Docker Hub网络速度较慢，这里使用阿里云提供的<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>. 需要配置阿里云加速器，官方说明如下：</p><ol><li><p>针对Docker客户端版本大于1.10的用户： </p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 您可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器</span></span><br><span class="line">$ sudo mkdir -p /etc/docker</span><br><span class="line">$ sudo tee /etc/docker/daemon.json &lt;&lt;-‘EOF’ </span><br><span class="line">  &#123; </span><br><span class="line">  “registry-mirrors”: [“https://fird1mfg.mirror.aliyuncs.com“] </span><br><span class="line">  &#125; </span><br><span class="line">  EOF</span><br><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>针对Docker客户的版本小于等于1.10的用户或者想配置启动参数，可以使用下面的命令将配置添加到docker daemon的启动参数中.</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 12.04 14.04的用户:</span></span><br><span class="line">$ <span class="built_in">echo</span> “DOCKER_OPTS=/”<span class="variable">$DOCKER_OPTS</span> –registry-mirror=https://fird1mfg.mirror.aliyuncs.com/”” | sudo tee -a /etc/default/docker</span><br><span class="line">$ sudo service docker restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ubuntu 15.04 16.04的用户</span></span><br><span class="line">$ sudo mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line">$ sudo tee /etc/systemd/system/docker.service.d/mirror.conf &lt;&lt;-‘EOF’ </span><br><span class="line">[Service] </span><br><span class="line">ExecStart=/usr/bin/docker daemon -H fd:// –registry-mirror=https://fird1mfg.mirror.aliyuncs.com </span><br><span class="line">EOF</span><br><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure></li></ol><h1 id="NVIDIA-Docker安装"><a href="#NVIDIA-Docker安装" class="headerlink" title="NVIDIA-Docker安装"></a><a href="https://github.com/NVIDIA/nvidia-docker/wiki" target="_blank" rel="noopener">NVIDIA-Docker</a>安装</h1><ol><li><p>Prerequisties</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GNU/Linux x86_64 with kernel version &gt; 3.10 </span><br><span class="line">Docker &gt;= 1.9 (official docker-engine, docker-ce or docker-ee only) </span><br><span class="line">NVIDIA GPU with Architecture &gt; Fermi (2.1) </span><br><span class="line">NVIDIA drivers &gt;= 340.29 with binary nvidia-modprobe (驱动版本与CUDA计算能力相关)</span><br></pre></td></tr></table></figure></li><li><p>CUDA与NVIDIA driver安装 <a href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="noopener">cuda</a></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">处理NVIDIA-Docker依赖项 NVIDIA drivers &gt;= 340.29 with binary nvidia-modprobe 要求. </span><br><span class="line">根据显卡，下载对应版本的CUDA并进行安装.</span><br></pre></td></tr></table></figure></li><li><p>NVIDIA-Docker安装</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Install nvidia-docker and nvidia-docker-plugin</span></span><br><span class="line"></span><br><span class="line">wget -P /tmp https://github.com/NVIDIA/nvidia-docker/releases/download/v1.0.1/nvidia-docker_1.0.1-1_amd64.deb</span><br><span class="line">sudo dpkg -i /tmp/nvidia-docker*.deb &amp;&amp; rm /tmp/nvidia-docker*.deb</span><br><span class="line"><span class="comment">#Test nvidia-smi</span></span><br><span class="line"></span><br><span class="line">sudo nvidia-docker run –rm nvidia/cuda nvidia-smi</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>默认用nvdia-docker替代docker命令：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'alias docker=nvidia-docker'</span> &gt;&gt; ~/.bashrc</span><br><span class="line">bash</span><br></pre></td></tr></table></figure></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://jingyan.baidu.com/article/a3aad71aa180e7b1fa009676.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/a3aad71aa180e7b1fa009676.html</a></li><li><a href="https://github.com/ufoym/deepo#Installation" target="_blank" rel="noopener">https://github.com/ufoym/deepo#Installation</a></li><li><a href="https://hub.docker.com/r/ufoym/deepo/" target="_blank" rel="noopener">https://hub.docker.com/r/ufoym/deepo/</a></li><li><a href="https://github.com/fatedier/frp/blob/master/README_zh.md#frp-%E7%9A%84%E4%BD%9C%E7%94%A8" target="_blank" rel="noopener">https://github.com/fatedier/frp/blob/master/README_zh.md#frp-%E7%9A%84%E4%BD%9C%E7%94%A8</a></li><li><a href="https://ranpox.github.io/2018/01/14/notification-of-gpu-server/" target="_blank" rel="noopener">https://ranpox.github.io/2018/01/14/notification-of-gpu-server/</a></li></ol>]]></content>
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 深度学习 </category>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python多线程教程</title>
      <link href="/2018/03/26/python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%95%99%E7%A8%8B/"/>
      <content type="html"><![CDATA[<h1 id="什么多线程"><a href="#什么多线程" class="headerlink" title="什么多线程"></a>什么多线程</h1><p>多线程是加速程序计算的有效方式</p><h2 id="添加线程-Thread"><a href="#添加线程-Thread" class="headerlink" title="添加线程 Thread"></a>添加线程 Thread</h2><ul><li>导入模块</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br></pre></td></tr></table></figure><ul><li>获取已激活的线程数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threading.active_count()</span><br></pre></td></tr></table></figure><ul><li>查看所有线程信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threading.enumerate()</span><br></pre></td></tr></table></figure><ul><li>查看现在正在运行的线程</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threading.current_thread()</span><br></pre></td></tr></table></figure><ul><li>添加线程</li></ul><p>threading.Thread()接收参数target代表这个线程要完成的任务，需自行定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_job</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'This is a thread of %s'</span> % threading.current_thread())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    thread = threading.Thread(target=thread_job,)   <span class="comment"># 定义线程 </span></span><br><span class="line">    thread.start()  <span class="comment"># 让线程开始工作</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="join-功能"><a href="#join-功能" class="headerlink" title="join 功能"></a>join 功能</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_job</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"T1 start\n"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(<span class="number">0.1</span>) <span class="comment"># 任务间隔0.1s</span></span><br><span class="line">    print(<span class="string">"T1 finish\n"</span>)</span><br><span class="line"></span><br><span class="line">added_thread = threading.Thread(target=thread_job, name=<span class="string">'T1'</span>)</span><br><span class="line">added_thread.start()</span><br><span class="line">print(<span class="string">"all done\n"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">thread_1.start() <span class="comment"># start T1</span></span><br><span class="line">thread_2.start() <span class="comment"># start T2</span></span><br><span class="line">thread_2.join() <span class="comment"># join for T2</span></span><br><span class="line">thread_1.join() <span class="comment"># join for T1</span></span><br><span class="line">print(<span class="string">"all done\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">T1 start</span></span><br><span class="line"><span class="string">T2 start</span></span><br><span class="line"><span class="string">T2 finish</span></span><br><span class="line"><span class="string">T1 finish</span></span><br><span class="line"><span class="string">all done</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h2 id="储存进程结果-Queue"><a href="#储存进程结果-Queue" class="headerlink" title="储存进程结果 Queue"></a>储存进程结果 Queue</h2><ul><li>导入线程,队列的标准模块</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br></pre></td></tr></table></figure><ul><li>定义一个被多线程调用的函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job</span><span class="params">(l,q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range (len(l)):</span><br><span class="line">        l[i] = l[i]**<span class="number">2</span></span><br><span class="line">    q.put(l)   <span class="comment">#多线程调用的函数不能用return返回值</span></span><br></pre></td></tr></table></figure><p>完整的代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job</span><span class="params">(l,q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range (len(l)):</span><br><span class="line">        l[i] = l[i]**<span class="number">2</span></span><br><span class="line">    q.put(l)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multithreading</span><span class="params">()</span>:</span></span><br><span class="line">    q =Queue()</span><br><span class="line">    threads = []</span><br><span class="line">    data = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        t = threading.Thread(target=job,args=(data[i],q))</span><br><span class="line">        t.start()</span><br><span class="line">        threads.append(t)</span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.join()</span><br><span class="line">    results = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        results.append(q.get())</span><br><span class="line">    print(results)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name___==<span class="string">'__main__'</span>:</span><br><span class="line">    multithreading()</span><br></pre></td></tr></table></figure><h2 id="线程锁-Lock"><a href="#线程锁-Lock" class="headerlink" title="线程锁 Lock"></a>线程锁 Lock</h2><ul><li>不使用 Lock 的情况</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> A</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        A+=<span class="number">1</span></span><br><span class="line">        print(<span class="string">'job1'</span>,A)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> A</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        A+=<span class="number">10</span></span><br><span class="line">        print(<span class="string">'job2'</span>,A)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__== <span class="string">'__main__'</span>:</span><br><span class="line">    lock=threading.Lock()</span><br><span class="line">    A=<span class="number">0</span></span><br><span class="line">    t1=threading.Thread(target=job1)</span><br><span class="line">    t2=threading.Thread(target=job2)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">job1job2 <span class="number">11</span></span><br><span class="line">job2 <span class="number">21</span></span><br><span class="line">job2 <span class="number">31</span></span><br><span class="line">job2 <span class="number">41</span></span><br><span class="line">job2 <span class="number">51</span></span><br><span class="line">job2 <span class="number">61</span></span><br><span class="line">job2 <span class="number">71</span></span><br><span class="line">job2 <span class="number">81</span></span><br><span class="line">job2 <span class="number">91</span></span><br><span class="line">job2 <span class="number">101</span></span><br><span class="line"> <span class="number">1</span></span><br><span class="line">job1 <span class="number">102</span></span><br><span class="line">job1 <span class="number">103</span></span><br><span class="line">job1 <span class="number">104</span></span><br><span class="line">job1 <span class="number">105</span></span><br><span class="line">job1 <span class="number">106</span></span><br><span class="line">job1 <span class="number">107</span></span><br><span class="line">job1 <span class="number">108</span></span><br><span class="line">job1 <span class="number">109</span></span><br><span class="line">job1 <span class="number">110</span></span><br></pre></td></tr></table></figure><ul><li>使用 Lock 的情况</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> A,lock</span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        A+=<span class="number">1</span></span><br><span class="line">        print(<span class="string">'job1'</span>,A)</span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> A,lock</span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        A+=<span class="number">10</span></span><br><span class="line">        print(<span class="string">'job2'</span>,A)</span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__== <span class="string">'__main__'</span>:</span><br><span class="line">    lock=threading.Lock()</span><br><span class="line">    A=<span class="number">0</span></span><br><span class="line">    t1=threading.Thread(target=job1)</span><br><span class="line">    t2=threading.Thread(target=job2)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">job1 <span class="number">1</span></span><br><span class="line">job1 <span class="number">2</span></span><br><span class="line">job1 <span class="number">3</span></span><br><span class="line">job1 <span class="number">4</span></span><br><span class="line">job1 <span class="number">5</span></span><br><span class="line">job1 <span class="number">6</span></span><br><span class="line">job1 <span class="number">7</span></span><br><span class="line">job1 <span class="number">8</span></span><br><span class="line">job1 <span class="number">9</span></span><br><span class="line">job1 <span class="number">10</span></span><br><span class="line">job2 <span class="number">20</span></span><br><span class="line">job2 <span class="number">30</span></span><br><span class="line">job2 <span class="number">40</span></span><br><span class="line">job2 <span class="number">50</span></span><br><span class="line">job2 <span class="number">60</span></span><br><span class="line">job2 <span class="number">70</span></span><br><span class="line">job2 <span class="number">80</span></span><br><span class="line">job2 <span class="number">90</span></span><br><span class="line">job2 <span class="number">100</span></span><br><span class="line">job2 <span class="number">110</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://morvanzhou.github.io/tutorials/python-basic/threading/" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/python-basic/threading/</a></li></ul>]]></content>
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>semantic_mapping_论文阅读</title>
      <link href="/2018/03/26/semantic-mapping-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
      <content type="html"><![CDATA[<h1 id="Semantic-Mapping-文献综述"><a href="#Semantic-Mapping-文献综述" class="headerlink" title="Semantic Mapping 文献综述"></a>Semantic Mapping 文献综述</h1><blockquote><p>1，CNN-SLAM为今年CVPR的文章，是比较完整的pipeline，将LSD-SLAM里的深度估计和图像匹配都替换成基于CNN的方法，取得了更为robust的结果，并可以融合语义信息。见<a href="http://campar.in.tum.de/Chair/ProjectCNNSLAM" target="_blank" rel="noopener">ProjectCNNSLAM</a>.类似的工作还有UnDeepVO: Monocular Visual Odometry through Unsupervised Deep Learning。 问题在于准确度非常低。做过benchmark，基于单帧彩色照片进行距离信息预测，在室内每个像素的平均误差约50cm，在室外平均误差则高达７米以上。一篇投ICRA的工作结合少量的距离信息和彩色信息进行距离图像预测，效果比单纯用彩色照片准确得多且鲁棒性强。这个方法可以帮助传统SLAM从稀疏点云快速生成密集的点云，也可以用在激光雷达的超分辨率上。代码已开源<a href="https://github.com/fangchangma/sparse-to-dense" target="_blank" rel="noopener">sparse-to-dense</a>,论文：Sparse-to-Dense: Depth Prediction from Sparse Depth Samples and a Single Image <br><br></p><ol><li>VINet是AAAI2017的文章，利用CNN和RNN构建了一个VIO，即输入image和IMU信息，直接输出估计的pose。 <br><br></li><li>Unsupervised learning of depth and ego-motion from video是Google CVPR 2017的oral文章，利用CNN学习一个无监督的深度估计和pose估计网络，代码见<a href="https://github.com/tinghuiz/SfMLearner.git" target="_blank" rel="noopener">SfMLearner</a>.SfM-Net利用监督学习也干了类似的工作。 <br><br></li><li>重定位PoseNet和Delving deeper into convolutional neural networks for camera relocalization <br></li><li>语义地图 Semi-Dense 3D Semantic Mapping from Monocular SLAM <br><br></li><li>哪怕在传统基于特征点的SLAM已经能做到非常稳定高效的这个情况下，适合结合deep learning的科研方向还是有很多的。这其中包括 <br><blockquote><ul><li>提高特征点稳定性（减少outlier）和自动提取不同层级的特征点（点、线、面、物体）， <br></li><li>快速生成密集的地图（而非稀疏的三维点云） <br></li><li>结合语义信息和图像分割 <br></li><li>生成动态地图（可以实时更新、表达动态物体） <br></li><li>降低SLAM调参的难度 <br></li></ul></blockquote></li></ol></blockquote><blockquote><p>7.跳出SLAM，说点题外话，利用深度强化学习来进行端对端的机器人导航，已经有了不错的结果。人类在环境中导航，不也是直接输入image，输出action吗？有兴趣的可以看看这两篇文章：<a href="https://arxiv.org/abs/1702.03920" target="_blank" rel="noopener">Cognitive Mapping and Planning for Visual Navigation</a>和<a href="https://arxiv.org/abs/1609.05143" target="_blank" rel="noopener">Target-driven Visual Navigation in Indoor Scenes using Deep Reinforcement Learning</a>。navigation 是更适合 DL 的一个场景。人在移动的时候，并不会建立精确的环境地图，无法具体说出障碍物距离自己多少厘米。所以，我一直有一个直觉：「navigation 应该不需要精确地图信息与定位信息」，而 DL 似乎有可能实现这一全新的方法。 navigation 是更适合 DL 的一个场景。人在移动的时候，并不会建立精确的环境地图，无法具体说出障碍物距离自己多少厘米。所以，一直有一个直觉：「navigation 应该不需要精确地图信息与定位信息」，而 DL 似乎有可能实现这一全新的方法。但是，目前所有这些工作都存在一个问题：只是训练出一个 local planner，无法实现全局的路径规划。 <br><br></p><ol><li>语义分割和SLAM的结合还很粗糙.最简单的方式，就是跑一个pixel-wise的图像语义分割，再跑一个dense或者semi-dense的SLAM，把前者的结果map到后者的地图上去，每个像素（或者surfel）上做recursive Bayesian update，其实也就是概率累乘。参见Andrew Davison组的SemanticFusion (ICRA’17)，代码已开源。国内学者也有类似的工作，用LSD-SLAM + DeepLab v2，这个是单目的（SemanticFusion是RGB-D）,即<a href="https://arxiv.org/abs/1611.04144" target="_blank" rel="noopener">Semi-Dense 3D Semantic Mapping from Monocular SLAM</a>。这种结合方式，按某些学者的意见都不能称为semantic SLAM，只能叫semantic mapping，因为localization部分跟semantics没关系嘛。 <br><br></li><li>真正的semantic SLAM，语义信息是要能够帮助定位的，比如这篇：<a href="https://pdfs.semanticscholar.org/ef4c/ffbbca79df1c1ca7891345f898812289b6cb.pdf" target="_blank" rel="noopener">Probabilistic Data Association for Semantic SLAM</a>(ICRA’17)。用object detection的结果作为SLAM前端的输入，跟ORB之类的特征互补提高定位鲁棒性。优点很明显，这下SLAM不会因为你把床收拾了一下就啥都不认识了（视觉特征都变了，但床还是床）。难点是detection结果的data association最好能跟定位联合优化，但前者是个离散问题。这篇文章用EM算法，E步考虑所有可能的association，比较粗暴，但识别物体较少的时候还不错（论文实验里只识别椅子）。上面这篇文章没有语义分割。。。map里只有稀稀拉拉的几个物体（位置和类别）。 <br><br></li><li>另外，SLAM也能提升语义理解水平。前面提到的SemanticFusion和类似的工作里，融合了多个视角语义理解结果的3D地图，其中的语义标签准确率高于单帧图像得到的结果，这很容易理解。另外，通过在3D空间引入一些先验信息，比如用CRF对地图做一下diffusion，能进一步提升准确率。但CRF毕竟还是简单粗暴，如果设计更精细的滤波算法，尤其是能从真实数据中学习一些先验的话，应该效果还会更好。这方面的工作还没有。 <br><br></li><li>再提一个，融合优化之后的结果如果反馈给图像语义理解算法做一下fine-tuning，那就是self-supervised learning了。这方面的工作也还没有。 <br><br></li><li>接下来是语义地图怎么用的问题。对上层应用有价值的语义地图，应该包含一个个物体及其模型，而不仅是一堆标记了类别的voxel。一个比较好的例子来自IROS’17：<a href="https://arxiv.org/abs/1609.07849" target="_blank" rel="noopener">Meaningful Maps With Object-Oriented Semantic Mapping</a>不过这篇文章里的语义信息来自SSD和非神经网络的分割，还没有用端到端的语义分割网络。 <br><br></li><li>另外，针对动态场景，怎样处理物体移位，怎样区别长效地图和短效地图，怎么“脑补”同类物体，这里面一堆问题可以研究。更别说地图构建出来之后如何做体现空间智能的自然语言交互和任务规划，如何reasoning了，这方面研究目前连影子都没有。 <br><br></li><li>一篇很好的综述，里面也有很多关于语义SLAM的介绍：<a href="https://arxiv.org/abs/1606.05830" target="_blank" rel="noopener">Past, Present, and Future of Simultaneous Localization And Mapping: Towards the Robust-Perception Age</a> <br><br></li><li>语义slam开源：<br></li></ol><ul><li><a href="https://github.com/yuxng/DA-RNN" target="_blank" rel="noopener">DA-RNN_Semantic Mapping with Data Associated</a><br></li><li><a href="https://bitbucket.org/dysonroboticslab/semanticfusion" target="_blank" rel="noopener">SemanticFusion</a><br></li><li><a href="https://github.com/shichaoy/pop_up_image" target="_blank" rel="noopener">Pop-up SLAM: Semantic Monocular Plane SLAM</a>.场景理解用于改善状态估计，尤其是在低纹理区域，是目前极少的开源语义SLAM方案之一<br></li></ul></blockquote><p>参考：</p><ol><li><a href="https://www.zhihu.com/question/66006923/answer/241333356" target="_blank" rel="noopener">当前深度学习和slam结合有哪些比较好的论文，有没有一些开源的代码?</a></li><li><a href="https://www.zhihu.com/question/264578623/answer/283163990" target="_blank" rel="noopener">当前语义分割帮助视觉SLAM提高定位准确度，建立语义地图的研究现状如何？</a></li></ol><h2 id="研读论文一：CNN-SLAM-Real-time-dense-monocular-SLAM-with-learned-depth-prediction"><a href="#研读论文一：CNN-SLAM-Real-time-dense-monocular-SLAM-with-learned-depth-prediction" class="headerlink" title="研读论文一：CNN-SLAM: Real-time dense monocular SLAM with learned depth prediction"></a>研读论文一：CNN-SLAM: Real-time dense monocular SLAM with learned depth prediction</h2><blockquote><p>Tateno, K., Tombari, F., Laina, I., &amp; Navab, N. (2017). CNN-SLAM: Real-time dense monocular SLAM with learned depth prediction. arXiv preprint arXiv:1704.03489.<br>CVPR 2017</p></blockquote><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ol><li>本文提出了一种基于深度神经网络方法能够从单目图像中预测深度信息，用途可为弹幕图像的重建。尤其是对于纯单目重建是小的区域，如纹理不丰富的区域，效果较好。此外，相比较于单目SLAM，该深度SLAM还可提供scale。此外，该方法还融合了语义标记，来重建语义信息的场景。</li><li>传统的基于深度摄像头的SLAM有如下缺点：</li></ol><ul><li>有效工作距离较短</li><li>太阳光的影响等</li><li>普适性</li></ul><ol><li>双目摄像头缺点：特征丰富程度敏感</li><li>鉴于卷积神经网络（CNN）深度预测的最新进展，本文研究了深度神经网络的预测深度图，可以部署用于精确和密集的单目重建。我们提出了一种方法，其中CNN预测的稠密深度图与通过直接单目SLAM获得的深度测量自然地融合在一起。我们的融合方案在图像定位中优于单目SLAM方法，例如沿低纹理区域，反之亦然。我们展示了使用深度预测来估计重建的绝对尺度，从而克服了单眼SLAM的主要局限性之一。最后，我们提出一个框架，从单个帧获得的语义标签有效地融合了密集的SLAM，从单个视图产生语义相干的场景重构。两个基准数据集的评估结果显示了我们的方法的鲁棒性和准确性</li></ol>]]></content>
      
      <categories>
          
          <category> 学术 </category>
          
          <category> 论文阅读 </category>
          
          <category> Semantic Mapping </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学术 </tag>
            
            <tag> 论文阅读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>numpy和pandas教程</title>
      <link href="/2018/03/26/numpy%E5%92%8Cpandas%E6%95%99%E7%A8%8B/"/>
      <content type="html"><![CDATA[<h1 id="安装-numpy和pandas"><a href="#安装-numpy和pandas" class="headerlink" title="安装 numpy和pandas"></a>安装 numpy和pandas</h1><p><a href="http://www.numpy.org/" target="_blank" rel="noopener">numpy</a> 和 <a href="https://pandas.pydata.org/" target="_blank" rel="noopener">pandas</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install numpy</span><br><span class="line">sudo pip install pandas</span><br></pre></td></tr></table></figure><h1 id="Numpy教程"><a href="#Numpy教程" class="headerlink" title="Numpy教程"></a>Numpy教程</h1><h2 id="Numpy-属性"><a href="#Numpy-属性" class="headerlink" title="Numpy 属性"></a>Numpy 属性</h2><ul><li>ndim：维度</li><li>shape：行数和列数</li><li>size：元素个数</li></ul><h2 id="Numpy-的创建-array"><a href="#Numpy-的创建-array" class="headerlink" title="Numpy 的创建 array"></a>Numpy 的创建 array</h2><ul><li>array：创建数组</li><li>dtype：指定数据类型</li><li>zeros：创建数据全为0</li><li>ones：创建数据全为1</li><li>empty：创建数据接近0</li><li>arrange：按指定范围创建数据</li><li>linspace：创建线段</li></ul><h2 id="Numpy-基础运算"><a href="#Numpy-基础运算" class="headerlink" title="Numpy 基础运算"></a>Numpy 基础运算</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a=np.array([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>])   <span class="comment"># array([10, 20, 30, 40])</span></span><br><span class="line">b=np.arange(<span class="number">4</span>)              <span class="comment"># array([0, 1, 2, 3])</span></span><br></pre></td></tr></table></figure><ul><li>减法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c=a-b  <span class="comment"># array([10, 19, 28, 37])</span></span><br></pre></td></tr></table></figure><ul><li>加法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c=a+b   <span class="comment"># array([10, 21, 32, 43])</span></span><br></pre></td></tr></table></figure><ul><li>乘法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c=a*b   <span class="comment"># array([  0,  20,  60, 120])</span></span><br></pre></td></tr></table></figure><p>有所不同的是，在Numpy中，想要求出矩阵中各个元素的乘方需要依赖双星符号 **</p><ul><li>乘法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c=b**<span class="number">2</span>  <span class="comment"># array([0, 1, 4, 9])</span></span><br></pre></td></tr></table></figure><ul><li>三角函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c=<span class="number">10</span>*np.sin(a)  <span class="comment"># cos tan</span></span><br><span class="line"><span class="comment"># array([-5.44021111,  9.12945251, -9.88031624,  7.4511316 ])</span></span><br></pre></td></tr></table></figure><ul><li>逻辑判断</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(b&lt;<span class="number">3</span>)  </span><br><span class="line"><span class="comment"># array([ True,  True,  True, False], dtype=bool)</span></span><br></pre></td></tr></table></figure><p>上述运算均是建立在一维矩阵，即只有一行的矩阵上面的计算，如果我们想要对多行多维度的矩阵进行操作，需要对开始的脚本进行一些修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a=np.array([[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>]])</span><br><span class="line">b=np.arange(<span class="number">4</span>).reshape((<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># array([[1, 1],</span></span><br><span class="line"><span class="comment">#       [0, 1]])</span></span><br><span class="line"></span><br><span class="line">print(b)</span><br><span class="line"><span class="comment"># array([[0, 1],</span></span><br><span class="line"><span class="comment">#       [2, 3]])</span></span><br></pre></td></tr></table></figure><p>此时构造出来的矩阵a和b便是2行2列的，其中 reshape 操作是对矩阵的形状进行重构， 其重构的形状便是括号中给出的数字。</p><ul><li>矩阵乘法运算</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c_dot = np.dot(a,b)</span><br><span class="line"><span class="comment"># array([[2, 4],</span></span><br><span class="line"><span class="comment">#       [2, 3]])</span></span><br><span class="line">c_dot_2 = a.dot(b)</span><br><span class="line"><span class="comment"># array([[2, 4],</span></span><br><span class="line"><span class="comment">#       [2, 3]])</span></span><br></pre></td></tr></table></figure><ul><li>特定运算<ul><li>求和：np.sum(A)</li><li>最小值：np.min(A)</li><li>最大值：np.max(A)</li><li>最小值索引：np.argmin(A)</li><li>最大值索引：np.argmax(A)</li><li>平均值：np.mean(A)</li><li>中位数：np.medium(A)</li><li>累加：np.cumsum(A)</li><li>累差：np.diff(A)</li><li>非零数：np.nonzero(A)</li><li>排序：np.sort(A)</li><li>矩阵反向（转置）：np.transpose(A)或A.T</li><li>截断：np.clip(A,5,9) # 小于5为5，大于9为9</li></ul></li></ul><h2 id="Numpy-索引"><a href="#Numpy-索引" class="headerlink" title="Numpy 索引"></a>Numpy 索引</h2><h3 id="一维索引"><a href="#一维索引" class="headerlink" title="一维索引"></a>一维索引</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.arange(<span class="number">3</span>,<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># array([3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])</span></span><br><span class="line">         </span><br><span class="line">print(A[<span class="number">3</span>])    <span class="comment"># 6</span></span><br></pre></td></tr></table></figure><h3 id="二维索引"><a href="#二维索引" class="headerlink" title="二维索引"></a>二维索引</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(A[<span class="number">1</span>][<span class="number">1</span>])      <span class="comment"># 8</span></span><br></pre></td></tr></table></figure><p>这一脚本中的flatten是一个展开性质的函数，将多维的矩阵进行展开成1行的数列。而flat是一个迭代器，本身是一个object属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.arange(<span class="number">3</span>,<span class="number">15</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">         </span><br><span class="line">print(A.flatten())   </span><br><span class="line"><span class="comment"># array([3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> A.flat:</span><br><span class="line">    print(item)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line">……</span><br><span class="line"><span class="comment"># 14</span></span><br></pre></td></tr></table></figure><h2 id="Numpy-array-合并"><a href="#Numpy-array-合并" class="headerlink" title="Numpy array 合并"></a>Numpy array 合并</h2><ul><li>上下合并 - np.vstack()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line">B = np.array([<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>])</span><br><span class="line">         </span><br><span class="line">print(np.vstack((A,B)))    <span class="comment"># vertical stack</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[1,1,1]</span></span><br><span class="line"><span class="string"> [2,2,2]]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><ul><li>左右合并 - np.hstack()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">D = np.hstack((A,B))       <span class="comment"># horizontal stack</span></span><br><span class="line"></span><br><span class="line">print(D)</span><br><span class="line"><span class="comment"># [1,1,1,2,2,2]</span></span><br><span class="line"></span><br><span class="line">print(A.shape,D.shape)</span><br><span class="line"><span class="comment"># (3,) (6,)</span></span><br></pre></td></tr></table></figure><ul><li>转置操作 - np.newaxis()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">print(A[np.newaxis,:])</span><br><span class="line"><span class="comment"># [[1 1 1]]</span></span><br><span class="line"></span><br><span class="line">print(A[np.newaxis,:].shape)</span><br><span class="line"><span class="comment"># (1,3)</span></span><br><span class="line"></span><br><span class="line">print(A[:,np.newaxis])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[1]</span></span><br><span class="line"><span class="string">[1]</span></span><br><span class="line"><span class="string">[1]]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">print(A[:,np.newaxis].shape)</span><br><span class="line"><span class="comment"># (3,1)</span></span><br></pre></td></tr></table></figure><p>此时我们便将具有3个元素的array转换为了1行3列以及3行1列的矩阵了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])[:,np.newaxis]</span><br><span class="line">B = np.array([<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>])[:,np.newaxis]</span><br><span class="line">         </span><br><span class="line">C = np.vstack((A,B))   <span class="comment"># vertical stack</span></span><br><span class="line">D = np.hstack((A,B))   <span class="comment"># horizontal stack</span></span><br><span class="line"></span><br><span class="line">print(D)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[1 2]</span></span><br><span class="line"><span class="string">[1 2]</span></span><br><span class="line"><span class="string">[1 2]]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">print(A.shape,D.shape)</span><br><span class="line"><span class="comment"># (3,1) (3,2)</span></span><br></pre></td></tr></table></figure><ul><li>合并操作需要针对多个矩阵或序列 - np.concatenate()</li></ul><p>当你的合并操作需要针对多个矩阵或序列时，借助concatenate函数可能会让你使用起来比前述的函数更加方便：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">C = np.concatenate((A,B,B,A),axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">print(C)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[1],</span></span><br><span class="line"><span class="string">       [1],</span></span><br><span class="line"><span class="string">       [1],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [1],</span></span><br><span class="line"><span class="string">       [1],</span></span><br><span class="line"><span class="string">       [1]])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">D = np.concatenate((A,B,B,A),axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(D)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[1, 2, 2, 1],</span></span><br><span class="line"><span class="string">       [1, 2, 2, 1],</span></span><br><span class="line"><span class="string">       [1, 2, 2, 1]])</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>axis参数很好的控制了矩阵的纵向或是横向打印，相比较vstack和hstack函数显得更加方便。</p><h2 id="Numpy-array-分割"><a href="#Numpy-array-分割" class="headerlink" title="Numpy array 分割"></a>Numpy array 分割</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">print(A)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="string">    [ 4,  5,  6,  7],</span></span><br><span class="line"><span class="string">    [ 8,  9, 10, 11]])</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><ul><li>纵向分割</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(np.split(A, <span class="number">2</span>, axis=<span class="number">1</span>))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[array([[0, 1],</span></span><br><span class="line"><span class="string">        [4, 5],</span></span><br><span class="line"><span class="string">        [8, 9]]), array([[ 2,  3],</span></span><br><span class="line"><span class="string">        [ 6,  7],</span></span><br><span class="line"><span class="string">        [10, 11]])]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><ul><li>横向分割</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(np.split(A, <span class="number">3</span>, axis=<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># [array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8,  9, 10, 11]])]</span></span><br></pre></td></tr></table></figure><ul><li>错误的分割 </li></ul><p>范例的Array只有4列，只能等量对分，因此输入以上程序代码后Python就会报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(np.split(A, <span class="number">3</span>, axis=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ValueError: array split does not result in an equal division</span></span><br></pre></td></tr></table></figure><ul><li>不等量的分割</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">print(np.array_split(A, <span class="number">3</span>, axis=<span class="number">1</span>))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[array([[0, 1],</span></span><br><span class="line"><span class="string">        [4, 5],</span></span><br><span class="line"><span class="string">        [8, 9]]), array([[ 2],</span></span><br><span class="line"><span class="string">        [ 6],</span></span><br><span class="line"><span class="string">        [10]]), array([[ 3],</span></span><br><span class="line"><span class="string">        [ 7],</span></span><br><span class="line"><span class="string">        [11]])]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><ul><li>其他的分割方式</li></ul><p>在Numpy里还有np.vsplit()与横np.hsplit()方式可用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">print(np.vsplit(A, <span class="number">3</span>)) <span class="comment">#等于 print(np.split(A, 3, axis=0))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8,  9, 10, 11]])]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(np.hsplit(A, <span class="number">2</span>)) <span class="comment">#等于 print(np.split(A, 2, axis=1))</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[array([[0, 1],</span></span><br><span class="line"><span class="string">       [4, 5],</span></span><br><span class="line"><span class="string">       [8, 9]]), array([[ 2,  3],</span></span><br><span class="line"><span class="string">        [ 6,  7],</span></span><br><span class="line"><span class="string">        [10, 11]])]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h2 id="Numpy-copy-amp-deep-copy"><a href="#Numpy-copy-amp-deep-copy" class="headerlink" title="Numpy copy &amp; deep copy"></a>Numpy copy &amp; deep copy</h2><ul><li>copy() 的赋值方式没有关联性</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b = a.copy()    <span class="comment"># deep copy</span></span><br><span class="line">print(b)        <span class="comment"># array([11, 22, 33,  3])</span></span><br><span class="line">a[<span class="number">3</span>] = <span class="number">44</span></span><br><span class="line">print(a)        <span class="comment"># array([11, 22, 33, 44])</span></span><br><span class="line">print(b)        <span class="comment"># array([11, 22, 33,  3])</span></span><br></pre></td></tr></table></figure><h1 id="Pandas-教程"><a href="#Pandas-教程" class="headerlink" title="Pandas 教程"></a>Pandas 教程</h1><h2 id="Numpy-和-Pandas-有什么不同"><a href="#Numpy-和-Pandas-有什么不同" class="headerlink" title="Numpy 和 Pandas 有什么不同"></a>Numpy 和 Pandas 有什么不同</h2><p>如果用 python 的列表和字典来作比较, 那么可以说 Numpy 是列表形式的，没有数值标签，而 Pandas 就是字典形式。Pandas是基于Numpy构建的，让Numpy为中心的应用变得更加简单。</p><ul><li>Series</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">s = pd.Series([<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,np.nan,<span class="number">44</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">print(s)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">0     1.0</span></span><br><span class="line"><span class="string">1     3.0</span></span><br><span class="line"><span class="string">2     6.0</span></span><br><span class="line"><span class="string">3     NaN</span></span><br><span class="line"><span class="string">4    44.0</span></span><br><span class="line"><span class="string">5     1.0</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>Series的字符串表现形式为：索引在左边，值在右边。由于我们没有为数据指定索引。于是会自动创建一个0到N-1（N为长度）的整数型索引。</p><ul><li>DataFrame</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dates = pd.date_range(<span class="string">'20160101'</span>,periods=<span class="number">6</span>)</span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">6</span>,<span class="number">4</span>),index=dates,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line"></span><br><span class="line">print(df)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">                   a         b         c         d</span></span><br><span class="line"><span class="string">2016-01-01 -0.253065 -2.071051 -0.640515  0.613663</span></span><br><span class="line"><span class="string">2016-01-02 -1.147178  1.532470  0.989255 -0.499761</span></span><br><span class="line"><span class="string">2016-01-03  1.221656 -2.390171  1.862914  0.778070</span></span><br><span class="line"><span class="string">2016-01-04  1.473877 -0.046419  0.610046  0.204672</span></span><br><span class="line"><span class="string">2016-01-05 -1.584752 -0.700592  1.487264 -1.778293</span></span><br><span class="line"><span class="string">2016-01-06  0.633675 -1.414157 -0.277066 -0.442545</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>DataFrame是一个表格型的数据结构，它包含有一组有序的列，每列可以是不同的值类型（数值，字符串，布尔值等）。DataFrame既有行索引也有列索引， 它可以被看做由Series组成的大字典。</p><ul><li>DataFrame 的一些简单运用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">print(df[<span class="string">'b'</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">2016-01-01   -2.071051</span></span><br><span class="line"><span class="string">2016-01-02    1.532470</span></span><br><span class="line"><span class="string">2016-01-03   -2.390171</span></span><br><span class="line"><span class="string">2016-01-04   -0.046419</span></span><br><span class="line"><span class="string">2016-01-05   -0.700592</span></span><br><span class="line"><span class="string">2016-01-06   -1.414157</span></span><br><span class="line"><span class="string">Freq: D, Name: b, dtype: float64</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>我们在创建一组没有给定行标签和列标签的数据 df1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>)))</span><br><span class="line">print(df1)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">   0  1   2   3</span></span><br><span class="line"><span class="string">0  0  1   2   3</span></span><br><span class="line"><span class="string">1  4  5   6   7</span></span><br><span class="line"><span class="string">2  8  9  10  11</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>默认的从0开始 index. 还有一种生成 df 的方法, 如下 df2:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'A'</span> : <span class="number">1.</span>,</span><br><span class="line">                    <span class="string">'B'</span> : pd.Timestamp(<span class="string">'20130102'</span>),</span><br><span class="line">                    <span class="string">'C'</span> : pd.Series(<span class="number">1</span>,index=list(range(<span class="number">4</span>)),dtype=<span class="string">'float32'</span>),</span><br><span class="line">                    <span class="string">'D'</span> : np.array([<span class="number">3</span>] * <span class="number">4</span>,dtype=<span class="string">'int32'</span>),</span><br><span class="line">                    <span class="string">'E'</span> : pd.Categorical([<span class="string">"test"</span>,<span class="string">"train"</span>,<span class="string">"test"</span>,<span class="string">"train"</span>]),</span><br><span class="line">                    <span class="string">'F'</span> : <span class="string">'foo'</span>&#125;)</span><br><span class="line">                    </span><br><span class="line">print(df2)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">     A          B    C  D      E    F</span></span><br><span class="line"><span class="string">0  1.0 2013-01-02  1.0  3   test  foo</span></span><br><span class="line"><span class="string">1  1.0 2013-01-02  1.0  3  train  foo</span></span><br><span class="line"><span class="string">2  1.0 2013-01-02  1.0  3   test  foo</span></span><br><span class="line"><span class="string">3  1.0 2013-01-02  1.0  3  train  foo</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>这种方法能对每一列的数据进行特殊对待. 如果想要查看数据中的类型, 我们可以用 dtype 这个属性:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">print(df2.dtypes)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">df2.dtypes</span></span><br><span class="line"><span class="string">A           float64</span></span><br><span class="line"><span class="string">B    datetime64[ns]</span></span><br><span class="line"><span class="string">C           float32</span></span><br><span class="line"><span class="string">D             int32</span></span><br><span class="line"><span class="string">E          category</span></span><br><span class="line"><span class="string">F            object</span></span><br><span class="line"><span class="string">dtype: object</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>如果想看对列的序号:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(df2.index)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Int64Index([0, 1, 2, 3], dtype='int64')</span></span><br></pre></td></tr></table></figure><p>同样, 每种数据的名称也能看到:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(df2.columns)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Index(['A', 'B', 'C', 'D', 'E', 'F'], dtype='object')</span></span><br></pre></td></tr></table></figure><p>果只想看所有df2的值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(df2.values)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'test', 'foo'],</span></span><br><span class="line"><span class="string">       [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'train', 'foo'],</span></span><br><span class="line"><span class="string">       [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'test', 'foo'],</span></span><br><span class="line"><span class="string">       [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'train', 'foo']], dtype=object)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>想知道数据的总结, 可以用 describe():</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">df2.describe()</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">         A    C    D</span></span><br><span class="line"><span class="string">count  4.0  4.0  4.0</span></span><br><span class="line"><span class="string">mean   1.0  1.0  3.0</span></span><br><span class="line"><span class="string">std    0.0  0.0  0.0</span></span><br><span class="line"><span class="string">min    1.0  1.0  3.0</span></span><br><span class="line"><span class="string">25%    1.0  1.0  3.0</span></span><br><span class="line"><span class="string">50%    1.0  1.0  3.0</span></span><br><span class="line"><span class="string">75%    1.0  1.0  3.0</span></span><br><span class="line"><span class="string">max    1.0  1.0  3.0</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>如果想翻转数据, transpose:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">print(df2.T)</span><br><span class="line"></span><br><span class="line"><span class="string">"""                   </span></span><br><span class="line"><span class="string">0                    1                    2  \</span></span><br><span class="line"><span class="string">A                    1                    1                    1   </span></span><br><span class="line"><span class="string">B  2013-01-02 00:00:00  2013-01-02 00:00:00  2013-01-02 00:00:00   </span></span><br><span class="line"><span class="string">C                    1                    1                    1   </span></span><br><span class="line"><span class="string">D                    3                    3                    3   </span></span><br><span class="line"><span class="string">E                 test                train                 test   </span></span><br><span class="line"><span class="string">F                  foo                  foo                  foo   </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                     3  </span></span><br><span class="line"><span class="string">A                    1  </span></span><br><span class="line"><span class="string">B  2013-01-02 00:00:00  </span></span><br><span class="line"><span class="string">C                    1  </span></span><br><span class="line"><span class="string">D                    3  </span></span><br><span class="line"><span class="string">E                train  </span></span><br><span class="line"><span class="string">F                  foo  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>如果想对数据的 index 进行排序并输出:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">print(df2.sort_index(axis=<span class="number">1</span>, ascending=<span class="keyword">False</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">     F      E  D    C          B    A</span></span><br><span class="line"><span class="string">0  foo   test  3  1.0 2013-01-02  1.0</span></span><br><span class="line"><span class="string">1  foo  train  3  1.0 2013-01-02  1.0</span></span><br><span class="line"><span class="string">2  foo   test  3  1.0 2013-01-02  1.0</span></span><br><span class="line"><span class="string">3  foo  train  3  1.0 2013-01-02  1.0</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">如果是对数据 值 排序输出:</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">print(df2.sort_values(by=<span class="string">'B'</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">     A          B    C  D      E    F</span></span><br><span class="line"><span class="string">0  1.0 2013-01-02  1.0  3   test  foo</span></span><br><span class="line"><span class="string">1  1.0 2013-01-02  1.0  3  train  foo</span></span><br><span class="line"><span class="string">2  1.0 2013-01-02  1.0  3   test  foo</span></span><br><span class="line"><span class="string">3  1.0 2013-01-02  1.0  3  train  foo</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://morvanzhou.github.io/tutorials/data-manipulation/np-pd/3-1-pd-intro/" target="_blank" rel="noopener">Pandas 基本介绍</a></li></ul>]]></content>
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux入门教程</title>
      <link href="/2018/03/25/linux%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
      <content type="html"><![CDATA[<h1 id="Linux入门教程"><a href="#Linux入门教程" class="headerlink" title="Linux入门教程"></a>Linux入门教程</h1><h2 id="SSH-远程连接-Linux"><a href="#SSH-远程连接-Linux" class="headerlink" title="SSH 远程连接 Linux"></a>SSH 远程连接 Linux</h2><h3 id="Linux端配置"><a href="#Linux端配置" class="headerlink" title="Linux端配置"></a>Linux端配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure><p>查看IP地址：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure></p><h3 id="Mac端配置"><a href="#Mac端配置" class="headerlink" title="Mac端配置"></a>Mac端配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 用户名@IP地址 <span class="comment">#输入密码确认</span></span><br></pre></td></tr></table></figure><h3 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h3><p>Mac端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -f <span class="built_in">test</span> -C <span class="string">"test-key"</span> <span class="comment"># 一直回车</span></span><br><span class="line">cat test.pub <span class="comment"># 查看公钥内容</span></span><br></pre></td></tr></table></figure><p>配置公钥到服务器：将公钥内容添加到服务器的~/.ssh/authorized_keys 文件中.</p><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp   /home/yourname/.ssh/authorized_keys yourname@192.168.38.58:/home/yourname/.ssh/</span><br></pre></td></tr></table></figure><p>alias 实现命令快速登陆：做好配置之后，通过ssh可以直接登录了。对经常登录的服务器，可以将ssh登录命令的alias加到 ~/.bash_profile文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.bash_profile | grep 101</span><br><span class="line"><span class="built_in">alias</span> to-101=<span class="string">'ssh huqiu@192.168.154.101'</span></span><br></pre></td></tr></table></figure><p>登录的时候:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ to-101</span><br></pre></td></tr></table></figure><p>无法登录一般的原因：</p><ul><li><p>客户端的私钥和公钥文件位置必须位于 ~/.ssh 下。</p></li><li><p>确保双方 ~/.ssh 目录，父目录，公钥私钥，authorized_keys 文件的权限对当前用户至少要有执行权限，对其他用户最多只能有执行权限。</p></li><li><p>注意git登录，要求对公钥和私钥以及config文件，其他用户不能有任何权限。</p></li><li><p>服务器端 ~/.ssh/authorized_keys 文件名确保没错 :).</p></li></ul><p>ssh-copy-id：ssh-copy-id 是一个小脚本，你可以用这个小脚本完成以上工作。这个脚本在linux系统上一般都有。</p><p><a href="https://www.liaohuqiu.net/cn/posts/ssh-keygen-abc/" target="_blank" rel="noopener">ssh-keygen 基本用法</a></p><p>1) 使用 ssh-keygen 时，请先进入到 ~/.ssh 目录，不存在的话，请先创建。并且保证 ~/.ssh 以及所有父目录的权限不能大于 711</p><p>2) 使用 ssh-kengen 会在~/.ssh/目录下生成两个文件，不指定文件名和密钥类型的时候，默认生成的两个文件是：</p><ul><li>id_rsa</li><li>id_rsa.pub</li></ul><p>第一个是私钥文件，第二个是公钥文件。</p><p>生成ssh key的时候，可以通过 -f 选项指定生成文件的文件名，如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -f <span class="built_in">test</span>   -C <span class="string">"test key"</span> <span class="comment"># test - 文件名，"test key" - 备注</span></span><br></pre></td></tr></table></figure><h3 id="SSH-config"><a href="#SSH-config" class="headerlink" title="SSH config"></a>SSH config</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Host example                       <span class="comment"># 关键词</span></span><br><span class="line">HostName example.com           <span class="comment"># 主机地址</span></span><br><span class="line">User root                      <span class="comment"># 用户名</span></span><br><span class="line">IdentityFile ~/.ssh/id_ecdsa <span class="comment"># 认证文件</span></span><br><span class="line">Port 22                      <span class="comment"># 指定端口</span></span><br><span class="line">ControlMaster auto</span><br><span class="line">ControlPath /tmp/%r@%h:%p</span><br></pre></td></tr></table></figure><h1 id="OpenCV3-1配置"><a href="#OpenCV3-1配置" class="headerlink" title="OpenCV3.1配置"></a>OpenCV3.1配置</h1><h2 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line"><span class="comment"># 必须的，gcc编译环境</span></span><br><span class="line"></span><br><span class="line">sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev</span><br><span class="line"><span class="comment"># 必须的,包括cmake等工具</span></span><br><span class="line"></span><br><span class="line">sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev</span><br><span class="line"><span class="comment"># 可选的，看个人需要，总共5M左右</span></span><br><span class="line"></span><br><span class="line">sudo apt-get install libv4l-dev</span><br></pre></td></tr></table></figure><h2 id="下载-源码"><a href="#下载-源码" class="headerlink" title="下载 源码"></a>下载 源码</h2><p><a href="https://opencv.org/releases.html" target="_blank" rel="noopener">OpenCV</a></p><p>或着用git clone：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/opencv310</span><br><span class="line">    <span class="comment"># opencv310为自己建的，源码将放在这里</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/Itseez/opencv.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/Itseez/opencv_contrib.git</span><br></pre></td></tr></table></figure><h2 id="CMake-Opencv源码"><a href="#CMake-Opencv源码" class="headerlink" title="CMake Opencv源码"></a>CMake Opencv源码</h2><p>建立一个编译目录（例如：/build）把cmake后的文件都放在这里边。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/opencv</span><br><span class="line">mkdir build  //建立一个build目录，把cmake的文件都放着里边</span><br><span class="line"><span class="built_in">cd</span> build　　　//进入build目录</span><br></pre></td></tr></table></figure><p>cmake时ippicv_linux_20151201.tgz总是不能成功下载，故cmake之前将./downloads/linux-808b791a6eac9ed78d32a7666804320e 文件拷贝至./opencv-3.1.0/3rdparty/ippicv/ 路径下(先执行一次cmake 命令生成文件路径，在将ippicv_linux_20151201.tgz复制进去) ippicv_linux_20151201.tgz下载链接:链接: <a href="https://pan.baidu.com/s/1jBBPxXX_NqCodS5bAln4-g" target="_blank" rel="noopener">https://pan.baidu.com/s/1jBBPxXX_NqCodS5bAln4-g</a> 密码: x4sn</p><p>然后开始cmake，这里需要注意几个cmake的参数，比较重要。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/<span class="built_in">local</span> WITH_LIBV4L=ON ..</span><br></pre></td></tr></table></figure><p>切记最后’..’两个点之前要加空格！！</p><h2 id="把代码编译成可执行文件"><a href="#把代码编译成可执行文件" class="headerlink" title="把代码编译成可执行文件"></a>把代码编译成可执行文件</h2><p>这里官方推荐使用多进程编译，推荐七个进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j7 <span class="comment"># 并行运行七个jobs，这一步也在build目录中进行</span></span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">如果你要在python下运行opencv库的情况下，那就必须安装安装python-opencv</span><br><span class="line">sudo apt-get install python-opencv</span><br></pre></td></tr></table></figure><h2 id="配置库文件路径"><a href="#配置库文件路径" class="headerlink" title="配置库文件路径"></a>配置库文件路径</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c <span class="string">'echo "/usr/local/lib" &gt; /etc/ld.so.conf.d/opencv.conf'</span></span><br><span class="line"><span class="comment">#或者直接打开/etc/ld.so.conf.d/opencv.conf，添加/usr/local/lib</span></span><br><span class="line"><span class="comment">#使配置生效</span></span><br><span class="line">sudo  ldconfig(重要)</span><br></pre></td></tr></table></figure><h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo vim/etc/bash.bashrc   </span><br><span class="line"><span class="comment">#在最后加入以下两行代码</span></span><br><span class="line">PKG_CONFIG_PATH=<span class="variable">$PKG_CONFIG_PATH</span>:/usr/<span class="built_in">local</span>/lib/pkgconfig </span><br><span class="line"><span class="built_in">export</span> PKG_CONFIG_PATH  </span><br><span class="line"><span class="comment">#使配置生效</span></span><br><span class="line">sudo <span class="built_in">source</span> /etc/bash.bashrc </span><br><span class="line">（该步骤可能会报错找不到命令，原因是<span class="built_in">source</span>为root命令</span><br><span class="line">su（进入root权限）</span><br></pre></td></tr></table></figure><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --modversion opencv</span><br><span class="line">pkg-config --cflags opencv</span><br></pre></td></tr></table></figure><h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><p>我是用python+opencv的，我这里直接运行opencv自带的python的例子程序，TX1自带摄像头不能用，需要使用外接USB摄像头，插入USB接口即可，无需安装驱动，也无需改动测试代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;opencv3.1.0_dir&gt;/samples/python/</span><br><span class="line">python video.py</span><br><span class="line">python edge.py</span><br><span class="line">python facedetect.py</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.liaohuqiu.net/cn/posts/ssh-public-key-auto-login/" target="_blank" rel="noopener">https://www.liaohuqiu.net/cn/posts/ssh-public-key-auto-login/</a></li><li><a href="https://blog.csdn.net/asukasmallriver/article/details/72927860" target="_blank" rel="noopener">https://blog.csdn.net/asukasmallriver/article/details/72927860</a></li><li><a href="https://blog.csdn.net/u011440558/article/details/78358447" target="_blank" rel="noopener">https://blog.csdn.net/u011440558/article/details/78358447</a></li></ol>]]></content>
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Linux </category>
          
          <category> 入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ubuntu_16.04_env</title>
      <link href="/2018/03/25/ubuntu-16-04-env/"/>
      <content type="html"><![CDATA[<h1 id="Ubuntu-16-04-环境配置"><a href="#Ubuntu-16-04-环境配置" class="headerlink" title="Ubuntu 16.04 环境配置"></a>Ubuntu 16.04 环境配置</h1><h2 id="PCL1-8环境"><a href="#PCL1-8环境" class="headerlink" title="PCL1.8环境"></a>PCL1.8环境</h2><h3 id="第一步：安装依赖"><a href="#第一步：安装依赖" class="headerlink" title="第一步：安装依赖"></a>第一步：安装依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update  </span><br><span class="line">sudo apt-get install git build-essential linux-libc-dev  </span><br><span class="line">sudo apt-get install cmake cmake-gui   </span><br><span class="line">sudo apt-get install libusb-1.0-0-dev libusb-dev libudev-dev  </span><br><span class="line">sudo apt-get install mpi-default-dev openmpi-bin openmpi-common    </span><br><span class="line">sudo apt-get install libflann1.8 libflann-dev  </span><br><span class="line">sudo apt-get install libeigen3-dev  </span><br><span class="line">sudo apt-get install libboost-all-dev  </span><br><span class="line">sudo apt-get install libvtk5.10-qt4 libvtk5.10 libvtk5-dev  </span><br><span class="line">sudo apt-get install libqhull* libgtest-dev  </span><br><span class="line">sudo apt-get install freeglut3-dev pkg-config  </span><br><span class="line">sudo apt-get install libxmu-dev libxi-dev   </span><br><span class="line">sudo apt-get install mono-complete  </span><br><span class="line">sudo apt-get install qt-sdk openjdk-8-jdk openjdk-8-jre</span><br></pre></td></tr></table></figure><h3 id="第二步：下载源码"><a href="#第二步：下载源码" class="headerlink" title="第二步：下载源码"></a>第二步：下载源码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/PointCloudLibrary/pcl.git</span><br></pre></td></tr></table></figure><h3 id="第三步：编译源码"><a href="#第三步：编译源码" class="headerlink" title="第三步：编译源码"></a>第三步：编译源码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> pcl  </span><br><span class="line">mkdir release  </span><br><span class="line"><span class="built_in">cd</span> release  </span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=None -DCMAKE_INSTALL_PREFIX=/usr \  </span><br><span class="line">      -DBUILD_GPU=ON -DBUILD_apps=ON -DBUILD_examples=ON \  </span><br><span class="line">      -DCMAKE_INSTALL_PREFIX=/usr ..  </span><br><span class="line">make</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h3 id="第四步（可选-and-建议）：如果需要PCLVisualizer"><a href="#第四步（可选-and-建议）：如果需要PCLVisualizer" class="headerlink" title="第四步（可选 and 建议）：如果需要PCLVisualizer"></a>第四步（可选 and 建议）：如果需要PCLVisualizer</h3><p>安装OpenNI、OpenNI2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libopenni-dev   </span><br><span class="line">sudo apt-get install libopenni2-dev</span><br></pre></td></tr></table></figure><p>安装<a href="https://www.ensenso.com/support/sdk-download/?lang=de" target="_blank" rel="noopener">ensensor</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i ensenso-sdk-2.0.147-x64.deb </span><br><span class="line">sudo dpkg -i codemeter_6.40.2402.501_amd64.deb</span><br></pre></td></tr></table></figure><p>如缺少依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get -f install</span><br></pre></td></tr></table></figure><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ol><li><a href="https://blog.csdn.net/dantengc/article/details/78446600" target="_blank" rel="noopener">https://blog.csdn.net/dantengc/article/details/78446600</a></li></ol><h2 id="OpenCV环境"><a href="#OpenCV环境" class="headerlink" title="OpenCV环境"></a>OpenCV环境</h2><h2 id="Caffe-环境"><a href="#Caffe-环境" class="headerlink" title="Caffe 环境"></a>Caffe 环境</h2>]]></content>
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Linux </category>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>semap论文</title>
      <link href="/2018/03/25/semap%E8%AE%BA%E6%96%87/"/>
      <content type="html"><![CDATA[<h1 id="SeMap-数字化室内语义地图低成本自动化构建方法"><a href="#SeMap-数字化室内语义地图低成本自动化构建方法" class="headerlink" title="SeMap: 数字化室内语义地图低成本自动化构建方法"></a>SeMap: 数字化室内语义地图低成本自动化构建方法</h1><h2 id="场景图重建"><a href="#场景图重建" class="headerlink" title="场景图重建"></a>场景图重建</h2><p>使用Colmap工具来获取场景图重建结果</p><h2 id="Colmap使用方法"><a href="#Colmap使用方法" class="headerlink" title="Colmap使用方法"></a><a href="https://colmap.github.io/tutorial.html#quickstart" target="_blank" rel="noopener">Colmap使用方法</a></h2><p>场景图通过<a href="https://colmap.github.io/tutorial.html#feature-detection-and-extraction" target="_blank" rel="noopener">Feature Detection and Extraction</a>和<a href="https://colmap.github.io/tutorial.html#feature-matching-and-geometric-verification" target="_blank" rel="noopener">Feature Matching and Geometric Verification</a>两步完成。</p><p>首先使用GUI来操作。</p><h3 id="打开Colmap"><a href="#打开Colmap" class="headerlink" title="打开Colmap"></a><a href="https://colmap.github.io/tutorial.html#data-structure" target="_blank" rel="noopener">打开Colmap</a></h3><p>（1）Windows: COLMAP.bat</p><p>Mac: COLMAP.app</p><p>Linux可选为：./src/exe/colmap gui</p><p>（2）新建项目-GUI操作</p><p>File &gt; New project</p><p>在此步，首先确定生成的数据库保存位置，还要确定输入图片位置。为了方便起见，能够通过File &gt; Save project来保存整个项目。</p><p>File &gt; Open project为打开现有项目。</p><p>（3）新建项目-命令行操作</p><p>colmap gui 或 colmap gui –project_path path/to/project.ini</p><p>（4）例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/path/to/project/...</span><br><span class="line">+── images</span><br><span class="line">│   +── image1.jpg</span><br><span class="line">│   +── image2.jpg</span><br><span class="line">│   +── ...</span><br><span class="line">│   +── imageN.jpg</span><br><span class="line">+── database.db</span><br><span class="line">+── project.ini</span><br></pre></td></tr></table></figure><p>其中，/path/to/project/images为图片路径，/path/to/project/database.db为数据库保存路径，/path/to/project/project.ini为项目配置保存路径。</p><h3 id="Feature-Detection-and-Extraction"><a href="#Feature-Detection-and-Extraction" class="headerlink" title="Feature Detection and Extraction"></a>Feature Detection and Extraction</h3><p>(1) GUI操作</p><p>Processing &gt; Extract features</p><blockquote><p>如果导入现有的特征提取的文件，需有如下文件：<br><br>NUM_FEATURES 128 <br><br>X Y SCALE ORIENTATION D_1 D_2 D_3 … D_128<br><br>…<br><br>X Y SCALE ORIENTATION D_1 D_2 D_3 … D_128<br><br>where X, Y, SCALE, ORIENTATION are floating point numbers and D_1…D_128 values in the range 0…255. The file should have NUM_FEATURES lines with one line per feature. For example, if an image has 4 features, then the text file should look something like this:<br><br>4 128<br><br>1.2 2.3 0.1 0.3 1 2 3 4 … 21<br><br>2.2 3.3 1.1 0.3 3 2 3 2 … 32<br><br>0.2 1.3 1.1 0.3 3 2 3 2 … 2<br><br>1.2 2.3 1.1 0.3 3 2 3 2 … 3<br></p></blockquote><h3 id="Feature-Matching-and-Geometric-Verification"><a href="#Feature-Matching-and-Geometric-Verification" class="headerlink" title="Feature Matching and Geometric Verification"></a>Feature Matching and Geometric Verification</h3><p>Processing &gt; Match features</p><h3 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h3><p>（1）<a href="https://colmap.github.io/tutorial.html#database-management" target="_blank" rel="noopener">Database Management</a></p><p>Processing &gt; Manage database</p><p>（2）<a href="https://colmap.github.io/database.html#database-format" target="_blank" rel="noopener">Database Format</a></p><p>SQLite database file</p><p>The database contains the following tables:</p><ul><li>cameras</li><li>images</li><li>keypoints</li><li>descriptors</li><li>matches</li><li>inlier_matches</li></ul><p>Cameras and Images： The relation between cameras and images is 1-to-N. </p><p>Keypoints and Descriptors：The detected keypoints are stored as row-major float32 binary blobs, where the first two columns are the X and Y locations in the image, respectively. </p><p>Matches：Feature matching stores its output in the matches table and geometric verification in the inlier_matches table. COLMAP only uses the data in inlier_matches for reconstruction. Every entry in the two tables stores the feature matches between two unique images, where the pair_id is the row-major, linear index in the upper-triangular match matrix, generated as follows:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image_ids_to_pair_id</span><span class="params">(image_id1, image_id2)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> image_id1 &gt; image_id2:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2147483647</span> * image_id2 + image_id1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2147483647</span> * image_id1 + image_id2</span><br></pre></td></tr></table></figure><p>and image identifiers can be uniquely determined from the pair_id as:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pair_id_to_image_ids</span><span class="params">(pair_id)</span>:</span></span><br><span class="line">    image_id2 = pair_id % <span class="number">2147483647</span></span><br><span class="line">    image_id1 = (pair_id - image_id2) / <span class="number">2147483647</span></span><br><span class="line">    <span class="keyword">return</span> image_id1, image_id2</span><br></pre></td></tr></table></figure><p>The pair_id enables efficient database queries, as the matches tables may contain several hundred millions of entries. This scheme limits the maximum number of images in a database to 2147483647 (maximum value of signed 32-bit integers), i.e. image_id must be smaller than 2147483647.</p><p>The binary blobs in the matches tables are row-major uint32 matrices, where the left column are zero-based indices into the features of image_id1 and the second column into the features of image_id2. The column cols must be 2 and the rows column specifies the number of feature matches.</p>]]></content>
      
      <categories>
          
          <category> 学术 </category>
          
          <category> semap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学术 </tag>
            
            <tag> semap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>categories</title>
      <link href="/2018/03/24/categories/"/>
      <content type="html"><![CDATA[<h1 id="Categories"><a href="#Categories" class="headerlink" title="Categories"></a>Categories</h1><ul><li><p><font color="“blue”"><strong>编程: programming</strong></font></p><ul><li>C++</li><li>Java</li><li>Python</li><li>Matlab</li><li>Android</li><li>Linux</li><li>Git</li><li>Latex</li><li>PHP</li><li>IOS</li><li>数据库</li><li>网络编程</li><li>多线程</li><li>QT编程</li><li>MarkDown</li><li>DP<ul><li>Caffe</li><li>TF</li><li>PyTorch</li></ul></li><li>数据结构</li><li>算法</li></ul></li><li><p><font color="“blue”"><strong>学术: science</strong></font></p><ul><li>计算机视觉<ul><li>ICCV</li><li>CVPR</li><li>ECCV</li></ul></li><li>移动计算<ul><li>MobiCom</li><li>SigComm</li><li>InfoCom</li><li>NSDI</li><li>SenSys</li><li>PerCom</li><li>UbiComp</li></ul></li><li>机器学习&amp;深度学习<ul><li>AAAI</li><li>IJCAI</li></ul></li></ul></li><li><p><font color="“blue”"><strong>理论: theory</strong></font></p><ul><li>计算机视觉</li><li>移动计算</li><li>数学</li><li>优化算法</li><li>机器学习</li></ul></li><li><p><font color="“blue”"><strong>其他: other</strong></font></p><ul><li>Hexo博客</li><li>生活</li></ul></li></ul><h1 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h1><ul><li>论文</li><li>理论</li><li>其他</li><li>等等</li></ul>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
          <category> categories </category>
          
      </categories>
      
      
        <tags>
            
            <tag> categories </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>双目成像深度原理</title>
      <link href="/2018/03/24/%E5%8F%8C%E7%9B%AE%E6%88%90%E5%83%8F%E6%B7%B1%E5%BA%A6%E5%8E%9F%E7%90%86/"/>
      <content type="html"><![CDATA[<h1 id="相机内参数"><a href="#相机内参数" class="headerlink" title="相机内参数"></a>相机内参数</h1><p>与相机自身特性相关的参数，比如相机的焦距、像素大小等；</p><h1 id="相机外参数"><a href="#相机外参数" class="headerlink" title="相机外参数"></a>相机外参数</h1><p>在世界坐标系中的参数，比如相机的位置、旋转方向等</p><h1 id="坐标系转换"><a href="#坐标系转换" class="headerlink" title="坐标系转换"></a>坐标系转换</h1><h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><p>图像处理、立体视觉等等方向常常涉及到四个坐标系：世界坐标系、相机坐标系、图像坐标系、像素坐标系。例如下图：</p><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_1" alt=""></p><h2 id="坐标系转换-1"><a href="#坐标系转换-1" class="headerlink" title="坐标系转换"></a>坐标系转换</h2><h3 id="世界坐标系与相机坐标系"><a href="#世界坐标系与相机坐标系" class="headerlink" title="世界坐标系与相机坐标系"></a>世界坐标系与相机坐标系</h3><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_2" alt=""></p><p>于是，从世界坐标系到相机坐标系，涉及到旋转和平移（其实所有的运动也可以用旋转矩阵和平移向量来描述）。绕着不同的坐标轴旋转不同的角度，得到相应的旋转矩阵，如下图所示：</p><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_3" alt=""></p><p>从世界坐标系到相机坐标系的转换关系如下所示：</p><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_4" alt=""></p><p>那么点P在相机坐标系的坐标为：</p><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_8" alt=""></p><h3 id="相机坐标系与图像坐标系"><a href="#相机坐标系与图像坐标系" class="headerlink" title="相机坐标系与图像坐标系"></a>相机坐标系与图像坐标系</h3><p>相机坐标系到图像坐标系，属于透视投影关系，从3D转换到2D。 </p><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_5" alt=""></p><p>此时投影点p的单位还是mm，并不是pixel，需要进一步转换到像素坐标系。</p><h3 id="图像坐标系与像素坐标系"><a href="#图像坐标系与像素坐标系" class="headerlink" title="图像坐标系与像素坐标系"></a>图像坐标系与像素坐标系</h3><p>像素坐标系和图像坐标系都在成像平面上，只是各自的原点和度量单位不一样。图像坐标系的原点为相机光轴与成像平面的交点，通常情况下是成像平面的中点或者叫principal point。图像坐标系的单位是mm，属于物理单位，而像素坐标系的单位是pixel，我们平常描述一个像素点都是几行几列。所以这二者之间的转换如下：其中dx和dy表示每一列和每一行分别代表多少mm，即1pixel=dx mm </p><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_6" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>那么通过上面四个坐标系的转换就可以得到一个点从世界坐标系如何转换到像素坐标系的。</p><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_7" alt=""></p><p>其中，<img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_9" alt="">为相机的内参，<img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_10" alt="">为相机的外参，fx, fy,  cx/dx+u0, cy/dy+v0的单位均为像素。相机的内参和外参可以通过张正友标定获取,如下小节介绍。通过最终的转换关系来看，一个三维中的坐标点，的确可以在图像中找到一个对应的像素点，但是反过来，通过图像中的一个点找到它在三维中对应的点就很成了一个问题，因为我们并不知道等式左边的Zc的值。 </p><h4 id="相机内参K"><a href="#相机内参K" class="headerlink" title="相机内参K"></a>相机内参K</h4><p>在计算机视觉中，摄像机内参数矩阵如下：</p><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_11" alt=""></p><p>其中 f 为摄像机的焦距，单位一般是mm;dx,dy 为像元尺寸;u0,v0 为图像中心。fx = f/dx, fy = f/dy,分别称为x轴和y轴上的归一化焦距.</p><p>为更好的理解，举个实例：<br><br>现以NiKon D700相机为例进行求解其内参数矩阵：<br><br>就算大家身边没有这款相机也无所谓，可以在网上百度一下，很方便的就知道其一些参数—— <br><br>焦距 f = 35mm<br>   最高分辨率：4256×2832<br>     传感器尺寸：36.0×23.9 mm<br><br>根据以上定义可以有：<br><br>u0= 4256/2 = 2128<br>   v0= 2832/2 = 1416<br>  dx = 36.0/4256<br>   dy = 23.9/2832<br><br>fx = f/dx = 4137.8<br>   fy = f/dy = 4147.3<br></p><p>分辨率可以从显示分辨率与图像分辨率两个方向来分类。<br><br>[1]显示分辨率（屏幕分辨率）是屏幕图像的精密度，是指显示器所能显示的像素有多少。由于屏幕上的点、线和面都是由像素组成的，<br>显示器可显示的像素越多，画面就越精细，同样的屏幕区域内能显示的信息也越多，所以分辨率是个非常重要的性能指标之一。<br>可以把整个图像想象成是一个大型的棋盘，而分辨率的表示方式就是所有经线和纬线交叉点的数目。<br>显示分辨率一定的情况下，显示屏越小图像越清晰，反之，显示屏大小固定时，显示分辨率越高图像越清晰。<br><br>[2]图像分辨率则是单位英寸中所包含的像素点数，其定义更趋近于分辨率本身的定义。</p><h4 id="畸变参数（与点集如何畸变的2D几何相关。）"><a href="#畸变参数（与点集如何畸变的2D几何相关。）" class="headerlink" title="畸变参数（与点集如何畸变的2D几何相关。）"></a>畸变参数（与点集如何畸变的2D几何相关。）</h4><p>采用理想针孔模型，由于通过针孔的光线少，摄像机曝光太慢，在实际使用中均采用透镜，可以使图像生成迅速，但代价是引入了畸变。</p><p>有两种畸变对投影图像影响较大： 径向畸变和切向畸变。</p><p>(1) 对某些透镜，光线在远离透镜中心的地方比靠近中心的地方更加弯曲，产生“筒形”或“鱼眼”现象，称为径向畸变。一般来讲，成像仪中心的径向畸变为0，越向边缘移动，畸变越严重。不过径向畸变可以通过下面的泰勒级数展开式来校正：</p><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_12" alt=""></p><p>这里（x, y）是畸变点在成像仪上的原始位置，r为该点距离成像仪中心的距离，（xcorrected ，ycorrected ）是校正后的新位置。</p><p>对于一般的摄像机校正，通常使用泰勒级数中的前两项k1和k2就够了；对畸变很大的摄像机，比如鱼眼透镜，可以使用第三径向畸变项k3.</p><p>(2) 当成像仪被粘贴在摄像机的时候，会存在一定的误差，使得图像平面和透镜不完全平行，从而产生切向畸变。也就是说，如果一个矩形被投影到成像仪上时，可能会变成一个梯形。切向畸变可以通过如下公式来校正：</p><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_13" alt=""></p><p>这里（x, y）是畸变点在成像仪上的原始位置，r为该点距离成像仪中心的距离，（xcorrected ，ycorrected ）是校正后的新位置。</p><h4 id="摄像机的外参数"><a href="#摄像机的外参数" class="headerlink" title="摄像机的外参数"></a>摄像机的外参数</h4><p>旋转向量（大小为1×3的矢量或旋转矩阵3×3）和平移向量（tx,ty,tz）。</p><p>旋转向量:旋转向量是旋转矩阵紧凑的变现形式，旋转向量为1×3的行矢量。</p><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_14" alt=""></p><p>r就是旋转向量，旋转向量的方向是旋转轴 ,旋转向量的模为围绕旋转轴旋转的角度。</p><p>通过上面的公式，我们就可以求解出旋转矩阵R。同样的已知旋转矩阵，我们也可以通过下面的公式求解得到旋转向量：</p><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_15" alt=""></p><h1 id="相机标定（或摄像机标定）"><a href="#相机标定（或摄像机标定）" class="headerlink" title="相机标定（或摄像机标定）"></a>相机标定（或摄像机标定）</h1><p>摄像机标定(Camera calibration)简单来说是从世界坐标系换到图像坐标系的过程，也就是求最终的投影矩阵的过程。</p><p>那为什么要做相机标定呢？<br><br>【1】进行摄像机标定的目的：求出相机的内、外参数，以及畸变参数。<br><br>【2】标定相机后通常是想做两件事：一个是由于每个镜头的畸变程度各不相同，通过相机标定可以校正这种镜头畸变矫正畸变，生成矫正后的图像；另一个是根据获得的图像重构三维场景。<br><br>摄像机标定过程，简单的可以简单的描述为通过标定板，如下图，可以得到n个对应的世界坐标三维点Xi和对应的图像坐标二维点xi，这些三维点到二维点的转换都可以通过上面提到的相机内参K，相机外参R和t，以及畸变参数D，经过一系列的矩阵变换得到。<br></p><h2 id="标定原理"><a href="#标定原理" class="headerlink" title="标定原理"></a>标定原理</h2><p>原理推导请参考<a href="https://zhuanlan.zhihu.com/p/24651968" target="_blank" rel="noopener">张氏法相机标定</a></p><h2 id="标定方法"><a href="#标定方法" class="headerlink" title="标定方法"></a>标定方法</h2><h3 id="摄像机标定方法分类"><a href="#摄像机标定方法分类" class="headerlink" title="摄像机标定方法分类"></a>摄像机标定方法分类</h3><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_17" alt=""></p><h3 id="使用Matlab相机标定工具箱标定相机的基本步骤"><a href="#使用Matlab相机标定工具箱标定相机的基本步骤" class="headerlink" title="使用Matlab相机标定工具箱标定相机的基本步骤"></a>使用Matlab相机标定工具箱标定相机的基本步骤</h3><p>参考：</p><ol><li><a href="http://www.cnblogs.com/star91/p/6012425.html" target="_blank" rel="noopener">http://www.cnblogs.com/star91/p/6012425.html</a></li><li><a href="https://blog.csdn.net/wangxiaokun671903/article/details/38925553" target="_blank" rel="noopener">https://blog.csdn.net/wangxiaokun671903/article/details/38925553</a></li></ol><h3 id="使用OpenCV进行相机标定"><a href="#使用OpenCV进行相机标定" class="headerlink" title="使用OpenCV进行相机标定"></a>使用OpenCV进行相机标定</h3><p>参考：</p><ol><li><a href="https://blog.csdn.net/dcrmg/article/details/52929669" target="_blank" rel="noopener">Opencv 张正友相机标定傻瓜教程</a></li><li><a href="https://blog.csdn.net/u010784534/article/details/24323643" target="_blank" rel="noopener">使用OpenCV进行相机标定(基于OpenCV2.4.3)</a></li><li><a href="https://blog.csdn.net/dcrmg/article/details/52939318" target="_blank" rel="noopener">张正友相机标定Opencv实现以及标定流程&amp;&amp;标定结果评价&amp;&amp;图像矫正流程解析（附标定程序和棋盘图）</a></li></ol><h1 id="双目立体视觉深度相机详细原理"><a href="#双目立体视觉深度相机详细原理" class="headerlink" title="双目立体视觉深度相机详细原理"></a>双目立体视觉深度相机详细原理</h1><h2 id="理想双目相机成像模型"><a href="#理想双目相机成像模型" class="headerlink" title="理想双目相机成像模型"></a>理想双目相机成像模型</h2><p>首先我们从理想的情况开始分析:假设左右两个相机位于同一平面（光轴平行），且相机参数（如焦距f）一致。那么深度值的推导原理和公式如下。公式只涉及到初中学的三角形相似知识，不难看懂。</p><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_18" alt=""><br><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_19" alt=""><br><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_20" alt=""></p><p>根据上述推导，空间点P离相机的距离（深度）z=f*b/d，可以发现如果要计算深度z，必须要知道：</p><p>（1）、相机焦距f，左右相机基线b。这些参数可以通过先验信息或者相机标定得到。</p><p>（2）、视差d。需要知道左相机的每个像素点(xl, yl)和右相机中对应点(xr, yr)的对应关系。这是双目视觉的核心问题。</p><h2 id="极线约束"><a href="#极线约束" class="headerlink" title="极线约束"></a>极线约束</h2><p>那么问题来了，对于左图中的一个像素点，如何确定该点在右图中的位置？是不是需要我们在整个图像中地毯式搜索一个个匹配？</p><p>答案是：不需要。因为有极线约束（名字听着很吓人）。极线约束对于求解图像对中像素点的对应关系非常重要。</p><p>那什么是极线呢？如下图所示。C1，C2是两个相机，P是空间中的一个点，P和两个相机中心点C1、C2形成了三维空间中的一个平面PC1C2，称为极平面（Epipolar plane）。极平面和两幅图像相交于两条直线，这两条直线称为极线(Epipolar line)。P在相机C1中的成像点是P1，在相机C2中的成像点是P2，但是P的位置事先是未知的。</p><p>我们的目标是：对于左图的P1点，寻找它在右图中的对应点P2，这样就能确定P点的空间位置，也就是我们想要的空间物体和相机的距离（深度）。</p><p>所谓极线约束（Epipolar Constraint）就是指当同一个空间点在两幅图像上分别成像时，已知左图投影点p1，那么对应右图投影点p2一定在相对于p1的极线上，这样可以极大的缩小匹配范围。</p><p><img src="http://p55se4hrx.bkt.clouddn.com/images/theory/computer_vision/1_camera_21" alt=""></p><p>根据极线约束的定义，我们可以在下图中直观的看到P2一定在对极线上，所以我们只需要沿着极线搜索一定可以找到和P1的对应点P2。</p><p>细心的朋友会发现上述过程考虑的情况（两相机共面且光轴平行，参数相同）非常理想，相机C1，C2如果不是在同一直线上怎么办？</p><p>事实上，这种情况非常常见，因为有些场景下两个相机需要独立固定，很难保证光心C1，C2完全水平，即使是固定在同一个基板上也会因为装配的原因导致光心不完全水平。如下图所示。我们看到两个相机的极线不仅不平行，还不共面，之前的理想模型那一套推导结果用不了了，这可咋办呢？</p><p>把不理想情况转化为理想情况不就OK了！这就是图像矫正（Image Rectification）技术。</p><p>参考：<a href="https://zhuanlan.zhihu.com/p/32199990" target="_blank" rel="noopener">深度相机原理揭秘–双目立体视觉</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://www.bijishequ.com/detail/397458" target="_blank" rel="noopener">http://www.bijishequ.com/detail/397458</a></li><li><a href="https://www.cnblogs.com/Jessica-jie/p/6596450.html" target="_blank" rel="noopener">https://www.cnblogs.com/Jessica-jie/p/6596450.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/32199990" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32199990</a></li><li><a href="https://cloud.tencent.com/developer/article/1015777" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1015777</a></li></ol>]]></content>
      
      <categories>
          
          <category> 理论 </category>
          
          <category> 计算机视觉 </category>
          
          <category> 成像原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 理论 </tag>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于hexo+github免费搭建个人博客</title>
      <link href="/2018/03/04/%E5%9F%BA%E4%BA%8EHexo+GitHub%20Pages%20%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <content type="html"><![CDATA[<h1 id="一、Hexo简介"><a href="#一、Hexo简介" class="headerlink" title="一、Hexo简介"></a>一、Hexo简介</h1><p>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。这里我们选用的是GitHub。Hexo同时也是GitHub上的开源项目，参见：<a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">hexojs/hexo</a> 如果想要更加全面的了解Hexo，可以到其官网 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 了解更多的细节，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。</p><h1 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h1><h1 id="三、环境配置"><a href="#三、环境配置" class="headerlink" title="三、环境配置"></a>三、环境配置</h1><h2 id="1-本机环境配置"><a href="#1-本机环境配置" class="headerlink" title="1. 本机环境配置"></a>1. 本机环境配置</h2><ol><li><p>安装Node.js</p><p> 下载<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node.js</a>,注意安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js是否安装成功，在命令行中输入 node -v. 检测npm是否安装成功，在命令行中输入npm -v</p></li><li><p>安装Hexo</p></li></ol><ul><li><p>Hexo就是我们的个人博客网站的框架， 这里需要自己在电脑常里创建一个文件夹，可以命名为Blog，Hexo框架与以后你自己发布的网页都在这个文件夹中。创建好后，进入文件夹中,使用npm命令安装Hexo，输入：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo <span class="comment">#等待一会就会完成下载安装。</span></span><br><span class="line">hexo init <span class="comment">#该命令会在目标文件夹内建立网站所需要的所有文件</span></span><br><span class="line">npm install <span class="comment">#安装依赖包</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>到这里本地博客就搭建好了。执行以下命令（在你博客的对应文件夹路径下）:</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate <span class="comment"># Or hexo g</span></span><br><span class="line">hexo server   <span class="comment"># Or hexo s</span></span><br></pre></td></tr></table></figure></li><li><p>在浏览器输入<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 就可以进行查看了。当然这个博客是本地的，别人是无法访问的，之后我们需要部署到GitHub上。常用的Hexo 命令:</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g <span class="comment">#安装Hexo</span></span><br><span class="line">npm update hexo -g <span class="comment">#升级</span></span><br><span class="line">hexo init <span class="comment">#初始化博客</span></span><br><span class="line"><span class="comment"># 命令简写</span></span><br><span class="line">hexo n <span class="string">"我的博客"</span> == hexo new <span class="string">"我的博客"</span> <span class="comment">#新建文章</span></span><br><span class="line">hexo g == hexo generate <span class="comment">#生成</span></span><br><span class="line">hexo s == hexo server <span class="comment">#启动服务预览</span></span><br><span class="line">hexo d == hexo deploy <span class="comment">#部署</span></span><br><span class="line">hexo server <span class="comment">#Hexo会监视文件变动并自动更新，无须重启服务器</span></span><br><span class="line">hexo server -s <span class="comment">#静态模式</span></span><br><span class="line">hexo server -p 5000 <span class="comment">#更改端口</span></span><br><span class="line">hexo server -i 192.168.1.1 <span class="comment">#自定义 IP</span></span><br><span class="line">hexo clean <span class="comment">#清除缓存，若是网页正常情况下可以忽略这条命令</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-git环境配置"><a href="#2-git环境配置" class="headerlink" title="2. git环境配置"></a>2. git环境配置</h2><ol><li><p>注册Github账号并新建仓库</p><ul><li>注册过程就不多说了，注册完成之后需要新建一个仓库。需要注意的是新创建的仓库的名字，必须是username.github.io。例如我的username是XXX，那么新创建的仓库的名字便是XXX.github.io。</li></ul></li><li><p>配置SSH Key</p></li></ol><ul><li><p>这一步不是必须的，配置SSH Key的话之后每次更新博客就不用都输入用户名和密码，可以方便一些。</p><p>  (1)检查本机上是否已经存在SSH Key。打开终端，输入如下命令：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> .ssh</span><br><span class="line">ls -la</span><br></pre></td></tr></table></figure><p>  检查终端输出的文件列表中是否已经存在id_rsa.pub 或 id_dsa.pub 文件，如果文件已经存在，则直接进入第三步。</p><p>  (2)创建一个SSH Key。在终端输入如下命令:</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"your_email@example.com"</span></span><br></pre></td></tr></table></figure><pre><code>按下回车，让你输入文件名，直接回车会创建使用默认文件名的文件(推荐使用默认文件名)，然后会提示你输入两次密码，可以为空。</code></pre><p>  (3)添加SSH Key到Github</p><pre><code>如果你没有指定文件名（也就是使用的默认文件名），那么你的.ssh文件夹下，应该有一个id_rsa.pub文件了，打开该文件，复制里面的文本。然后登录Github，点击右上角头像右边的三角图标，点击Settings，然后在左边菜单栏点击SSH and GPG keys，点击New SSH key，Title 随便填一个，在Key栏填入你复制的内容，点击Add SSH key，就添加成功了。</code></pre><p>  (4)检验SSH Key是否配置成功。在终端输入如下命令:</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></li></ul><pre><code>    如果出现:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Are you sure you want to <span class="built_in">continue</span> connecting (yes/no)?</span><br></pre></td></tr></table></figure>    请输入yes再按回车。如果最后出现:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi username! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure>    就说明你的SSH Key配置成功了。</code></pre><h2 id="3-同步本地博客到Github"><a href="#3-同步本地博客到Github" class="headerlink" title="3. 同步本地博客到Github"></a>3. 同步本地博客到Github</h2><ol><li><p>上面只是在本地预览，接下来要做的就是就是推送网站，也就是发布网站，让我们的网站可以被更多的人访问。在设置之前，需要解释一个概念，在blog根目录里的_config.yml文件称为站点配置文件.</p></li><li><p>我们的Hexo与GitHub关联起来，打开站点的配置文件_config.yml，翻到最后修改为：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy: </span><br><span class="line">type: git</span><br><span class="line">repo: 这里填入你之前在GitHub上创建仓库的完整路径，记得加上 .git</span><br><span class="line">branch: master参考如下：</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>例子：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line"><span class="built_in">type</span>: git</span><br><span class="line">repo: https://github.com/xiaoqiangteng/xiaoqiangteng.github.io.git</span><br><span class="line">brabch: master</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>保存站点配置文件。其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。最后安装Git部署插件，输入命令：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>这时，我们分别输入三条命令：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li></ol><pre><code>其实第三条的 hexo d 就是部署网站命令，d是deploy的缩写。完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径</code></pre><ol><li><p>发布新的博客</p><ul><li><p>既然博客已经搭建好了，那么不发几篇博文有就没有意义了，使用下面的命令来新建一篇叫做”brightloong”的文章。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">'brightloong'</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><pre><code>- 命令执行之后，你会在你文件博客根目录的source/_post目录下找到你刚刚新建的md后缀的文件，hexo博客是使用markdown语法来书写的，如果不熟悉markdown语法可以快速的看一下[markdown](https://www.appinn.com/markdown/)语法说明.&gt; 注意：在冒号后面一定要加上一个空格，否则在生成静态文件的时候会报错，并且也不能将其成功推送到github。<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: brightloong #文章标题</span><br><span class="line">date: 2017-02-24 12:03:12 #创建时间</span><br><span class="line">tags: #文章标签，如果有多个标签可以使用[1,2,3]的形式，还有其他形式自己摸索吧</span><br><span class="line">---</span><br><span class="line"><span class="section">#这之后是正文</span></span><br></pre></td></tr></table></figure>- 文章编写好之后，只用以下命令生成静态文件并推送到github上，执行完成后打开自己的博客页面，是不是发现刚刚编写的文章出现了；如果你想删除某一篇文章，那么在source/_post目录下找到对应的文章将其删除后，同样执行一下命令就OK了。</code></pre><ol><li><p>站点配置文件_config.yml</p><ul><li><p>站点配置文件_config.yml是在你博客保存目录的根目录下，注意将它与主题配置文件进行区分，我使用的主题是Next主题。下面我先介绍下站点配置文件，我将一些主要的配置做了注释，如果你想了解更多的配置的含义和作用，请访问<a href="https://hexo.io/docs/configuration.html" target="_blank" rel="noopener">Hexo官方教程</a>查看。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">BrightLoong's</span> <span class="string">Blog</span> <span class="comment">#博客的标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="comment">#子标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">Remember</span> <span class="string">what</span> <span class="string">should</span> <span class="string">be</span> <span class="string">remembered,</span> <span class="string">and</span> <span class="string">forget</span> <span class="string">what</span> <span class="string">should</span> <span class="string">be</span> <span class="string">forgotten.Alter</span> <span class="string">what</span> <span class="string">is</span> <span class="string">changeable,</span> <span class="string">and</span> <span class="string">accept</span> <span class="string">what</span> <span class="string">is</span> <span class="string">mutable.</span> <span class="comment">#博客描述，可以是一段你喜欢的话，也可以是你博客的描述，只要你开心就好。</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">BrightLoong</span> <span class="comment">#作者</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-Hans</span> <span class="comment">#语言（我使用的是简体中文）</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="comment">#时区（默认使用电脑时间）</span></span><br><span class="line"><span class="comment">##之下的保持默认就好，没有什么需要更改的</span></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' #and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="attr">https://brightloong.github.io</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span> <span class="comment">#source目录</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span> <span class="comment">#标签目录</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span> </span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span> <span class="comment">#分类目录</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span> <span class="string">static/**</span> <span class="comment">#注意这个属性（跳过渲染），你暂时不用配置，我之后会讲到，这个也是我遇到的坑</span></span><br><span class="line"><span class="comment">##之下的保持默认就好，没有什么需要更改的</span></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># File name of new posts</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  line_number:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  auto_detect:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  tab_replace:</span></span><br><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line"><span class="comment"># Date / Time format</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="attr">HH:mm:ss</span></span><br><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span> <span class="comment">#你设置的主题，接下来我会说到这个</span></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repository:</span> <span class="attr">https://github.com/BrightLoong/BrightLoong.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="设置专属域名"><a href="#设置专属域名" class="headerlink" title="设置专属域名"></a>设置专属域名</h2><p>博客搭建好后，我们可以通过之前设置好的GitHub仓库地址来访问，比如：<a href="http://XXX.github.io，而且GitHub是免费替我们托管的的，如果我们想要设置自己的专属的域名，我们可以去阿里云购买域名，我们点击添加记录，设置主机记录为@，类型为A，到IP" target="_blank" rel="noopener">http://XXX.github.io，而且GitHub是免费替我们托管的的，如果我们想要设置自己的专属的域名，我们可以去阿里云购买域名，我们点击添加记录，设置主机记录为@，类型为A，到IP</a> 192.30.252.153（固定值）。按照如上设置完成之后， 可能不会立即生效，等个几分钟，在./source目录下新建文件CNAME（没有后缀名），文件中写上我们要绑定的域名，例如: XXX.com.部署到GitHub上。这时就可以通过<a href="http://XXX.com访问" target="_blank" rel="noopener">http://XXX.com访问</a>.</p><h1 id="四、Hexo配置"><a href="#四、Hexo配置" class="headerlink" title="四、Hexo配置"></a>四、Hexo配置</h1><h2 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h2><p>搭建自己的博客，最吸引人的莫过于那千变万化的主题了，大家可以在<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo官网</a>上看到无数漂亮、大方、简洁的主题。本人使用的是简洁的<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">Next主题</a>，你可以选择你喜欢的下载下来，将其解压放入themes目录中，比如我的目录是.\themes，然后修改我在上面提到的站点配置文件中的theme属性，为你刚刚放入themes目录中文件的名字（最好是对解压文件修改一个名字，否则名字可能会比较长，我把我下载下来的主题改文了next）,做完这些之后并不代表你完成了，你还需要参考你所下载的主题所说的配置步骤进行相关的配置，由于不同的主题配置过程也尽不相同，大家根据自己下载的主题去配置，我在这里只说我使用的Next主题如何配置。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：从下面开始所说的都是Next主题的相关配置。</p></blockquote><p>如果你使用的和我一样，也是Next的主题，那么你最好还是看官方提供<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">Next使用文档</a>，并且文档是中文版的,我也仅仅是讲一些容易被忽略的配置，以及我使用的配置，以及在使用过程中遇到的问题;至于如何更换头像，添加分类和标签页面、切换主题样式（Next主题包含3中样式）之类的，大家还是照着官方的做更好。</p><ol><li><p>配置网站图标 </p><p> 如何让网站前能显示自己想要的图标，我当时也是找了很久，最后发现是在主题配置文件（我的是F:\myblog\themes\next_config.yml）的最前面，有一个favicon属性，我把一个名字叫favicon.ico的图片放到了F:\myblog\source下，然后配置如下：</p> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">favicon:</span> <span class="string">/favicon.ico</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>首页显示阅读全文按钮</p><p> 首页的文章是不是默认展开了，显示出了整篇文章，怎么才能显示出如下的阅读全文的按钮。在主题配置文件中找到auto_excerpt属性进行配置:</p> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line"> <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">#改写为true</span></span><br><span class="line"><span class="attr">   length:</span> <span class="number">150</span> <span class="comment">#默认展示的高度</span></span><br></pre></td></tr></table></figure></li></ol><pre><code>你也可以在自己的博文中添加\&lt;!--more--&gt;来决定在首页展示到什么位置（我就喜欢用这种方式），这个标签后的内容就不会展示到首页啦。</code></pre><h2 id="修改文章内链接文本样式"><a href="#修改文章内链接文本样式" class="headerlink" title="修改文章内链接文本样式"></a>修改文章内链接文本样式</h2><p>修改文件 themes\next\source\css_common\components\post\post.styl，在末尾添加如下css样式，：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 文章内链接文本样式</span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0593d3</span>;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    <span class="selector-tag">color</span>: <span class="selector-id">#fc6423</span>;</span><br><span class="line">    <span class="selector-tag">border-bottom</span>: <span class="selector-tag">none</span>;</span><br><span class="line">    <span class="selector-tag">border-bottom</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#fc6423</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中选择.post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。</p><h2 id="在每篇文章末尾统一添加“本文结束”标记"><a href="#在每篇文章末尾统一添加“本文结束”标记" class="headerlink" title="在每篇文章末尾统一添加“本文结束”标记"></a>在每篇文章末尾统一添加“本文结束”标记</h2>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo使用攻略-添加分类及标签</title>
      <link href="/2018/03/04/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/"/>
      <content type="html"><![CDATA[<h1 id="Hexo使用攻略-添加分类及标签"><a href="#Hexo使用攻略-添加分类及标签" class="headerlink" title="Hexo使用攻略-添加分类及标签"></a>Hexo使用攻略-添加分类及标签</h1><h2 id="创建“分类”选项"><a href="#创建“分类”选项" class="headerlink" title="创建“分类”选项"></a>创建“分类”选项</h2><p>###生成“分类”页并添加tpye属性</p><p>打开命令行，进入博客所在文件夹。执行命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure><p>成功后会提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Created: ~/Documents/blog/source/categories/index.md</span><br></pre></td></tr></table></figure></p><p>根据上面的路径，找到index.md这个文件，打开后默认内容是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2017-05-27 13:47:40</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>保存并关闭文件。</p><h3 id="给文章添加“categories”属性"><a href="#给文章添加“categories”属性" class="headerlink" title="给文章添加“categories”属性"></a>给文章添加“categories”属性</h3><p>打开需要添加分类的文章，为其添加categories属性。下方的categories: web前端表示添加这篇文章到“web前端”这个分类。注意：hexo一篇文章只能属于一个分类，也就是说如果在“- web前端”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- web前端”下的 “-xxx ”分类）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: jQuery对表单的操作及更多应用</span><br><span class="line">date: 2017-05-26 12:12:57</span><br><span class="line">categories: </span><br><span class="line">- web前端</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了categories: xxx的文章才会被收录到首页的“分类”中。</p><p>注意：如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>或</p><h3 id="设置分类列表"><a href="#设置分类列表" class="headerlink" title="设置分类列表"></a>设置分类列表</h3><p>在我们编辑文章的时候，直接在categories:项填写属于哪个分类，但如果分类是中文的时候，路径也会包含中文。<br>比如分类我们设置的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">categories: 编程</span><br></pre></td></tr></table></figure><p>那在生成页面后，分类列表就会出现编程这个选项，他的访问路径是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">那在生成页面后，分类列表就会出现编程这个选项，他的访问路径是：</span><br></pre></td></tr></table></figure><p>如果我们想要把路径名和分类名分别设置，需要怎么办呢？</p><p>打开根目录下的配置文件_config.yml，找到如下位置做更改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Category &amp; Tag</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">编程: programming</span><br><span class="line">生活: life</span><br><span class="line">其他: other</span><br><span class="line">tag_map:</span><br></pre></td></tr></table></figure><p>在这里category_map:是设置分类的地方，每行一个分类，冒号前面是分类名称，后面是访问路径。</p><p>可以提前在这里设置好一些分类，当编辑的文章填写了对应的分类名时，就会自动的按照对应的路径来访问。</p><h2 id="创建“标签”选项"><a href="#创建“标签”选项" class="headerlink" title="创建“标签”选项"></a>创建“标签”选项</h2><h3 id="生成“标签”页并添加tpye属性"><a href="#生成“标签”页并添加tpye属性" class="headerlink" title="生成“标签”页并添加tpye属性"></a>生成“标签”页并添加tpye属性</h3><p>打开命令行，进入博客所在文件夹。执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure><p>成功后会提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Created: ~/Documents/blog/source/tags/index.md</span><br></pre></td></tr></table></figure><p>根据上面的路径，找到index.md这个文件，打开后默认内容是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2017-05-27 14:22:08</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>添加type: “tags”到内容中，添加后是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2017-05-27 13:47:40</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>保存并关闭文件。</p><h3 id="给文章添加“tags”属性"><a href="#给文章添加“tags”属性" class="headerlink" title="给文章添加“tags”属性"></a>给文章添加“tags”属性</h3><p>打开需要添加标签的文章，为其添加tags属性。下方的tags:下方的- jQuery - 表格<br>- 表单验证就是这篇文章的标签了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: jQuery对表单的操作及更多应用</span><br><span class="line">date: 2017-05-26 12:12:57</span><br><span class="line">categories: </span><br><span class="line">- web前端</span><br><span class="line">tags:</span><br><span class="line">- jQuery</span><br><span class="line">- 表格</span><br><span class="line">- 表单验证</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>至此，成功给文章添加分类，点击首页的“标签”可以看到该标签下的所有文章。当然，只有添加了tags: xxx的文章才会被收录到首页的“标签”中。</p><h2 id="新建页面的模板"><a href="#新建页面的模板" class="headerlink" title="新建页面的模板"></a>新建页面的模板</h2><p>打开scaffolds/post.md文件，在tages:上面加入categories:,保存后，重新执行hexo n ‘name’命令，会发现新建的页面里有categories:项了。</p><p>scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。</p><h2 id="菜单中添加链接"><a href="#菜单中添加链接" class="headerlink" title="菜单中添加链接"></a>菜单中添加链接</h2><p>编辑主题的 _config.yml ，将 menu 中的 categories: /categories 注释去掉，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /</span><br><span class="line">  categories: /categories</span><br><span class="line">  archives: /archives</span><br><span class="line">  tags: /tags</span><br></pre></td></tr></table></figure><p>在主题配置文件中添加分类选项</p><p>在主题配置文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">themes/_config.yml</span><br></pre></td></tr></table></figure><p>中添加以下代码（#号后为注释内容）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  主页: /</span><br><span class="line">  所有文章: /archives</span><br><span class="line">  技巧经验: /categories/技巧经验     # 博客首页展示文本： 访问路径/自定义归档名称</span><br><span class="line">  资料总结: /categories/资料总结</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/03/03/hello-world/"/>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
